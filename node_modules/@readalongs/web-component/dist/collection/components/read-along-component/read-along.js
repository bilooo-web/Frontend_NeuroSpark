import { Howl } from "howler";
import { Subject } from "rxjs";
import { distinctUntilChanged } from "rxjs/operators";
import { Fragment, h, } from "@stencil/core";
import { parseRAS, Sprite, extractPages, extractAlignment, isFileAvailable, isIOS, getUserPreferences, USER_PREFERENCE_VERSION, setUserPreferences, extractMeta, sentenceIsAligned, hasUserPreferences, clearUserPreferences, } from "../../utils/utils";
import { web_component as eng_strings } from "../../i18n/messages.eng.json";
import { web_component as fra_strings } from "../../i18n/messages.fra.json";
import { web_component as spa_strings } from "../../i18n/messages.spa.json";
import { PACKAGE_VERSION } from "../../version";
import { MatIcon } from "../../utils/mat-icon";
const LOADING = 0;
const LOADED = 1;
const ERROR_PARSING = 2;
const ERROR_LOADING = 3;
// The length of time an error message stays on the screen. 0 (and negative)
// values disables this functionality.
const DEFAULT_ERROR_TIMEOUT_MS = 50000;
/**
 * navigatorTheme returns the user's preferred theme, defaults to the
 * light theme.
 */
function navigatorTheme() {
    if (window.matchMedia) {
        if (window.matchMedia("prefers-color-scheme: dark").matches) {
            return "dark";
        }
    }
    return "light";
}
export class ReadAlongComponent {
    constructor() {
        this.reading$ = new Subject(); // An RxJs Subject for the current item being read.
        /**
         * Theme to use: ['light', 'dark'] defaults to the user's configured theme.
         */
        this.theme = navigatorTheme();
        /**
         * Language  of the interface. In 639-3 code.
         * Options are "eng" (English), "fra" (French) or "spa" (Spanish)
         */
        this.language = "eng";
        /**
         * i18n strings dicts
         */
        this.i18nStrings = { eng: eng_strings, fra: fra_strings, spa: spa_strings };
        /**
         * Define a path for where the image assets are located
         * This should be used instead of use-assets-folder.
         * Defaults to 'assets/'. The empty string means that
         * image paths will not have a prefix added to them.
         * Use of the forward slash is optional.
         */
        this.imageAssetsFolder = "assets/";
        /**
         * Toggles the page scrolling from horizontal to vertical. Defaults to horizontal
         *
         */
        this.pageScrolling = "horizontal";
        /**
         * Choose mode of ReadAlong - either view (default) or edit
         */
        this.mode = "VIEW";
        /**
         * Select whether scrolling between pages should be "smooth" (default nicely
         * animated, good for fast computers) or "auto" (choppy but much less compute
         * intensive)
         */
        this.scrollBehaviour = "smooth";
        /**
         * Show text translation  on at load time
         */
        this.displayTranslation = true;
        /**
         * Control the range of the playback rate: allow speeds
         * from 100 - playback-rate-range to 100 + playback-rate-range.
         */
        this.playbackRateRange = 15;
        /**
         * Auto Pause at end of every page
         */
        this.autoPauseAtEndOfPage = false;
        /************
         *  STATES  *
         ************/
        /**
         * Whether audio is playing or not
         */
        this.playing = false;
        this.playback_rate = 1;
        this.fullscreen = false;
        this.autoScroll = true;
        this.hasLoaded = 0;
        this.showGuide = false;
        this.hasTextTranslations = false;
        this.invalidImages = {};
        this.assetsStatus = {
            AUDIO: LOADING,
            RAS: LOADING,
        };
        this.alignment_failed = false;
        this.isScrolling = false;
        this.scrollTimer = null;
        this.endOfPageTags = {};
        this.settingsVisible = false;
        this.userPreferencesDirty = false;
        this.hasUserPreferences = hasUserPreferences();
        this.meta = {};
        this.annotations = [];
        this.annotationsMenuVisible = false;
        /**********
         * RENDER *
         **********/
        /**
         * The Guide element
         */
        this.Guide = () => (h("button", { class: "scroll-guide__container ripple ui-button theme--" +
                this.userPreferences.theme, onClick: () => this.hideGuideAndScroll() }, h("span", { class: "scroll-guide__text theme--" + this.userPreferences.theme }, this.getI18nString("re-align"))));
        /**
         * Render svg overlay
         */
        this.Overlay = () => (h("object", { onClick: (e) => this.goToSeekFromProgress(e), id: "overlay__object", type: "image/svg+xml", data: this.svgOverlay }));
        /**
         * Remove image at given page
         *
         * @param props
         */
        this.RemoveImg = (props) => {
            return (h("button", { "data-test-id": "delete-button", "aria-label": "Delete", title: "Delete image", onClick: () => this.deleteImage(props.pageIndex), id: "img-remover", class: "ripple theme--" +
                    this.userPreferences.theme +
                    " background--" +
                    this.userPreferences.theme }, h(MatIcon, null, "delete")));
        };
        /**
         * Render image at path 'url' in assets folder.
         *
         * @param props
         */
        this.Img = (props) => {
            return (h("div", { class: "image__container page__col__image theme--" +
                    this.userPreferences.theme }, this.mode === "EDIT" && (h("span", { id: "image-container" }, h(this.RemoveImg, { pageIndex: props.pageIndex }))), h("img", { alt: "image", class: "image", src: props.imgURL })));
        };
        this.ImgPlaceHolder = (props) => {
            return (h("div", { class: "image__container page__col__image theme--" +
                    this.userPreferences.theme }, h("div", { class: "drop-area" }, h("form", { class: "my-form" }, h("p", { class: "theme--" + this.userPreferences.theme }, this.getI18nString("upload-image")), h("input", { type: "file", class: "fileElem", id: "fileElem--" + props.pageID, accept: "image/*", onChange: ($event) => {
                    const el = $event.target;
                    if (el.files.length === 0) {
                        return;
                    }
                    this.handleImageFile(el.files[0], props.pageIndex);
                    el.value = "";
                } }), h("label", { class: "button", htmlFor: "fileElem--" + props.pageID }, this.getI18nString("choose-file"))))));
        };
        /**
         * Page Counter element
         *
         * @param props
         *
         * Shows currentPage / pgCount
         */
        this.PageCount = (props) => (h("div", { class: "page__counter color--" + this.userPreferences.theme }, this.getI18nString("page"), " ", h("span", { "data-test-id": "page-count__current" }, props.currentPage), " / ", h("span", { "data-test-id": "page-count__total" }, props.pgCount)));
        this.ImgContainer = (props) => {
            const hasImage = props.pageIndex in this.images && this.images[props.pageIndex] !== null;
            if (hasImage) {
                return (h(this.Img, { imgURL: this.images[props.pageIndex], pageIndex: props.pageIndex }));
            }
            if (this.mode === "EDIT") {
                return (h(this.ImgPlaceHolder, { pageID: props.pageID, pageIndex: props.pageIndex }));
            }
        };
        /**
         * Page element
         *
         * @param props
         *
         * Show 'Page' or vertically scrollable text content.
         * Text content on 'Page' breaks is separated horizontally.
         */
        this.Page = (props) => (h("div", { class: "page page__container page--multi animate-transition  theme--" +
                this.userPreferences.theme +
                " " +
                (props.pageData.attributes["class"]
                    ? props.pageData.attributes["class"].value
                    : ""), id: props.pageData["id"] }, 
        /* Display the PageCount only if there's more than 1 page */
        this.parsed_text.length > 1 ? (h(this.PageCount, { pgCount: this.parsed_text.length, currentPage: this.parsed_text.indexOf(props.pageData) + 1 })) : null, h(this.ImgContainer, { pageID: props.pageData.id, pageIndex: this.parsed_text.indexOf(props.pageData) }), h("div", { class: "page__col__text paragraph__container theme--" +
                this.userPreferences.theme }, 
        /* Here are the Paragraph children */
        props.pageData.paragraphs.map((paragraph) => {
            return (h(this.Paragraph, { sentences: Array.from(paragraph.childNodes), attributes: paragraph.attributes }));
        }))));
        /**
         * Paragraph element
         *
         * @param props
         *
         * A paragraph element with one or more sentences
         */
        this.Paragraph = (props) => (h("div", Object.assign({}, props.attributes, { class: "paragraph sentence__container theme--" +
                this.userPreferences.theme +
                " " +
                (props.attributes["class"] ? props.attributes["class"].value : "") }), 
        /* Here are the Sentence children */
        props.sentences.map((sentence) => sentence.childNodes.length > 0 && (h(this.Sentence, { sentenceData: sentence })))));
        /**
         * Sentence element
         *
         * @param props
         *
         * A sentence element with one or more words
         */
        this.Sentence = (props) => {
            let words = Array.from(props.sentenceData.childNodes);
            let sentenceID = props.sentenceData.id;
            if (!this.hasTextTranslations && props.sentenceData.hasAttribute("class")) {
                this.hasTextTranslations = /translation/.test(props.sentenceData.getAttribute("class"));
            }
            let nodeProps = {};
            //attributes of sentence you want to retain
            for (const attr of ["annotation-id", "do-not-align", "lang", "id"]) {
                if (props.sentenceData.hasAttribute(attr)) {
                    nodeProps[attr] = props.sentenceData.getAttribute(attr);
                }
            }
            if (props.sentenceData.hasAttribute("xml:lang")) {
                nodeProps["lang"] = props.sentenceData.getAttribute("xml:lang");
            }
            if (this.mode === "EDIT" &&
                /translation/.test(props.sentenceData.getAttribute("class")))
                return h(Fragment, null);
            return (h("div", Object.assign({}, nodeProps, { class: "sentence" +
                    " " +
                    (props.sentenceData.hasAttribute("class")
                        ? props.sentenceData.getAttribute("class")
                        : "") +
                    (nodeProps["annotation-id"] ? " invisible" : "") }), 
            /* Here are the Word and NonWordText children */
            words.map((child, c) => {
                if (child.nodeName === "#text") {
                    return (h(this.NonWordText, { text: child.textContent, attributes: child.attributes, id: (props.sentenceData.hasAttribute("id")
                            ? props.sentenceData.getAttribute("id")
                            : "P") +
                            "text" +
                            c }));
                }
                else if (child.nodeName === "w" || child.nodeName === "W") {
                    /* It may be uppercase for embedded markup, because in
                         that case it has been parsed as "HTML".  See
                         https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName */
                    return (h(this.Word, { text: child.textContent, id: child["id"], attributes: child.attributes }));
                }
                else if (child) {
                    let cnodeProps = {};
                    if (child.hasAttribute("xml:lang"))
                        cnodeProps["lang"] =
                            props.sentenceData.getAttribute("xml:lang");
                    if (child.hasAttribute("lang"))
                        cnodeProps["lang"] = props.sentenceData.getAttribute("lang");
                    return (h("span", Object.assign({}, cnodeProps, { class: "sentence__text theme--" +
                            this.userPreferences.theme +
                            (" " + child.className), id: child.id ? child.id : "text_" + c }), child.textContent));
                }
            }), (() => {
                if (this.mode === "EDIT" &&
                    !/translation/.test(props.sentenceData.getAttribute("class"))) {
                    if (sentenceID in this.translations &&
                        sentenceID in this.translations &&
                        this.translations[sentenceID] !== null) {
                        return (h("span", { class: "sentence__translation" }, h("button", { title: "Remove translation", "aria-label": "Remove translation", "data-test-id": "remove-translation-button", onClick: () => this.removeLine(props.sentenceData), class: "sentence__translation__button remove" }, h(MatIcon, null, "remove")), h("p", { id: sentenceID + "translation", "data-test-id": "translation-line", class: "sentence__text editable__translation", onInput: (e) => {
                                this.updateTranslation(sentenceID, e.currentTarget.innerText);
                            }, contentEditable: true, onKeyDown: (event) => {
                                if (event.key == "Enter")
                                    event.preventDefault();
                            }, "data-placeholder": this.getI18nString("line-placeholder"), innerHTML: this.translations[sentenceID] })));
                    }
                    else {
                        return (h("button", { title: this.getI18nString("add-translation"), "aria-label": "Add translation", "data-test-id": "add-translation-button", class: "sentence__translation sentence__translation__button", onClick: () => this.addLine(props.sentenceData) }, h(MatIcon, null, "add")));
                    }
                }
                else {
                    return null;
                }
            })()));
        };
        /**
         * A non-Word text element
         *
         * @param props
         *
         * This is an element that is a child to a Sentence element,
         * but cannot be clicked and is not a word. This is usually
         * inter-Word punctuation or other text.
         */
        this.NonWordText = (props) => {
            let nodeProps = {};
            if (props.attributes && props.attributes["xml:lang"])
                nodeProps["lang"] = props.attributes["xml:lang"].value;
            if (props.attributes && props.attributes["lang"])
                nodeProps["lang"] = props.attributes["lang"].value;
            return (h("span", Object.assign({}, nodeProps, { class: "sentence__text theme--" + this.userPreferences.theme, id: props.id }), props.text));
        };
        /**
         * A Word text element
         *
         * @param props
         *
         * This is a clickable, audio-aligned Word element
         */
        this.Word = (props) => {
            let nodeProps = {};
            if (props.attributes && props.attributes["xml:lang"])
                nodeProps["lang"] = props.attributes["xml:lang"].value;
            if (props.attributes && props.attributes["lang"])
                nodeProps["lang"] = props.attributes["lang"].value;
            return (h("span", Object.assign({}, nodeProps, { class: "sentence__word theme--" +
                    this.userPreferences.theme +
                    " " +
                    (props && props.attributes["class"]
                        ? props.attributes["class"].value
                        : ""), id: props.id, onClick: (ev) => this.playSprite(ev) }), props.text));
        };
        /**
         * Render controls for ReadAlong
         */
        this.PlayControl = () => (h("button", { "data-test-id": "play-button", disabled: !this.isReadyToPlay(), "aria-label": "Play", title: this.getI18nString("play-tooltip"), onClick: () => {
                this.playing ? this.pause() : this.play();
            }, class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, tabindex: 1 }, this.playing ? h(MatIcon, null, "pause") : h(MatIcon, null, "play_arrow")));
        this.ReplayControl = () => (h("button", { "data-test-id": "replay-button", disabled: this.hasLoaded < 2, "aria-label": "Rewind", title: this.getI18nString("rewind-tooltip"), onClick: () => this.goBack(5), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h(MatIcon, null, "replay_5")));
        this.StopControl = () => (h("button", { "data-test-id": "stop-button", disabled: this.hasLoaded < 2, "aria-label": "Stop", title: this.getI18nString("stop-tooltip"), onClick: () => this.stop(), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h(MatIcon, null, "stop")));
        this.PlaybackSpeedControl = () => (h("div", null, h("h5", { class: "control-panel__buttons__header color--" + this.userPreferences.theme, id: "speed-slider-label" }, this.getI18nString("speed")), h("input", { type: "range", min: 100 - this.playbackRateRange, max: 100 + this.playbackRateRange, value: this.playback_rate * 100, class: "slider control-panel__control", id: "myRange", "aria-labelledby": "speed-slider-label", onInput: (v) => {
                //console.log("v", v);
                this.changePlayback(v);
            } })));
        this.StyleControl = () => (h("button", { "aria-label": "Change theme", title: this.getI18nString("theme-tooltip"), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h(MatIcon, { outline: true }, "style")));
        this.FullScreenControl = () => (h("button", { "aria-label": "Full screen mode", onClick: () => this.toggleFullscreen(), title: this.getI18nString("full-screen-tooltip"), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, this.fullscreen ? (h(MatIcon, { "aria-label": "Exit full screen mode" }, "fullscreen_exit")) : (h(MatIcon, { "aria-label": "Full screen mode" }, "fullscreen"))));
        this.TextAnnotationsControl = () => (h("button", { "data-test-id": "annotations-toggle", "aria-label": "Toggle Annotations", title: this.getI18nString("annotations-tooltip"), onClick: () => (this.annotationsMenuVisible = !this.annotationsMenuVisible), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h(MatIcon, { outline: true }, "layers")));
        this.TextTranslationDisplayControl = () => (h("button", { "data-test-id": "translation-toggle", "aria-label": "Toggle Translation", title: this.getI18nString("translation-tooltip"), onClick: () => this.toggleTextTranslation(), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h(MatIcon, { outline: true }, "subtitles")));
        this.ToggleSettingsControl = () => (h("button", { "data-test-id": "settings-button", title: this.getI18nString("configuration-tooltip"), onClick: () => this.toggleSettings(), id: "settings-button", class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h(MatIcon, { "aria-label": "Show settings" }, "settings")));
        this.ControlPanel = () => (h("div", { "data-test-id": "control-panel", class: "control-panel theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, h("div", { class: "control-panel__buttons--left" }, h(this.PlayControl, null), h(this.ReplayControl, null), h(this.StopControl, null)), h("div", { class: "control-panel__buttons--center" }, h(this.PlaybackSpeedControl, null)), h("div", { class: "control-panel__buttons--right" }, this.annotations.length > 0 ? (h(this.TextAnnotationsControl, null)) : (this.hasTextTranslations && h(this.TextTranslationDisplayControl, null)), window.document.fullscreenEnabled && h(this.FullScreenControl, null), h(this.ToggleSettingsControl, null))));
        this.Settings = () => (h("div", { id: "settings", "data-test-id": "settings", class: "settings  theme--" + this.userPreferences.theme }, h("div", { class: "header" }, h("button", { class: "close", "data-test-id": "settings-close-button", onClick: () => {
                this.toggleSettings();
            } }, "\u00D7", " "), h("h3", null, this.getI18nString("settings"))), h("div", { class: "content" }, h("p", null, h("label", null, h("select", { title: this.getI18nString("language"), onChange: (e) => {
                const newLang = e.target.value;
                this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { language: newLang });
                this.userPreferencesDirty = true;
            }, id: "settings-language", "data-test-id": "settings-language", tabindex: 2 }, Object.keys(this.i18nStrings).map((lang) => (h("option", { class: `background--${this.userPreferences.theme}`, selected: this.userPreferences.language == lang, value: lang }, this.i18nStrings[lang][lang] || lang)))), this.getI18nString("language"))), h("p", { onClick: () => {
                this.changeTheme();
                this.userPreferencesDirty = true;
            }, tabindex: 3 }, h(this.StyleControl, null), this.getI18nString("theme-tooltip")), h("p", { onClick: () => {
                this.toggleScrollBehavior();
                this.userPreferencesDirty = true;
            }, tabindex: 4 }, h("button", { class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, title: this.getI18nString("page-animation"), "data-test-id": "settings-scroll-behavior" }, this.userPreferences.scrollBehaviour === "smooth" ? (h(MatIcon, { outline: true }, "check_box")) : (h(MatIcon, { outline: true }, "check_box_outline_blank"))), this.getI18nString("page-animation")), h("p", { onClick: () => {
                this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { autoPauseAtEndOfPage: !this.userPreferences.autoPauseAtEndOfPage });
                this.userPreferencesDirty = true;
            }, tabindex: 5 }, h("button", { class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, title: this.getI18nString("auto-pause"), "data-test-id": "settings-auto-pause" }, this.userPreferences.autoPauseAtEndOfPage ? (h(MatIcon, { outline: true }, "check_box")) : (h(MatIcon, { outline: true }, "check_box_outline_blank"))), this.getI18nString("auto-pause")), h("div", { class: "preference-btns" }, h("button", { type: "button", class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, title: this.getI18nString("save-settings"), onClick: () => {
                setUserPreferences(this.userPreferences);
                this.userPreferencesDirty = false;
                this.hasUserPreferences = true;
            }, "data-test-id": "settings-save", disabled: !this.userPreferencesDirty, tabindex: 6 }, this.getI18nString("save-settings"))), h("p", { class: "version" }, "@readalongs/web-component version: ", PACKAGE_VERSION)), h("div", { class: "footer" }, h("button", { type: "button", class: "control-panel__control ripple" +
                ` theme--${this.userPreferences.theme}` +
                ` background--${this.userPreferences.theme}`, title: this.getI18nString("reset-title"), onClick: () => {
                clearUserPreferences();
                this.userPreferences = this.defaultUserPreferences();
                this.userPreferencesDirty = false;
                this.hasUserPreferences = false;
            }, "data-test-id": "reset", disabled: !this.hasUserPreferences && !this.userPreferencesDirty, tabindex: 7 }, this.getI18nString("reset")), h("button", { onClick: () => this.toggleSettings(), class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, tabindex: 8 }, this.getI18nString("close")))));
        this.AnnotationsMenu = () => {
            return (h("div", { id: "annotationsMenu", class: "annotations-menu  theme--" + this.userPreferences.theme }, this.annotations.map((annotation) => (h("button", { "data-test-id": "toggle-annotation-" + annotation.id, class: "ripple theme--" +
                    this.userPreferences.theme +
                    " background--" +
                    this.userPreferences.theme, onClick: () => this.toggleTextAnnotation(annotation.id) }, annotation.isVisible ? (h(MatIcon, { outline: true }, "check_box")) : (h(MatIcon, { outline: true }, "check_box_outline_blank")), annotation.name))), h("button", { "data-test-id": "toggle-all-annotations", class: "ripple theme--" +
                    this.userPreferences.theme +
                    " background--" +
                    this.userPreferences.theme, onClick: () => this.toggleTextAnnotation("*") }, h(MatIcon, { outline: true }, "layers"), " All")));
        };
    }
    handleScrollEvent() {
        this.isScrolling = true;
        if (this.scrollTimer)
            clearTimeout(this.scrollTimer);
        this.scrollTimer = setTimeout(() => {
            this.isScrolling = false;
        }, 125);
    }
    wheelHandler(event) {
        // only show guide if there is an actual highlighted element
        if (this.el.shadowRoot.querySelector(".reading")) {
            if (event["path"] &&
                event["path"].length > 0 &&
                (event["path"][0].classList.contains("sentence__word") ||
                    event["path"][0].classList.contains("sentence__container") ||
                    event["path"][0].classList.contains("sentence"))) {
                if (this.autoScroll) {
                    let reading_el = this.el.shadowRoot.querySelector(".reading");
                    if (reading_el) {
                        this.autoScroll = !this.inPageContentOverflow(reading_el);
                        this.showGuide = !this.autoScroll;
                    }
                }
            }
        }
    }
    // handle cases where user presses esc to cancel full screen
    fullScreenHandler() {
        this.fullscreen = window.document.fullscreenElement != null;
    }
    handleKeyDown(event) {
        //dismiss setting modal user pressing escape
        if (event.key === "Escape" && this.settingsVisible) {
            this.settingsVisible = false;
        }
    }
    /***********
     *  UTILS  *
     ***********/
    /**
     * Transforms a given path to either use the default assets folder or rely on the absolute path given
     * @param path
     * @return string
     */
    urlTransform(path) {
        // Frankenstein of combined useAssetsFolder v1.1.1 functionality and imageAssetsFolder v2.0.0 functionality
        // TODO: delete this first if statement and all occurrences of useAssetsFolder for v2.0.0
        if (this.useAssetsFolder !== undefined) {
            // Old v1.1.1 functionality
            if (this.useAssetsFolder &&
                looksLikeRelativePath(path) &&
                !path.startsWith("blob")) {
                return "assets/" + path;
            }
            else {
                return path;
            }
        }
        else if (this.imageAssetsFolder &&
            looksLikeRelativePath(path) &&
            !path.startsWith("blob")) {
            if (this.imageAssetsFolder && !this.imageAssetsFolder.endsWith("/")) {
                this.imageAssetsFolder += "/";
            }
            return this.imageAssetsFolder + path;
        }
        return path;
        function looksLikeRelativePath(path) {
            return !/^(https?:[/][/]|assets[/]|data:)/.test(path);
        }
    }
    /**
     * Given an audio file path and a parsed alignment object,
     * build a Sprite object
     * @param audio
     * @param alignment
     */
    buildSprite(audio, alignment) {
        return new Sprite({
            src: [audio],
            sprite: alignment,
            rate: this.playback_rate,
        });
    }
    /**
     * Add escape characters to query selector param
     * @param id
     */
    tagToQuery(id) {
        id = id.replace(".", "\\.");
        id = id.replace("#", "\\#");
        return "#" + id;
    }
    /**
     * Return HTML element of word closest to second s
     *
     * @param s seconds
     */
    returnWordClosestTo(s) {
        let keys = Object.keys(this.processed_alignment);
        // remove 'all' sprite as it's not a word.
        keys.pop();
        for (let i = 1; i < keys.length; i++) {
            if (s * 1000 > this.processed_alignment[keys[i]][0] &&
                this.processed_alignment[keys[i + 1]] &&
                s * 1000 < this.processed_alignment[keys[i + 1]][0]) {
                return this.el.shadowRoot.querySelector(this.tagToQuery(keys[i]));
            }
        }
    }
    /**
     * Return the file path given the asset_type
     */
    getPathFromAssetType(asset_type) {
        if (asset_type === "AUDIO") {
            return this.audio;
        }
        else if (asset_type === "RAS") {
            return this.href;
        }
        else {
            return "Asset Path Not Supported";
        }
    }
    /**
     * toggle the setting pane visiblilty
     */
    toggleSettings() {
        //pause audio if playing and setting modal is being presented
        if (this.playing) {
            this.pause();
        }
        this.settingsVisible = !this.settingsVisible;
    }
    /**
     * toggle (override) scrolling animation
     */
    toggleScrollBehavior() {
        this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { scrollBehaviour: this.userPreferences.scrollBehaviour === "auto" ? "smooth" : "auto" });
    }
    /*************
     *   AUDIO   *
     *************/
    /**
     * Change playback between .75 and 1.25. To change the playback options,
     * change the HTML in the function renderControlPanel
     *
     * @param ev
     */
    changePlayback(ev) {
        let inputEl = ev.currentTarget;
        this.playback_rate = parseInt(inputEl.value) / 100;
        this.audio_howl_sprites.sound.rate(this.playback_rate);
    }
    /**
     *  Go back s milliseconds
     *
     * @param s
     */
    goBack(s) {
        this.autoScroll = false;
        if (this.play_id) {
            this.audio_howl_sprites.goBack(this.play_id, s);
        }
        setTimeout(() => (this.autoScroll = true), 100);
    }
    /**
     * Go to seek
     *
     * @param seek number
     *
     */
    goTo(seek) {
        if (this.play_id === undefined) {
            this.play();
            this.pause();
        }
        //allow display to bring the selected portion into view
        this.autoScroll = true;
        seek = seek / 1000;
        this.audio_howl_sprites.goTo(this.play_id, seek);
        setTimeout(() => (this.autoScroll = true), 100);
    }
    /**
     * Go to seek from id
     *
     * @param ev
     */
    goToSeekAtEl(ev) {
        let el = ev.currentTarget;
        let tag = el.id;
        let seek = this.processed_alignment[tag][0];
        this.goTo(seek);
        return tag;
    }
    /**
     * Go to seek from progress bar
     */
    goToSeekFromProgress(ev) {
        let el = ev.currentTarget;
        let client_rect = el.getBoundingClientRect();
        // get offset of clicked element
        let offset = client_rect.left;
        // get width of clicked element
        let width = client_rect.width;
        // get click point
        let click = ev.pageX - offset;
        // get seek in milliseconds
        let seek = (click / width) * this.duration * 1000;
        this.goTo(seek);
    }
    /**
     * Pause audio.
     */
    pause() {
        if (this.playing) {
            this.playing = false;
            this.audio_howl_sprites.pause();
        }
    }
    /**
     * Play the current audio, or start a new play of all
     * the audio
     *
     *
     */
    play() {
        //do not attempt to play if sprites are not initialized
        if (this.audio_howl_sprites === undefined)
            return;
        this.playing = true;
        // If already playing once, continue playing
        if (this.play_id !== undefined) {
            this.play_id = this.audio_howl_sprites.play(this.play_id);
        }
        else {
            // else, start a new play
            this.play_id = this.audio_howl_sprites.play("all");
        }
        // animate the progress bar
        this.animateProgress();
    }
    /**
     * Seek to an element with id 'id', then play it
     *
     * @param ev
     */
    playSprite(ev) {
        let tag = this.goToSeekAtEl(ev);
        if (!this.playing) {
            this.audio_howl_sprites.play(tag);
        }
    }
    /**
     * Stop the sound and remove all active reading styling
     */
    stop() {
        this.playing = false;
        this.play_id = undefined;
        if (this.audio_howl_sprites) {
            this.audio_howl_sprites.stop();
        }
        this.el.shadowRoot
            .querySelectorAll(".reading")
            .forEach((x) => x.classList.remove("reading"));
        if (!this.autoScroll) {
            this.autoScroll = true;
            this.showGuide = false;
        }
    }
    /**
     * toggle the visibility of translation text
     */
    toggleTextTranslation() {
        this.el.shadowRoot
            .querySelectorAll(".translation, .sentence__translation, [annotation-id]")
            .forEach((translation) => translation.classList.toggle("invisible"));
    }
    /**
     * Toggle the visibility of annotation layers (sentences)
     * if id is set to * it toggles all layers
     * @param annotationId
     */
    toggleTextAnnotation(annotationId) {
        this.el.shadowRoot
            .querySelectorAll("[annotation-id" +
            (annotationId === "*" ? "]" : '="' + annotationId + '"]'))
            .forEach((annotationElem) => annotationElem.classList.toggle("invisible"));
        this.annotations = this.annotations.map((annotationObj) => {
            if (annotationObj.id == annotationId || annotationId === "*")
                annotationObj.isVisible = !annotationObj.isVisible;
            return annotationObj;
        });
    }
    /*************
     * ANIMATION *
     *************/
    /**
     * Remove highlighting from every other word and add it to el
     *
     * @param el
     */
    addHighlightingTo(el) {
        this.el.shadowRoot
            .querySelectorAll(".reading")
            .forEach((x) => x.classList.remove("reading"));
        el.classList.add("reading");
    }
    /**
     * Animate the progress through the overlay svg
     */
    animateProgressWithOverlay() {
        // select svg container
        let wave__container = this.el.shadowRoot.querySelector("#overlay__object");
        // use svg container to grab fill and trail
        let fill = wave__container.contentDocument.querySelector("#progress-fill");
        let trail = wave__container.contentDocument.querySelector("#progress-trail");
        let base = wave__container.contentDocument.querySelector("#progress-base");
        fill.classList.add("stop-color--" + this.userPreferences.theme);
        base.classList.add("stop-color--" + this.userPreferences.theme);
        // push them to array to be changed in step()
        this.audio_howl_sprites.sounds.push(fill);
        this.audio_howl_sprites.sounds.push(trail);
        // When this sound is finished, remove the progress element.
        this.audio_howl_sprites.sound.once("end", () => {
            this.audio_howl_sprites.sounds.forEach((x) => {
                x.setAttribute("offset", "0%");
            });
            this.el.shadowRoot
                .querySelectorAll(".reading")
                .forEach((x) => x.classList.remove("reading"));
            this.playing = false;
            // }
        }, this.play_id);
    }
    /**
     * Animate the progress if no svg overlay is provided
     *
     * @param play_id
     * @param tag
     */
    animateProgressDefault(play_id, tag) {
        let elm = document.createElement("div");
        elm.className = "progress theme--" + this.userPreferences.theme;
        elm.id = play_id.toString();
        elm.dataset.sprite = tag;
        let query = this.tagToQuery(tag);
        this.el.shadowRoot.querySelector(query).appendChild(elm);
        this.audio_howl_sprites.sounds.push(elm);
        // When this sound is finished, remove the progress element.
        this.audio_howl_sprites.sound.once("end", () => {
            // this.audio_howl_sprites = [];
            this.el.shadowRoot
                .querySelectorAll(".reading")
                .forEach((x) => x.classList.remove("reading"));
            this.playing = false;
            // }
        }, this.play_id);
    }
    /**
     * Animate progress, either by default or with svg overlay.
     */
    animateProgress(play_id = this.play_id) {
        // Start animating progress
        if (this.svgOverlay) {
            // either with svg overlay
            this.animateProgressWithOverlay();
        }
        else if (play_id) {
            // or default progress bar
            this.animateProgressDefault(play_id, "all");
        }
    }
    /**
     * Change fill colour to match theme
     */
    changeFill() {
        // Get theme contrast from the computed color of a word
        let contrast_el = this.el.shadowRoot.querySelector(".sentence__word");
        let contrast = window.getComputedStyle(contrast_el).color;
        // select svg container
        let wave__container = this.el.shadowRoot.querySelector("#overlay__object");
        // use svg container to grab fill and trail
        let fill = wave__container.contentDocument.querySelector("#progress-fill");
        let base = wave__container.contentDocument.querySelector("#progress-base");
        // select polygon
        let polygon = wave__container.contentDocument.querySelector("#polygon");
        polygon.setAttribute("stroke", contrast);
        base.setAttribute("stop-color", contrast);
        fill.setAttribute("stop-color", contrast);
    }
    /**
     * Get Current Word
     */
    async getCurrentWord() {
        return this.reading$;
    }
    /**
     * Get Images
     */
    async getImages() {
        return this.images;
    }
    /**
     * Update Single Sprite
     */
    async updateSpriteAlignments(alignment) {
        this.stop();
        this.processed_alignment = alignment;
        this.attachScrollingLogicToAudio();
    }
    /**
     * Get ReadAlong Element
     */
    async getReadAlongElement() {
        return this.el;
    }
    /**
     * Get Alignments
     */
    async getAlignments() {
        return this.processed_alignment;
    }
    /**
     * Get Translations
     */
    async getTranslations() {
        return this.translations;
    }
    /**
     * Change theme
     */
    async changeTheme() {
        const newTheme = this.userPreferences.theme === "light" ? "dark" : "light";
        this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { theme: newTheme });
    }
    /**
     * Update stylesheet
     * @param url
     */
    async setCss(url) {
        this.cssUrl = url;
    }
    /**
     * Add custom font
     */
    async addCustomFont(fontData) {
        const style = document.createElement("style");
        style.setAttribute("id", "ra-wc-custom-font");
        style.setAttribute("type", "text/css");
        style.innerHTML = fontData;
        document.head.appendChild(style);
    }
    /**
     * Return the Sentence Container of Word
     * Currently the 3rd parent up the tree node
     * @param element
     * @private
     */
    static _getSentenceContainerOfWord(element) {
        return element.parentElement.parentElement.parentElement;
    }
    /**
     * Make Fullscreen
     */
    toggleFullscreen() {
        let fullScreenPromise;
        if (!this.fullscreen) {
            let elem = this.el.shadowRoot.getElementById("read-along-container");
            if (elem.requestFullscreen) {
                fullScreenPromise = elem.requestFullscreen();
            }
            else if (elem.mozRequestFullScreen) {
                /* Firefox */
                fullScreenPromise = elem.mozRequestFullScreen();
            }
            else if (elem.webkitRequestFullscreen) {
                /* Chrome, Safari and Opera */
                fullScreenPromise = elem.webkitRequestFullscreen();
            }
            else if (elem.msRequestFullscreen) {
                /* IE/Edge */
                fullScreenPromise = elem.msRequestFullscreen();
            }
            fullScreenPromise.then(() => {
                this.fullscreen = true;
                this.el.shadowRoot
                    .getElementById("read-along-container")
                    .classList.add("read-along-container--fullscreen");
            });
        }
        else {
            let document = this.el.ownerDocument;
            if (document.exitFullscreen) {
                fullScreenPromise = document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                /* Firefox */
                fullScreenPromise = document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                /* Chrome, Safari and Opera */
                fullScreenPromise = document.webkitExitFullscreen();
            }
            else if (document.msExitFullscreen) {
                /* IE/Edge */
                fullScreenPromise = document.msExitFullscreen();
            }
            fullScreenPromise.then(() => {
                this.fullscreen = false;
                this.el.shadowRoot
                    .getElementById("read-along-container")
                    .classList.remove("read-along-container--fullscreen");
            });
        }
    }
    /*************
     * SCROLLING *
     *************/
    hideGuideAndScroll() {
        let reading_el = this.el.shadowRoot.querySelector(".reading");
        // observe when element is scrolled to, then remove the scroll guide and unobserve
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                intersectionObserver.unobserve(reading_el);
            }
        });
        intersectionObserver.observe(reading_el);
        this.scrollTo(reading_el);
    }
    //for when you visually align content
    inParagraphContentOverflow(element) {
        let para_el = ReadAlongComponent._getSentenceContainerOfWord(element);
        let para_rect = para_el.getBoundingClientRect();
        let el_rect = element.getBoundingClientRect();
        // element being read is left of the words being viewed
        let inOverflowLeft = el_rect.right < para_rect.left;
        // element being read is right of the words being viewed
        let inOverflowRight = el_rect.right > para_rect.right;
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                intersectionObserver.unobserve(element);
            }
        });
        intersectionObserver.observe(element);
        // if not in overflow, return false
        return inOverflowLeft || inOverflowRight;
    }
    inPageContentOverflow(element) {
        let page_el = this.el.shadowRoot.querySelector("#" + this.current_page);
        let page_rect = page_el.getBoundingClientRect();
        let el_rect = element.getBoundingClientRect();
        // element being read is below/ahead of the words being viewed
        let inOverflowBelow = el_rect.top + el_rect.height > page_rect.top + page_rect.height;
        // element being read is above/behind of the words being viewed
        //even if it is barely above the view
        let inOverflowAbove = el_rect.top < page_rect.top;
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                // IT IS VISIBLE
                inOverflowAbove = inOverflowBelow = false;
                intersectionObserver.unobserve(element);
            }
        });
        intersectionObserver.observe(element);
        // if not in overflow, return false
        return inOverflowAbove || inOverflowBelow;
    }
    inPage(element) {
        let sent_el = ReadAlongComponent._getSentenceContainerOfWord(element);
        let sent_rect = sent_el.getBoundingClientRect();
        let el_rect = element.getBoundingClientRect();
        // element being read is below/ahead of the words being viewed
        let inOverflowBelow = el_rect.top + el_rect.height > sent_rect.top + sent_rect.height;
        // element being read is above/behind of the words being viewed
        let inOverflowAbove = el_rect.top + el_rect.height < 0;
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                intersectionObserver.unobserve(element);
            }
        });
        intersectionObserver.observe(element);
        // if not in overflow, return false
        return inOverflowAbove || inOverflowBelow;
    }
    scrollToPage(pg_id) {
        let page_container = this.el.shadowRoot.querySelector(".pages__container");
        let next_page = this.el.shadowRoot.querySelector("#" + pg_id);
        page_container.scrollBy({
            top: this.pageScrolling.match("vertical") != null
                ? next_page.offsetTop - page_container.scrollTop
                : 0,
            left: this.pageScrolling.match("vertical") != null
                ? 0
                : next_page.offsetLeft - page_container.scrollLeft,
            behavior: this.userPreferences.scrollBehaviour,
        });
        next_page.scrollTo(0, 0); //reset to top of the page
    }
    scrollByHeight(el) {
        let sent_container = ReadAlongComponent._getSentenceContainerOfWord(el); //get the direct parent sentence container
        let anchor = el.parentElement.getBoundingClientRect();
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                intersectionObserver.unobserve(el);
            }
            else {
                sent_container.scrollTo({
                    top: sent_container.getBoundingClientRect().height - anchor.height, // negative value
                    // acceptable
                    left: 0,
                    behavior: this.userPreferences.scrollBehaviour,
                });
            }
        }, {
            root: sent_container,
            threshold: [0, 0.25, 0.5, 0.75, 1],
        });
        intersectionObserver.observe(el);
    }
    //scrolling within the visually aligned paragraph
    scrollByWidth(el) {
        let sent_container = ReadAlongComponent._getSentenceContainerOfWord(el); //get the direct parent sentence container
        let anchor = el.getBoundingClientRect();
        sent_container.scrollTo({
            left: anchor.left - 10, // negative value acceptable
            top: 0,
            behavior: this.userPreferences.scrollBehaviour,
        });
    }
    scrollTo(el) {
        el.scrollIntoView({
            behavior: this.userPreferences.scrollBehaviour,
        });
    }
    /*************
     * LIFECYCLE *
     *************/
    /**
     * When the component is disconnected, stop all audio.
     *
     */
    disconnectedCallback() {
        this.stop();
    }
    /**
     * When the component updates, change the fill of the progress bar.
     * This is because the fill colour is determined by a computed CSS
     * value set by the Web Component's theme. When the @prop theme changes and
     * the component updates, we have to update the fill with the new
     * computed CSS value.
     */
    componentDidUpdate() {
        if (this.svgOverlay) {
            this.changeFill();
        }
    }
    /**
     * construct a valid default user preferences object, using the provided
     * component properties.
     */
    defaultUserPreferences() {
        const prefs = {
            version: USER_PREFERENCE_VERSION,
            autoPauseAtEndOfPage: this.autoPauseAtEndOfPage,
            scrollBehaviour: this.scrollBehaviour.toLowerCase(),
            language: this.language.toLowerCase(),
            theme: this.theme.toLowerCase(),
        };
        // Make sure scroll-behaviour is valid
        if (prefs.scrollBehaviour !== "smooth" &&
            prefs.scrollBehaviour !== "auto") {
            console.error("Invalid scroll-behaviour value, using default (smooth)");
            prefs.scrollBehaviour = "smooth";
        }
        // The backward compatible behaviour used to be audio, alignment and text files outside assets
        // and only image files inside assets.
        // See version 0.1.0, where it only looks in assets/ for images, nothing else.
        // TO maintain backwards compatibility handle assets url
        //this.audio = this.urlTransform(this.audio)
        //this.alignment = this.urlTransform(this.alignment)
        //this.text = this.urlTransform(this.text)
        //this.cssUrl = this.urlTransform(this.cssUrl)
        // Maintains backwards compatibility with ISO 639-1 language codes.
        const acceptedLanguages = {
            en: "eng",
            eng: "eng",
            fr: "fra",
            fra: "fra",
            es: "spa",
            spa: "spa",
        };
        prefs.language = acceptedLanguages[prefs.language] || "eng";
        return prefs;
    }
    /**
     * Using this Lifecycle hook to handle backwards compatibility of component attribute
     */
    async componentWillLoad() {
        this.userPreferences = getUserPreferences();
        if (!this.userPreferences) {
            this.userPreferences = this.defaultUserPreferences();
        }
        // Make sure playback-rate-range is valid
        if (isNaN(this.playbackRateRange) ||
            this.playbackRateRange < 0 ||
            this.playbackRateRange > 99) {
            console.error("Invalid playback-rate-range value, using default (15).");
            this.playbackRateRange = 15;
        }
        // TODO: if parseRAS has an error, we need ERROR_PARSING
        // Parse the text to be displayed
        const text = this.el.querySelector("read-along > text");
        if (text) {
            this.parsed_text = extractPages(text);
            this.meta = extractMeta(this.el);
        }
        else {
            const doc = await parseRAS(this.href);
            this.parsed_text = doc.pages;
            this.meta = doc.meta;
        }
        if (this.parsed_text === null) {
            this.parsed_text = [];
            this.assetsStatus.RAS = ERROR_LOADING;
        }
        else if (this.parsed_text.length === 0) {
            this.assetsStatus.RAS = ERROR_PARSING;
        }
        else {
            this.images = {};
            this.translations = {};
            for (const [i, page] of this.parsed_text.entries()) {
                if ("img" in page) {
                    var imageURL = this.urlTransform(page.img);
                    this.images[i] = this.urlTransform(page.img);
                    if (/^(https?:[/]|assets)[/]\b/.test(imageURL)) {
                        let isAvailable = await isFileAvailable(imageURL);
                        if (!isAvailable) {
                            this.images[i] = null;
                        }
                    }
                }
                else {
                    this.images[i] = null;
                }
                //get the ids for the last word on each the page
                if ("paragraphs" in page) {
                    try {
                        const paragraphs = page.paragraphs;
                        const sentences = paragraphs[paragraphs.length - 1].querySelectorAll("s:not(.translation), s:not(.sentence__translation)"); //get non-translation sentences in the last paragraph
                        const word = sentences[sentences.length - 1].querySelector("w:last-of-type"); //get the last word of the last sentence
                        this.endOfPageTags[word.id] = [
                            parseFloat(word.getAttribute("time")), //in seconds
                            parseFloat(word.getAttribute("dur")) * 1000, // in milliseconds
                        ];
                        this.finalTaggedWord = word.id; // do not pause on the last word of the read-along
                    }
                    catch (err) { }
                    let lastAlignedSentenceId = null;
                    //get the translations
                    page.paragraphs
                        .map((paragraph) => paragraph.querySelectorAll("s"))
                        .forEach((sentences) => {
                        if (sentences.length) {
                            sentences.forEach((sentence) => {
                                if (sentence.id && sentenceIsAligned(sentence)) {
                                    lastAlignedSentenceId = `${sentence.id}`;
                                }
                                else if (/translation/.test(sentence.className)) {
                                    const translation = {};
                                    if (sentence.hasAttribute("sentence-id")) {
                                        let sentenceID = sentence.getAttribute("sentence-id");
                                        translation[sentenceID] = sentence.textContent;
                                        this.translations = Object.assign(Object.assign({}, this.translations), translation);
                                    }
                                    else if (lastAlignedSentenceId != null) {
                                        translation[lastAlignedSentenceId] = sentence.textContent;
                                        lastAlignedSentenceId = null;
                                        this.translations = Object.assign(Object.assign({}, this.translations), translation);
                                    }
                                }
                            });
                        }
                    });
                }
            }
            // this.parsed_text.map((page, i) => page.img ? [i, page.img] : [i, null])
            /**
             * parse defined annotations information from the .readalong meta
             * annotations-id defines the id of each layer
             * annotations-labels defines the display label for each layer
             * annotations-label-{locale} defines the localized display label for each layer
             * all lists are delimited by comma
             */
            if (this.meta["annotations-ids"]) {
                const delimiter = ",";
                const labels = this.meta["annotations-labels-" + this.userPreferences.language]
                    ? this.meta["annotations-labels-" + this.userPreferences.language]
                    : this.meta["annotations-labels"];
                const annotationNames = labels ? labels.split(delimiter) : [];
                this.meta["annotations-ids"]
                    .split(delimiter)
                    .forEach((annotation, l) => {
                    var _a;
                    this.annotations.push({
                        isVisible: false, //hide by default
                        name: (_a = annotationNames[l].trim()) !== null && _a !== void 0 ? _a : annotation.trim(),
                        id: annotation.trim(),
                    });
                });
            }
            this.assetsStatus.RAS = LOADED;
        }
        this.hasLoaded += 1;
    }
    /**
     * Lifecycle hook: after component loads, build the Sprite and parse the files necessary.
     * Then subscribe to the _reading$ Subject in order to update CSS styles when new element
     * is being read
     */
    componentDidLoad() {
        const bcSansFontCssUrl = "https://unpkg.com/@bcgov/bc-sans@1.0.1/css/BCSans.css";
        const iconsFontCssUrl = "https://fonts.googleapis.com/css2?family=Material+Icons&family=Material+Icons+Outlined&display=swap";
        [bcSansFontCssUrl, iconsFontCssUrl]
            .filter((url) => !document.querySelector(`link[href="${url}"]`))
            .forEach((url) => {
            const el = document.createElement("link");
            el.setAttribute("rel", "stylesheet");
            el.setAttribute("href", url);
            document.head.appendChild(el);
        });
        this.processed_alignment = extractAlignment(this.parsed_text);
        this.alignment_failed = Object.keys(this.processed_alignment).length == 0;
        // load basic Howl
        this.audio_howl = new Howl({
            src: [this.audio],
            html5: isIOS(),
            preload: false,
        });
        // Once loaded, get duration and build Sprite
        this.audio_howl.once("load", () => {
            this.attachScrollingLogicToAudio();
        });
        // Handle load errors
        this.audio_howl.once("loaderror", () => {
            this.hasLoaded += 1;
            this.assetsStatus.AUDIO = ERROR_LOADING;
        });
        this.audio_howl.load();
    }
    attachScrollingLogicToAudio() {
        this.processed_alignment["all"] = [0, this.audio_howl.duration() * 1000];
        this.duration = this.audio_howl.duration();
        this.audio_howl_sprites = this.buildSprite(this.audio, this.processed_alignment);
        // Once Sprites are built, subscribe to reading subject and update element class
        // when new distinct values are emitted
        this.audio_howl_sprites._reading$
            .pipe(distinctUntilChanged())
            .subscribe((el_tag) => {
            // Update the main reading tag subject
            this.reading$.next(el_tag);
            //if stop
            if (el_tag == "")
                return;
            //if auto pause is active and not on last word of the read along pause the audio
            if (this.playing &&
                this.userPreferences.autoPauseAtEndOfPage &&
                el_tag in this.endOfPageTags &&
                this.finalTaggedWord !== el_tag) {
                //clear previous timeout if active
                if (this.autoPauseTimer)
                    window.clearTimeout(this.autoPauseTimer);
                //pause 25ms before end of word
                this.autoPauseTimer = window.setTimeout(() => {
                    this.pause();
                }, this.endOfPageTags[el_tag][1] - 25);
            }
            // Turn tag to query
            let query = this.tagToQuery(el_tag);
            if (query === undefined)
                return; // not go any further if tag does not exist in the DOM
            // select the element with that tag
            let query_el = this.el.shadowRoot.querySelector(query);
            // Remove all elements with reading class
            this.el.shadowRoot
                .querySelectorAll(".reading")
                .forEach((x) => x.classList.remove("reading"));
            // Add reading to the selected el
            query_el.classList.add("reading");
            // Scroll horizontally (to different page) if needed
            let current_page = ReadAlongComponent._getSentenceContainerOfWord(query_el).parentElement
                .id;
            if (current_page !== this.current_page) {
                if (this.current_page !== undefined && !this.isScrolling) {
                    this.scrollToPage(current_page);
                }
                this.current_page = current_page;
            }
            const leftEdge = Math.ceil(this.el.shadowRoot
                .querySelector(".pages__container")
                .getBoundingClientRect().left) + 1;
            const pageLeftEdge = Math.ceil(this.el.shadowRoot
                .querySelector("#" + this.current_page)
                .getBoundingClientRect().left);
            //if the user has scrolled away from the from the current page bring them page
            if (query_el.getBoundingClientRect().left < 0 ||
                pageLeftEdge !== leftEdge) {
                if (!this.isScrolling)
                    this.scrollToPage(current_page);
            }
            // scroll vertically (through paragraph) if needed
            if (this.inPageContentOverflow(query_el)) {
                if (this.autoScroll) {
                    query_el.scrollIntoView({ block: "start", inline: "nearest" });
                    if (!this.isScrolling)
                        this.scrollByHeight(query_el);
                }
            } // scroll horizontal (through paragraph) if needed
            if (this.inParagraphContentOverflow(query_el)) {
                if (this.autoScroll) {
                    query_el.scrollIntoView(false);
                    if (!this.isScrolling)
                        this.scrollByWidth(query_el);
                }
            }
        });
        this.hasLoaded += 1;
        this.assetsStatus.AUDIO = LOADED;
    }
    componentDidRender() {
        //if creator does not want the translation to show at load time
        if (!this.displayTranslation &&
            this.parsed_text &&
            this.parsed_text.length > 0) {
            this.toggleTextTranslation();
            this.displayTranslation = true;
        }
        if (this.latestTranslation) {
            // Add focus to the latest translation line that was added
            let newLine = this.el.shadowRoot.querySelector(this.latestTranslation);
            newLine.focus();
            this.latestTranslation = "";
        }
    }
    /**
     * Is the App ready to start playing
     * This could be expressed as one line
     * but because there are multiple states involved
     * breaking it down to make it easier to track
     */
    isReadyToPlay() {
        //not ready if still audio & alignment is not loaded
        if (this.hasLoaded < 2)
            return false;
        //not ready if
        if (this.audio_howl_sprites === undefined)
            return false;
        //not ready if
        if (this.audio_howl_sprites.sound === undefined)
            return false;
        return true; //it is ready
    }
    /**********
     *  LANG  *
     **********/
    /**
     * Helper function for getI18nString()
     * @param key  the key of the string to lookup
     * @returns the requested string found i18n/messages.{this.language}.json
     */
    getRawI18nString(key) {
        if (this.i18nStrings[this.userPreferences.language] &&
            this.i18nStrings[this.userPreferences.language][key]) {
            return this.i18nStrings[this.userPreferences.language][key];
        }
        else if (this.i18nStrings.eng[key]) {
            // Fallback to English if the string does not exist for this.language
            return this.i18nStrings.eng[key];
        }
        else {
            // Last fallback in case it's not found anywhere, because we never want to just fail
            return key;
        }
    }
    /**
     * Any text used in the Web Component should be at least bilingual in English and French.
     * To add a new term, add a new key to each messages.*.json file in ../../i18n
     * and give the translations as values.
     *
     * Subsitution semantics: given substitution = { "STR1": "value1", "STR2": "value2" },
     * the text "foo <STR1> bar <STR2> baz" will replaced by "foo value1 bar value2 baz".
     *
     * @param key  short name for the text to fetch
     * @param substitutions  optional list of subtitutions to perform
     * @returns  the string in language this.language for key
     */
    getI18nString(key, substitutions = {}) {
        let result = this.getRawI18nString(key);
        for (const [sub_key, value] of Object.entries(substitutions)) {
            result = result.replace("<" + sub_key + ">", value);
        }
        return result;
    }
    /**********
     *  EDIT  *
     **********/
    addLine(sentence_element) {
        if (!this.hasTextTranslations) {
            this.hasTextTranslations = true;
        }
        let newTranslation = {};
        newTranslation[sentence_element.id] = "";
        this.translations = Object.assign(Object.assign({}, this.translations), newTranslation);
        this.latestTranslation = "#" + sentence_element.id + "translation";
    }
    removeLine(sentence_element) {
        delete this.translations[sentence_element.id];
        this.translations = Object.assign({}, this.translations);
    }
    updateTranslation(sentence_id, text) {
        this.translations[sentence_id] = text;
        //console.log(JSON.stringify(this.translations));
    }
    handleImageFile(file, pageIndex) {
        // verify the user has uploaded an  image file.
        if (!file.type.toLowerCase().startsWith("image/")) {
            this.invalidImages[pageIndex] = {
                fileName: file.name,
                pageIndex: pageIndex,
            };
            this.invalidImages = Object.assign({}, this.invalidImages);
            return;
        }
        // forcibly remove the error message associated
        // with this page.
        if (pageIndex in this.invalidImages) {
            delete this.invalidImages[pageIndex];
            this.invalidImages = Object.assign({}, this.invalidImages);
        }
        this.images[pageIndex] = URL.createObjectURL(file);
        this.images = Object.assign({}, this.images); // Using spread operator as advised https://stenciljs.com/docs/reactive-data#updating-an-object
    }
    deleteImage(pageIndex) {
        // release memory allocated by createObjectURL
        if (this.images[pageIndex].startsWith("blob:")) {
            URL.revokeObjectURL(this.images[pageIndex]);
        }
        const newImage = {};
        newImage[pageIndex] = null;
        this.images = Object.assign(Object.assign({}, this.images), newImage); // Using spread operator as advised https://stenciljs.com/docs/reactive-data#updating-an-object
    }
    /**
     * Render main component
     */
    render() {
        return (h("div", { key: '9e97168f2185f956462e96f9f36e47cdb02b66cb', id: "read-along-container", class: "read-along-container" }, h("div", { key: 'ed2e6c564afff98609d43bfecd025dd387a9cc39', id: "title__slot__container" }, h("h1", { key: '37cab34fce33269faa2358551a6d1c915b415cbd', class: "slot__header" }, h("slot", { key: 'bd3b4811eb6a103013a23cbc2d3527b24882a1a3', name: "read-along-header" })), h("h3", { key: '1b9f5380c25d7078c8584cb6c03d0fb667537a4e', class: "slot__subheader" }, h("slot", { key: '449845200d61903a88d1d206890b3a01b87f4e39', name: "read-along-subheader" }))), Object.entries(this.assetsStatus).map(([assetType, code]) => {
            if (code === ERROR_PARSING) {
                let path = this.getPathFromAssetType(assetType);
                return (h("error-message", { msg: this.getI18nString("parse-error", {
                        FILETYPE: assetType,
                        FILENAME: path,
                    }), data_cy: assetType + "-error" }));
            }
            if (code === ERROR_LOADING) {
                let path = this.getPathFromAssetType(assetType);
                return (h("error-message", { msg: this.getI18nString("loading-error", {
                        FILETYPE: assetType,
                        FILENAME: path,
                    }), data_cy: assetType + "-error" }));
            }
        }), this.alignment_failed && this.assetsStatus.RAS === LOADED && (h("error-message", { key: 'eaf54cd7fc20104524300f7a953d09cb82973f42', msg: this.getI18nString("alignment-error"), data_cy: "alignment-error" })), this.assetsStatus.RAS === LOADED &&
            Object.values(this.invalidImages).map((invalidImage) => {
                return (h("error-message", { msg: this.getI18nString("image-error", {
                        FILENAME: invalidImage.fileName,
                        PAGENUMBER: (invalidImage.pageIndex + 1).toString(),
                    }), timeout: DEFAULT_ERROR_TIMEOUT_MS, data_cy: "invalid-image-file", onExpired: () => {
                        // we don't need to be reactive here, the error message
                        // is no longer visible it is sufficient to remove
                        // its entry from the invalidImages object.
                        delete this.invalidImages[invalidImage.pageIndex];
                    } }));
            }), h("div", { key: 'a61e2c9b732b0b984284eb89992dfc4e68fcb359', onScroll: () => {
                this.handleScrollEvent();
            }, "data-test-id": "text-container", class: "pages__container" +
                " theme--" +
                this.userPreferences.theme +
                " " +
                this.pageScrolling }, this.showGuide ? h(this.Guide, null) : null, this.assetsStatus.RAS == LOADED &&
            this.parsed_text.map((page) => (h(this.Page, { pageData: page }))), this.hasLoaded < 2 && h("div", { key: '1c11b5f5a2a24bc4665e518847083e84e8ba9075', class: "loader" })), this.settingsVisible && (h("div", { key: 'bd23100cafa0691bc14f78d3ed601db07b730a1f', class: "settings-background", onClick: () => (this.settingsVisible = false) })), this.settingsVisible && h(this.Settings, { key: '3b424d3cae6aec26b2db79cfc342a80611a97998' }), this.alignment_failed || (h("div", { key: 'b112277b73af8aa0989f7bc2eee89e8945f2439c', onClick: (e) => this.goToSeekFromProgress(e), id: "all", "data-test-id": "progress-bar", class: "overlay__container theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, this.svgOverlay ? h(this.Overlay, null) : null)), this.annotationsMenuVisible && h(this.AnnotationsMenu, { key: '5184e678db807b007c2317883ee1d5a36b983a54' }), this.assetsStatus.AUDIO == LOADED && h(this.ControlPanel, { key: 'f5269089e11c1c34875ed5efcd5f7123e08115a7' }), this.cssUrl && this.cssUrl.match(".css") != null && (h("link", { key: '166f32c96ce9dd8d838f6f177e293f8c1dc23eb9', href: this.cssUrl, rel: "stylesheet" }))));
    }
    static get is() { return "read-along"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["../../scss/styles.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["../../scss/styles.css"]
        };
    }
    static get assetsDirs() { return ["assets"]; }
    static get properties() {
        return {
            "href": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "URL of the aligned text as readalong XML"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "href"
            },
            "audio": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "URL of the audio file"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "audio"
            },
            "svgOverlay": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Overlay\nThis is an SVG overlay to place over the progress bar"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "svg-overlay"
            },
            "theme": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Theme to use: ['light', 'dark'] defaults to the user's configured theme."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "theme",
                "defaultValue": "navigatorTheme()"
            },
            "language": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "InterfaceLanguage",
                    "resolved": "\"eng\" | \"fra\" | \"spa\"",
                    "references": {
                        "InterfaceLanguage": {
                            "location": "import",
                            "path": "../../index.d",
                            "id": "../../../packages/web-component/src/index.d.ts::InterfaceLanguage",
                            "referenceLocation": "InterfaceLanguage"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Language  of the interface. In 639-3 code.\nOptions are \"eng\" (English), \"fra\" (French) or \"spa\" (Spanish)"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "language",
                "defaultValue": "\"eng\""
            },
            "cssUrl": {
                "type": "string",
                "mutable": true,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Optional custom Stylesheet to override defaults"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "css-url"
            },
            "useAssetsFolder": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "DEPRECATED\nWill be removed in version 2.0.0\nToggle the use of an assets folder. Defaults to undefined.\nPreviously (<1.2.0) defaulted to 'true'.\n.readalong files should just contain base filenames\nnot the full paths to the images."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "use-assets-folder"
            },
            "imageAssetsFolder": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Define a path for where the image assets are located\nThis should be used instead of use-assets-folder.\nDefaults to 'assets/'. The empty string means that\nimage paths will not have a prefix added to them.\nUse of the forward slash is optional."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "image-assets-folder",
                "defaultValue": "\"assets/\""
            },
            "pageScrolling": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "\"horizontal\" | \"vertical\"",
                    "resolved": "\"horizontal\" | \"vertical\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Toggles the page scrolling from horizontal to vertical. Defaults to horizontal"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "page-scrolling",
                "defaultValue": "\"horizontal\""
            },
            "mode": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "ReadAlongMode",
                    "resolved": "\"EDIT\" | \"VIEW\"",
                    "references": {
                        "ReadAlongMode": {
                            "location": "import",
                            "path": "../../index.d",
                            "id": "../../../packages/web-component/src/index.d.ts::ReadAlongMode",
                            "referenceLocation": "ReadAlongMode"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Choose mode of ReadAlong - either view (default) or edit"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "mode",
                "defaultValue": "\"VIEW\""
            },
            "scrollBehaviour": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "ScrollBehaviour",
                    "resolved": "\"auto\" | \"smooth\"",
                    "references": {
                        "ScrollBehaviour": {
                            "location": "import",
                            "path": "../../index.d",
                            "id": "../../../packages/web-component/src/index.d.ts::ScrollBehaviour",
                            "referenceLocation": "ScrollBehaviour"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Select whether scrolling between pages should be \"smooth\" (default nicely\nanimated, good for fast computers) or \"auto\" (choppy but much less compute\nintensive)"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "scroll-behaviour",
                "defaultValue": "\"smooth\""
            },
            "displayTranslation": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Show text translation  on at load time"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "display-translation",
                "defaultValue": "true"
            },
            "playbackRateRange": {
                "type": "number",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Control the range of the playback rate: allow speeds\nfrom 100 - playback-rate-range to 100 + playback-rate-range."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "playback-rate-range",
                "defaultValue": "15"
            },
            "autoPauseAtEndOfPage": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Auto Pause at end of every page"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "attribute": "auto-pause-at-end-of-page",
                "defaultValue": "false"
            }
        };
    }
    static get states() {
        return {
            "playing": {},
            "fullscreen": {},
            "autoScroll": {},
            "hasLoaded": {},
            "images": {},
            "invalidImages": {},
            "translations": {},
            "settingsVisible": {},
            "userPreferences": {},
            "userPreferencesDirty": {},
            "hasUserPreferences": {},
            "annotations": {},
            "annotationsMenuVisible": {}
        };
    }
    static get methods() {
        return {
            "getCurrentWord": {
                "complexType": {
                    "signature": "() => Promise<Subject<string>>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Subject": {
                            "location": "import",
                            "path": "rxjs",
                            "id": "../../../node_modules/rxjs/dist/types/index.d.ts::Subject",
                            "referenceLocation": "Subject"
                        }
                    },
                    "return": "Promise<Subject<string>>"
                },
                "docs": {
                    "text": "Get Current Word",
                    "tags": []
                }
            },
            "getImages": {
                "complexType": {
                    "signature": "() => Promise<object>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<object>"
                },
                "docs": {
                    "text": "Get Images",
                    "tags": []
                }
            },
            "updateSpriteAlignments": {
                "complexType": {
                    "signature": "(alignment: Alignment) => Promise<void>",
                    "parameters": [{
                            "name": "alignment",
                            "type": "Alignment",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Alignment": {
                            "location": "import",
                            "path": "../../index.d",
                            "id": "../../../packages/web-component/src/index.d.ts::Alignment",
                            "referenceLocation": "Alignment"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Update Single Sprite",
                    "tags": []
                }
            },
            "getReadAlongElement": {
                "complexType": {
                    "signature": "() => Promise<Element>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Element": {
                            "location": "import",
                            "path": "@stencil/core",
                            "id": "../../../node_modules/@stencil/core/internal/stencil-core/index.d.ts::Element",
                            "referenceLocation": "Element"
                        }
                    },
                    "return": "Promise<Element>"
                },
                "docs": {
                    "text": "Get ReadAlong Element",
                    "tags": []
                }
            },
            "getAlignments": {
                "complexType": {
                    "signature": "() => Promise<Alignment>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Alignment": {
                            "location": "import",
                            "path": "../../index.d",
                            "id": "../../../packages/web-component/src/index.d.ts::Alignment",
                            "referenceLocation": "Alignment"
                        }
                    },
                    "return": "Promise<Alignment>"
                },
                "docs": {
                    "text": "Get Alignments",
                    "tags": []
                }
            },
            "getTranslations": {
                "complexType": {
                    "signature": "() => Promise<object>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<object>"
                },
                "docs": {
                    "text": "Get Translations",
                    "tags": []
                }
            },
            "changeTheme": {
                "complexType": {
                    "signature": "() => Promise<void>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Change theme",
                    "tags": []
                }
            },
            "setCss": {
                "complexType": {
                    "signature": "(url: any) => Promise<void>",
                    "parameters": [{
                            "name": "url",
                            "type": "any",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Update stylesheet",
                    "tags": [{
                            "name": "param",
                            "text": "url"
                        }]
                }
            },
            "addCustomFont": {
                "complexType": {
                    "signature": "(fontData: string) => Promise<void>",
                    "parameters": [{
                            "name": "fontData",
                            "type": "string",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Add custom font",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "el"; }
    static get watchers() {
        return [{
                "propName": "audio_howl_sprites",
                "methodName": "wheelHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "wheel",
                "method": "wheelHandler",
                "target": "window",
                "capture": false,
                "passive": true
            }, {
                "name": "fullscreenchange",
                "method": "fullScreenHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "keydown",
                "method": "handleKeyDown",
                "target": "document",
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=read-along.js.map

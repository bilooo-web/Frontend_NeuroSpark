'use strict';

var index = require('./index-C2iiE8_l.js');

/**
 * Helper component to generate material icon output. It is also used
 * to identify which icons are used in the application to create smaller
 * font files for integration in offline HTML files.
 */
const MatIcon = (props, children) => {
    const iconType = props.outline ? "material-icons-outlined" : "material-icons";
    delete props.outline;
    return (index.h("i", Object.assign({ class: iconType }, props), children));
};

const ErrorMessage = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.expired = index.createEvent(this, "expired");
        /**
         * The on-screen duration of the error message. Zero disables this
         * functionality, the message remains on the screen.
         */
        this.timeout = 0;
        this.timer = 0;
        this.open = true;
    }
    componentDidLoad() {
        if (this.timeout <= 0) {
            return;
        }
        this.timer = setTimeout(() => {
            this.timer = 0;
            this.expired.emit();
            this.open = false;
        }, this.timeout);
    }
    disconnectedCallback() {
        this.open = false;
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = 0;
        }
    }
    render() {
        if (!this.open) {
            return;
        }
        return (index.h("p", { "data-test-id": this.data_cy, class: "alert status-error" }, index.h(MatIcon, null, "error_outline"), " ", this.msg));
    }
};
ErrorMessage.style = `error-message {
      display: block;
    }`;

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var howler = {};

/*!
 *  howler.js v2.2.4
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

var hasRequiredHowler;

function requireHowler () {
	if (hasRequiredHowler) return howler;
	hasRequiredHowler = 1;
	(function (exports) {
		(function() {

		  /** Global Methods **/
		  /***************************************************************************/

		  /**
		   * Create the global controller. All contained methods and properties apply
		   * to all sounds that are currently playing or will be in the future.
		   */
		  var HowlerGlobal = function() {
		    this.init();
		  };
		  HowlerGlobal.prototype = {
		    /**
		     * Initialize the global Howler object.
		     * @return {Howler}
		     */
		    init: function() {
		      var self = this || Howler;

		      // Create a global ID counter.
		      self._counter = 1000;

		      // Pool of unlocked HTML5 Audio objects.
		      self._html5AudioPool = [];
		      self.html5PoolSize = 10;

		      // Internal properties.
		      self._codecs = {};
		      self._howls = [];
		      self._muted = false;
		      self._volume = 1;
		      self._canPlayEvent = 'canplaythrough';
		      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

		      // Public properties.
		      self.masterGain = null;
		      self.noAudio = false;
		      self.usingWebAudio = true;
		      self.autoSuspend = true;
		      self.ctx = null;

		      // Set to false to disable the auto audio unlocker.
		      self.autoUnlock = true;

		      // Setup the various state values for global tracking.
		      self._setup();

		      return self;
		    },

		    /**
		     * Get/set the global volume for all sounds.
		     * @param  {Float} vol Volume from 0.0 to 1.0.
		     * @return {Howler/Float}     Returns self or current volume.
		     */
		    volume: function(vol) {
		      var self = this || Howler;
		      vol = parseFloat(vol);

		      // If we don't have an AudioContext created yet, run the setup.
		      if (!self.ctx) {
		        setupAudioContext();
		      }

		      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
		        self._volume = vol;

		        // Don't update any of the nodes if we are muted.
		        if (self._muted) {
		          return self;
		        }

		        // When using Web Audio, we just need to adjust the master gain.
		        if (self.usingWebAudio) {
		          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
		        }

		        // Loop through and change volume for all HTML5 audio nodes.
		        for (var i=0; i<self._howls.length; i++) {
		          if (!self._howls[i]._webAudio) {
		            // Get all of the sounds in this Howl group.
		            var ids = self._howls[i]._getSoundIds();

		            // Loop through all sounds and change the volumes.
		            for (var j=0; j<ids.length; j++) {
		              var sound = self._howls[i]._soundById(ids[j]);

		              if (sound && sound._node) {
		                sound._node.volume = sound._volume * vol;
		              }
		            }
		          }
		        }

		        return self;
		      }

		      return self._volume;
		    },

		    /**
		     * Handle muting and unmuting globally.
		     * @param  {Boolean} muted Is muted or not.
		     */
		    mute: function(muted) {
		      var self = this || Howler;

		      // If we don't have an AudioContext created yet, run the setup.
		      if (!self.ctx) {
		        setupAudioContext();
		      }

		      self._muted = muted;

		      // With Web Audio, we just need to mute the master gain.
		      if (self.usingWebAudio) {
		        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
		      }

		      // Loop through and mute all HTML5 Audio nodes.
		      for (var i=0; i<self._howls.length; i++) {
		        if (!self._howls[i]._webAudio) {
		          // Get all of the sounds in this Howl group.
		          var ids = self._howls[i]._getSoundIds();

		          // Loop through all sounds and mark the audio node as muted.
		          for (var j=0; j<ids.length; j++) {
		            var sound = self._howls[i]._soundById(ids[j]);

		            if (sound && sound._node) {
		              sound._node.muted = (muted) ? true : sound._muted;
		            }
		          }
		        }
		      }

		      return self;
		    },

		    /**
		     * Handle stopping all sounds globally.
		     */
		    stop: function() {
		      var self = this || Howler;

		      // Loop through all Howls and stop them.
		      for (var i=0; i<self._howls.length; i++) {
		        self._howls[i].stop();
		      }

		      return self;
		    },

		    /**
		     * Unload and destroy all currently loaded Howl objects.
		     * @return {Howler}
		     */
		    unload: function() {
		      var self = this || Howler;

		      for (var i=self._howls.length-1; i>=0; i--) {
		        self._howls[i].unload();
		      }

		      // Create a new AudioContext to make sure it is fully reset.
		      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
		        self.ctx.close();
		        self.ctx = null;
		        setupAudioContext();
		      }

		      return self;
		    },

		    /**
		     * Check for codec support of specific extension.
		     * @param  {String} ext Audio file extention.
		     * @return {Boolean}
		     */
		    codecs: function(ext) {
		      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
		    },

		    /**
		     * Setup various state values for global tracking.
		     * @return {Howler}
		     */
		    _setup: function() {
		      var self = this || Howler;

		      // Keeps track of the suspend/resume state of the AudioContext.
		      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

		      // Automatically begin the 30-second suspend process
		      self._autoSuspend();

		      // Check if audio is available.
		      if (!self.usingWebAudio) {
		        // No audio is available on this system if noAudio is set to true.
		        if (typeof Audio !== 'undefined') {
		          try {
		            var test = new Audio();

		            // Check if the canplaythrough event is available.
		            if (typeof test.oncanplaythrough === 'undefined') {
		              self._canPlayEvent = 'canplay';
		            }
		          } catch(e) {
		            self.noAudio = true;
		          }
		        } else {
		          self.noAudio = true;
		        }
		      }

		      // Test to make sure audio isn't disabled in Internet Explorer.
		      try {
		        var test = new Audio();
		        if (test.muted) {
		          self.noAudio = true;
		        }
		      } catch (e) {}

		      // Check for supported codecs.
		      if (!self.noAudio) {
		        self._setupCodecs();
		      }

		      return self;
		    },

		    /**
		     * Check for browser support for various codecs and cache the results.
		     * @return {Howler}
		     */
		    _setupCodecs: function() {
		      var self = this || Howler;
		      var audioTest = null;

		      // Must wrap in a try/catch because IE11 in server mode throws an error.
		      try {
		        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
		      } catch (err) {
		        return self;
		      }

		      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
		        return self;
		      }

		      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

		      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
		      var ua = self._navigator ? self._navigator.userAgent : '';
		      var checkOpera = ua.match(/OPR\/(\d+)/g);
		      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);
		      var checkSafari = ua.indexOf('Safari') !== -1 && ua.indexOf('Chrome') === -1;
		      var safariVersion = ua.match(/Version\/(.*?) /);
		      var isOldSafari = (checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15);

		      self._codecs = {
		        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
		        mpeg: !!mpegTest,
		        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
		        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
		        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
		        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
		        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
		        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
		        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
		        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
		        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
		        weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
		        webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')),
		        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
		        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
		      };

		      return self;
		    },

		    /**
		     * Some browsers/devices will only allow audio to be played after a user interaction.
		     * Attempt to automatically unlock audio on the first user interaction.
		     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
		     * @return {Howler}
		     */
		    _unlockAudio: function() {
		      var self = this || Howler;

		      // Only run this if Web Audio is supported and it hasn't already been unlocked.
		      if (self._audioUnlocked || !self.ctx) {
		        return;
		      }

		      self._audioUnlocked = false;
		      self.autoUnlock = false;

		      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
		      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
		      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
		      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
		        self._mobileUnloaded = true;
		        self.unload();
		      }

		      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
		      // http://stackoverflow.com/questions/24119684
		      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

		      // Call this method on touch start to create and play a buffer,
		      // then check if the audio actually played to determine if
		      // audio has now been unlocked on iOS, Android, etc.
		      var unlock = function(e) {
		        // Create a pool of unlocked HTML5 Audio objects that can
		        // be used for playing sounds without user interaction. HTML5
		        // Audio objects must be individually unlocked, as opposed
		        // to the WebAudio API which only needs a single activation.
		        // This must occur before WebAudio setup or the source.onended
		        // event will not fire.
		        while (self._html5AudioPool.length < self.html5PoolSize) {
		          try {
		            var audioNode = new Audio();

		            // Mark this Audio object as unlocked to ensure it can get returned
		            // to the unlocked pool when released.
		            audioNode._unlocked = true;

		            // Add the audio node to the pool.
		            self._releaseHtml5Audio(audioNode);
		          } catch (e) {
		            self.noAudio = true;
		            break;
		          }
		        }

		        // Loop through any assigned audio nodes and unlock them.
		        for (var i=0; i<self._howls.length; i++) {
		          if (!self._howls[i]._webAudio) {
		            // Get all of the sounds in this Howl group.
		            var ids = self._howls[i]._getSoundIds();

		            // Loop through all sounds and unlock the audio nodes.
		            for (var j=0; j<ids.length; j++) {
		              var sound = self._howls[i]._soundById(ids[j]);

		              if (sound && sound._node && !sound._node._unlocked) {
		                sound._node._unlocked = true;
		                sound._node.load();
		              }
		            }
		          }
		        }

		        // Fix Android can not play in suspend state.
		        self._autoResume();

		        // Create an empty buffer.
		        var source = self.ctx.createBufferSource();
		        source.buffer = self._scratchBuffer;
		        source.connect(self.ctx.destination);

		        // Play the empty buffer.
		        if (typeof source.start === 'undefined') {
		          source.noteOn(0);
		        } else {
		          source.start(0);
		        }

		        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
		        if (typeof self.ctx.resume === 'function') {
		          self.ctx.resume();
		        }

		        // Setup a timeout to check that we are unlocked on the next event loop.
		        source.onended = function() {
		          source.disconnect(0);

		          // Update the unlocked state and prevent this check from happening again.
		          self._audioUnlocked = true;

		          // Remove the touch start listener.
		          document.removeEventListener('touchstart', unlock, true);
		          document.removeEventListener('touchend', unlock, true);
		          document.removeEventListener('click', unlock, true);
		          document.removeEventListener('keydown', unlock, true);

		          // Let all sounds know that audio has been unlocked.
		          for (var i=0; i<self._howls.length; i++) {
		            self._howls[i]._emit('unlock');
		          }
		        };
		      };

		      // Setup a touch start listener to attempt an unlock in.
		      document.addEventListener('touchstart', unlock, true);
		      document.addEventListener('touchend', unlock, true);
		      document.addEventListener('click', unlock, true);
		      document.addEventListener('keydown', unlock, true);

		      return self;
		    },

		    /**
		     * Get an unlocked HTML5 Audio object from the pool. If none are left,
		     * return a new Audio object and throw a warning.
		     * @return {Audio} HTML5 Audio object.
		     */
		    _obtainHtml5Audio: function() {
		      var self = this || Howler;

		      // Return the next object from the pool if one exists.
		      if (self._html5AudioPool.length) {
		        return self._html5AudioPool.pop();
		      }

		      //.Check if the audio is locked and throw a warning.
		      var testPlay = new Audio().play();
		      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
		        testPlay.catch(function() {
		          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
		        });
		      }

		      return new Audio();
		    },

		    /**
		     * Return an activated HTML5 Audio object to the pool.
		     * @return {Howler}
		     */
		    _releaseHtml5Audio: function(audio) {
		      var self = this || Howler;

		      // Don't add audio to the pool if we don't know if it has been unlocked.
		      if (audio._unlocked) {
		        self._html5AudioPool.push(audio);
		      }

		      return self;
		    },

		    /**
		     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
		     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
		     * @return {Howler}
		     */
		    _autoSuspend: function() {
		      var self = this;

		      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
		        return;
		      }

		      // Check if any sounds are playing.
		      for (var i=0; i<self._howls.length; i++) {
		        if (self._howls[i]._webAudio) {
		          for (var j=0; j<self._howls[i]._sounds.length; j++) {
		            if (!self._howls[i]._sounds[j]._paused) {
		              return self;
		            }
		          }
		        }
		      }

		      if (self._suspendTimer) {
		        clearTimeout(self._suspendTimer);
		      }

		      // If no sound has played after 30 seconds, suspend the context.
		      self._suspendTimer = setTimeout(function() {
		        if (!self.autoSuspend) {
		          return;
		        }

		        self._suspendTimer = null;
		        self.state = 'suspending';

		        // Handle updating the state of the audio context after suspending.
		        var handleSuspension = function() {
		          self.state = 'suspended';

		          if (self._resumeAfterSuspend) {
		            delete self._resumeAfterSuspend;
		            self._autoResume();
		          }
		        };

		        // Either the state gets suspended or it is interrupted.
		        // Either way, we need to update the state to suspended.
		        self.ctx.suspend().then(handleSuspension, handleSuspension);
		      }, 30000);

		      return self;
		    },

		    /**
		     * Automatically resume the Web Audio AudioContext when a new sound is played.
		     * @return {Howler}
		     */
		    _autoResume: function() {
		      var self = this;

		      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
		        return;
		      }

		      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
		        clearTimeout(self._suspendTimer);
		        self._suspendTimer = null;
		      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
		        self.ctx.resume().then(function() {
		          self.state = 'running';

		          // Emit to all Howls that the audio has resumed.
		          for (var i=0; i<self._howls.length; i++) {
		            self._howls[i]._emit('resume');
		          }
		        });

		        if (self._suspendTimer) {
		          clearTimeout(self._suspendTimer);
		          self._suspendTimer = null;
		        }
		      } else if (self.state === 'suspending') {
		        self._resumeAfterSuspend = true;
		      }

		      return self;
		    }
		  };

		  // Setup the global audio controller.
		  var Howler = new HowlerGlobal();

		  /** Group Methods **/
		  /***************************************************************************/

		  /**
		   * Create an audio group controller.
		   * @param {Object} o Passed in properties for this group.
		   */
		  var Howl = function(o) {
		    var self = this;

		    // Throw an error if no source is provided.
		    if (!o.src || o.src.length === 0) {
		      console.error('An array of source files must be passed with any new Howl.');
		      return;
		    }

		    self.init(o);
		  };
		  Howl.prototype = {
		    /**
		     * Initialize a new Howl group object.
		     * @param  {Object} o Passed in properties for this group.
		     * @return {Howl}
		     */
		    init: function(o) {
		      var self = this;

		      // If we don't have an AudioContext created yet, run the setup.
		      if (!Howler.ctx) {
		        setupAudioContext();
		      }

		      // Setup user-defined default properties.
		      self._autoplay = o.autoplay || false;
		      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
		      self._html5 = o.html5 || false;
		      self._muted = o.mute || false;
		      self._loop = o.loop || false;
		      self._pool = o.pool || 5;
		      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
		      self._rate = o.rate || 1;
		      self._sprite = o.sprite || {};
		      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
		      self._volume = o.volume !== undefined ? o.volume : 1;
		      self._xhr = {
		        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
		        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
		        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
		      };

		      // Setup all other default properties.
		      self._duration = 0;
		      self._state = 'unloaded';
		      self._sounds = [];
		      self._endTimers = {};
		      self._queue = [];
		      self._playLock = false;

		      // Setup event listeners.
		      self._onend = o.onend ? [{fn: o.onend}] : [];
		      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
		      self._onload = o.onload ? [{fn: o.onload}] : [];
		      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
		      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
		      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
		      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
		      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
		      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
		      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
		      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
		      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
		      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
		      self._onresume = [];

		      // Web Audio or HTML5 Audio?
		      self._webAudio = Howler.usingWebAudio && !self._html5;

		      // Automatically try to enable audio.
		      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
		        Howler._unlockAudio();
		      }

		      // Keep track of this Howl group in the global controller.
		      Howler._howls.push(self);

		      // If they selected autoplay, add a play event to the load queue.
		      if (self._autoplay) {
		        self._queue.push({
		          event: 'play',
		          action: function() {
		            self.play();
		          }
		        });
		      }

		      // Load the source file unless otherwise specified.
		      if (self._preload && self._preload !== 'none') {
		        self.load();
		      }

		      return self;
		    },

		    /**
		     * Load the audio file.
		     * @return {Howler}
		     */
		    load: function() {
		      var self = this;
		      var url = null;

		      // If no audio is available, quit immediately.
		      if (Howler.noAudio) {
		        self._emit('loaderror', null, 'No audio support.');
		        return;
		      }

		      // Make sure our source is in an array.
		      if (typeof self._src === 'string') {
		        self._src = [self._src];
		      }

		      // Loop through the sources and pick the first one that is compatible.
		      for (var i=0; i<self._src.length; i++) {
		        var ext, str;

		        if (self._format && self._format[i]) {
		          // If an extension was specified, use that instead.
		          ext = self._format[i];
		        } else {
		          // Make sure the source is a string.
		          str = self._src[i];
		          if (typeof str !== 'string') {
		            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
		            continue;
		          }

		          // Extract the file extension from the URL or base64 data URI.
		          ext = /^data:audio\/([^;,]+);/i.exec(str);
		          if (!ext) {
		            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
		          }

		          if (ext) {
		            ext = ext[1].toLowerCase();
		          }
		        }

		        // Log a warning if no extension was found.
		        if (!ext) {
		          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
		        }

		        // Check if this extension is available.
		        if (ext && Howler.codecs(ext)) {
		          url = self._src[i];
		          break;
		        }
		      }

		      if (!url) {
		        self._emit('loaderror', null, 'No codec support for selected audio sources.');
		        return;
		      }

		      self._src = url;
		      self._state = 'loading';

		      // If the hosting page is HTTPS and the source isn't,
		      // drop down to HTML5 Audio to avoid Mixed Content errors.
		      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
		        self._html5 = true;
		        self._webAudio = false;
		      }

		      // Create a new sound object and add it to the pool.
		      new Sound(self);

		      // Load and decode the audio data for playback.
		      if (self._webAudio) {
		        loadBuffer(self);
		      }

		      return self;
		    },

		    /**
		     * Play a sound or resume previous playback.
		     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
		     * @param  {Boolean} internal Internal Use: true prevents event firing.
		     * @return {Number}          Sound ID.
		     */
		    play: function(sprite, internal) {
		      var self = this;
		      var id = null;

		      // Determine if a sprite, sound id or nothing was passed
		      if (typeof sprite === 'number') {
		        id = sprite;
		        sprite = null;
		      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
		        // If the passed sprite doesn't exist, do nothing.
		        return null;
		      } else if (typeof sprite === 'undefined') {
		        // Use the default sound sprite (plays the full audio length).
		        sprite = '__default';

		        // Check if there is a single paused sound that isn't ended.
		        // If there is, play that sound. If not, continue as usual.
		        if (!self._playLock) {
		          var num = 0;
		          for (var i=0; i<self._sounds.length; i++) {
		            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
		              num++;
		              id = self._sounds[i]._id;
		            }
		          }

		          if (num === 1) {
		            sprite = null;
		          } else {
		            id = null;
		          }
		        }
		      }

		      // Get the selected node, or get one from the pool.
		      var sound = id ? self._soundById(id) : self._inactiveSound();

		      // If the sound doesn't exist, do nothing.
		      if (!sound) {
		        return null;
		      }

		      // Select the sprite definition.
		      if (id && !sprite) {
		        sprite = sound._sprite || '__default';
		      }

		      // If the sound hasn't loaded, we must wait to get the audio's duration.
		      // We also need to wait to make sure we don't run into race conditions with
		      // the order of function calls.
		      if (self._state !== 'loaded') {
		        // Set the sprite value on this sound.
		        sound._sprite = sprite;

		        // Mark this sound as not ended in case another sound is played before this one loads.
		        sound._ended = false;

		        // Add the sound to the queue to be played on load.
		        var soundId = sound._id;
		        self._queue.push({
		          event: 'play',
		          action: function() {
		            self.play(soundId);
		          }
		        });

		        return soundId;
		      }

		      // Don't play the sound if an id was passed and it is already playing.
		      if (id && !sound._paused) {
		        // Trigger the play event, in order to keep iterating through queue.
		        if (!internal) {
		          self._loadQueue('play');
		        }

		        return sound._id;
		      }

		      // Make sure the AudioContext isn't suspended, and resume it if it is.
		      if (self._webAudio) {
		        Howler._autoResume();
		      }

		      // Determine how long to play for and where to start playing.
		      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
		      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
		      var timeout = (duration * 1000) / Math.abs(sound._rate);
		      var start = self._sprite[sprite][0] / 1000;
		      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
		      sound._sprite = sprite;

		      // Mark the sound as ended instantly so that this async playback
		      // doesn't get grabbed by another call to play while this one waits to start.
		      sound._ended = false;

		      // Update the parameters of the sound.
		      var setParams = function() {
		        sound._paused = false;
		        sound._seek = seek;
		        sound._start = start;
		        sound._stop = stop;
		        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
		      };

		      // End the sound instantly if seek is at the end.
		      if (seek >= stop) {
		        self._ended(sound);
		        return;
		      }

		      // Begin the actual playback.
		      var node = sound._node;
		      if (self._webAudio) {
		        // Fire this when the sound is ready to play to begin Web Audio playback.
		        var playWebAudio = function() {
		          self._playLock = false;
		          setParams();
		          self._refreshBuffer(sound);

		          // Setup the playback params.
		          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
		          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
		          sound._playStart = Howler.ctx.currentTime;

		          // Play the sound using the supported method.
		          if (typeof node.bufferSource.start === 'undefined') {
		            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
		          } else {
		            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
		          }

		          // Start a new timer if none is present.
		          if (timeout !== Infinity) {
		            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
		          }

		          if (!internal) {
		            setTimeout(function() {
		              self._emit('play', sound._id);
		              self._loadQueue();
		            }, 0);
		          }
		        };

		        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
		          playWebAudio();
		        } else {
		          self._playLock = true;

		          // Wait for the audio context to resume before playing.
		          self.once('resume', playWebAudio);

		          // Cancel the end timer.
		          self._clearTimer(sound._id);
		        }
		      } else {
		        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
		        var playHtml5 = function() {
		          node.currentTime = seek;
		          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
		          node.volume = sound._volume * Howler.volume();
		          node.playbackRate = sound._rate;

		          // Some browsers will throw an error if this is called without user interaction.
		          try {
		            var play = node.play();

		            // Support older browsers that don't support promises, and thus don't have this issue.
		            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
		              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
		              self._playLock = true;

		              // Set param values immediately.
		              setParams();

		              // Releases the lock and executes queued actions.
		              play
		                .then(function() {
		                  self._playLock = false;
		                  node._unlocked = true;
		                  if (!internal) {
		                    self._emit('play', sound._id);
		                  } else {
		                    self._loadQueue();
		                  }
		                })
		                .catch(function() {
		                  self._playLock = false;
		                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
		                    'on mobile devices and Chrome where playback was not within a user interaction.');

		                  // Reset the ended and paused values.
		                  sound._ended = true;
		                  sound._paused = true;
		                });
		            } else if (!internal) {
		              self._playLock = false;
		              setParams();
		              self._emit('play', sound._id);
		            }

		            // Setting rate before playing won't work in IE, so we set it again here.
		            node.playbackRate = sound._rate;

		            // If the node is still paused, then we can assume there was a playback issue.
		            if (node.paused) {
		              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
		                'on mobile devices and Chrome where playback was not within a user interaction.');
		              return;
		            }

		            // Setup the end timer on sprites or listen for the ended event.
		            if (sprite !== '__default' || sound._loop) {
		              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
		            } else {
		              self._endTimers[sound._id] = function() {
		                // Fire ended on this audio node.
		                self._ended(sound);

		                // Clear this listener.
		                node.removeEventListener('ended', self._endTimers[sound._id], false);
		              };
		              node.addEventListener('ended', self._endTimers[sound._id], false);
		            }
		          } catch (err) {
		            self._emit('playerror', sound._id, err);
		          }
		        };

		        // If this is streaming audio, make sure the src is set and load again.
		        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
		          node.src = self._src;
		          node.load();
		        }

		        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
		        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
		        if (node.readyState >= 3 || loadedNoReadyState) {
		          playHtml5();
		        } else {
		          self._playLock = true;
		          self._state = 'loading';

		          var listener = function() {
		            self._state = 'loaded';
		            
		            // Begin playback.
		            playHtml5();

		            // Clear this listener.
		            node.removeEventListener(Howler._canPlayEvent, listener, false);
		          };
		          node.addEventListener(Howler._canPlayEvent, listener, false);

		          // Cancel the end timer.
		          self._clearTimer(sound._id);
		        }
		      }

		      return sound._id;
		    },

		    /**
		     * Pause playback and save current position.
		     * @param  {Number} id The sound ID (empty to pause all in group).
		     * @return {Howl}
		     */
		    pause: function(id) {
		      var self = this;

		      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
		      if (self._state !== 'loaded' || self._playLock) {
		        self._queue.push({
		          event: 'pause',
		          action: function() {
		            self.pause(id);
		          }
		        });

		        return self;
		      }

		      // If no id is passed, get all ID's to be paused.
		      var ids = self._getSoundIds(id);

		      for (var i=0; i<ids.length; i++) {
		        // Clear the end timer.
		        self._clearTimer(ids[i]);

		        // Get the sound.
		        var sound = self._soundById(ids[i]);

		        if (sound && !sound._paused) {
		          // Reset the seek position.
		          sound._seek = self.seek(ids[i]);
		          sound._rateSeek = 0;
		          sound._paused = true;

		          // Stop currently running fades.
		          self._stopFade(ids[i]);

		          if (sound._node) {
		            if (self._webAudio) {
		              // Make sure the sound has been created.
		              if (!sound._node.bufferSource) {
		                continue;
		              }

		              if (typeof sound._node.bufferSource.stop === 'undefined') {
		                sound._node.bufferSource.noteOff(0);
		              } else {
		                sound._node.bufferSource.stop(0);
		              }

		              // Clean up the buffer source.
		              self._cleanBuffer(sound._node);
		            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
		              sound._node.pause();
		            }
		          }
		        }

		        // Fire the pause event, unless `true` is passed as the 2nd argument.
		        if (!arguments[1]) {
		          self._emit('pause', sound ? sound._id : null);
		        }
		      }

		      return self;
		    },

		    /**
		     * Stop playback and reset to start.
		     * @param  {Number} id The sound ID (empty to stop all in group).
		     * @param  {Boolean} internal Internal Use: true prevents event firing.
		     * @return {Howl}
		     */
		    stop: function(id, internal) {
		      var self = this;

		      // If the sound hasn't loaded, add it to the load queue to stop when capable.
		      if (self._state !== 'loaded' || self._playLock) {
		        self._queue.push({
		          event: 'stop',
		          action: function() {
		            self.stop(id);
		          }
		        });

		        return self;
		      }

		      // If no id is passed, get all ID's to be stopped.
		      var ids = self._getSoundIds(id);

		      for (var i=0; i<ids.length; i++) {
		        // Clear the end timer.
		        self._clearTimer(ids[i]);

		        // Get the sound.
		        var sound = self._soundById(ids[i]);

		        if (sound) {
		          // Reset the seek position.
		          sound._seek = sound._start || 0;
		          sound._rateSeek = 0;
		          sound._paused = true;
		          sound._ended = true;

		          // Stop currently running fades.
		          self._stopFade(ids[i]);

		          if (sound._node) {
		            if (self._webAudio) {
		              // Make sure the sound's AudioBufferSourceNode has been created.
		              if (sound._node.bufferSource) {
		                if (typeof sound._node.bufferSource.stop === 'undefined') {
		                  sound._node.bufferSource.noteOff(0);
		                } else {
		                  sound._node.bufferSource.stop(0);
		                }

		                // Clean up the buffer source.
		                self._cleanBuffer(sound._node);
		              }
		            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
		              sound._node.currentTime = sound._start || 0;
		              sound._node.pause();

		              // If this is a live stream, stop download once the audio is stopped.
		              if (sound._node.duration === Infinity) {
		                self._clearSound(sound._node);
		              }
		            }
		          }

		          if (!internal) {
		            self._emit('stop', sound._id);
		          }
		        }
		      }

		      return self;
		    },

		    /**
		     * Mute/unmute a single sound or all sounds in this Howl group.
		     * @param  {Boolean} muted Set to true to mute and false to unmute.
		     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
		     * @return {Howl}
		     */
		    mute: function(muted, id) {
		      var self = this;

		      // If the sound hasn't loaded, add it to the load queue to mute when capable.
		      if (self._state !== 'loaded'|| self._playLock) {
		        self._queue.push({
		          event: 'mute',
		          action: function() {
		            self.mute(muted, id);
		          }
		        });

		        return self;
		      }

		      // If applying mute/unmute to all sounds, update the group's value.
		      if (typeof id === 'undefined') {
		        if (typeof muted === 'boolean') {
		          self._muted = muted;
		        } else {
		          return self._muted;
		        }
		      }

		      // If no id is passed, get all ID's to be muted.
		      var ids = self._getSoundIds(id);

		      for (var i=0; i<ids.length; i++) {
		        // Get the sound.
		        var sound = self._soundById(ids[i]);

		        if (sound) {
		          sound._muted = muted;

		          // Cancel active fade and set the volume to the end value.
		          if (sound._interval) {
		            self._stopFade(sound._id);
		          }

		          if (self._webAudio && sound._node) {
		            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
		          } else if (sound._node) {
		            sound._node.muted = Howler._muted ? true : muted;
		          }

		          self._emit('mute', sound._id);
		        }
		      }

		      return self;
		    },

		    /**
		     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
		     *   volume() -> Returns the group's volume value.
		     *   volume(id) -> Returns the sound id's current volume.
		     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
		     *   volume(vol, id) -> Sets the volume of passed sound id.
		     * @return {Howl/Number} Returns self or current volume.
		     */
		    volume: function() {
		      var self = this;
		      var args = arguments;
		      var vol, id;

		      // Determine the values based on arguments.
		      if (args.length === 0) {
		        // Return the value of the groups' volume.
		        return self._volume;
		      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
		        // First check if this is an ID, and if not, assume it is a new volume.
		        var ids = self._getSoundIds();
		        var index = ids.indexOf(args[0]);
		        if (index >= 0) {
		          id = parseInt(args[0], 10);
		        } else {
		          vol = parseFloat(args[0]);
		        }
		      } else if (args.length >= 2) {
		        vol = parseFloat(args[0]);
		        id = parseInt(args[1], 10);
		      }

		      // Update the volume or return the current volume.
		      var sound;
		      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
		        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
		        if (self._state !== 'loaded'|| self._playLock) {
		          self._queue.push({
		            event: 'volume',
		            action: function() {
		              self.volume.apply(self, args);
		            }
		          });

		          return self;
		        }

		        // Set the group volume.
		        if (typeof id === 'undefined') {
		          self._volume = vol;
		        }

		        // Update one or all volumes.
		        id = self._getSoundIds(id);
		        for (var i=0; i<id.length; i++) {
		          // Get the sound.
		          sound = self._soundById(id[i]);

		          if (sound) {
		            sound._volume = vol;

		            // Stop currently running fades.
		            if (!args[2]) {
		              self._stopFade(id[i]);
		            }

		            if (self._webAudio && sound._node && !sound._muted) {
		              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
		            } else if (sound._node && !sound._muted) {
		              sound._node.volume = vol * Howler.volume();
		            }

		            self._emit('volume', sound._id);
		          }
		        }
		      } else {
		        sound = id ? self._soundById(id) : self._sounds[0];
		        return sound ? sound._volume : 0;
		      }

		      return self;
		    },

		    /**
		     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
		     * @param  {Number} from The value to fade from (0.0 to 1.0).
		     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
		     * @param  {Number} len  Time in milliseconds to fade.
		     * @param  {Number} id   The sound id (omit to fade all sounds).
		     * @return {Howl}
		     */
		    fade: function(from, to, len, id) {
		      var self = this;

		      // If the sound hasn't loaded, add it to the load queue to fade when capable.
		      if (self._state !== 'loaded' || self._playLock) {
		        self._queue.push({
		          event: 'fade',
		          action: function() {
		            self.fade(from, to, len, id);
		          }
		        });

		        return self;
		      }

		      // Make sure the to/from/len values are numbers.
		      from = Math.min(Math.max(0, parseFloat(from)), 1);
		      to = Math.min(Math.max(0, parseFloat(to)), 1);
		      len = parseFloat(len);

		      // Set the volume to the start position.
		      self.volume(from, id);

		      // Fade the volume of one or all sounds.
		      var ids = self._getSoundIds(id);
		      for (var i=0; i<ids.length; i++) {
		        // Get the sound.
		        var sound = self._soundById(ids[i]);

		        // Create a linear fade or fall back to timeouts with HTML5 Audio.
		        if (sound) {
		          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
		          if (!id) {
		            self._stopFade(ids[i]);
		          }

		          // If we are using Web Audio, let the native methods do the actual fade.
		          if (self._webAudio && !sound._muted) {
		            var currentTime = Howler.ctx.currentTime;
		            var end = currentTime + (len / 1000);
		            sound._volume = from;
		            sound._node.gain.setValueAtTime(from, currentTime);
		            sound._node.gain.linearRampToValueAtTime(to, end);
		          }

		          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
		        }
		      }

		      return self;
		    },

		    /**
		     * Starts the internal interval to fade a sound.
		     * @param  {Object} sound Reference to sound to fade.
		     * @param  {Number} from The value to fade from (0.0 to 1.0).
		     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
		     * @param  {Number} len  Time in milliseconds to fade.
		     * @param  {Number} id   The sound id to fade.
		     * @param  {Boolean} isGroup   If true, set the volume on the group.
		     */
		    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
		      var self = this;
		      var vol = from;
		      var diff = to - from;
		      var steps = Math.abs(diff / 0.01);
		      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
		      var lastTick = Date.now();

		      // Store the value being faded to.
		      sound._fadeTo = to;

		      // Update the volume value on each interval tick.
		      sound._interval = setInterval(function() {
		        // Update the volume based on the time since the last tick.
		        var tick = (Date.now() - lastTick) / len;
		        lastTick = Date.now();
		        vol += diff * tick;

		        // Round to within 2 decimal points.
		        vol = Math.round(vol * 100) / 100;

		        // Make sure the volume is in the right bounds.
		        if (diff < 0) {
		          vol = Math.max(to, vol);
		        } else {
		          vol = Math.min(to, vol);
		        }

		        // Change the volume.
		        if (self._webAudio) {
		          sound._volume = vol;
		        } else {
		          self.volume(vol, sound._id, true);
		        }

		        // Set the group's volume.
		        if (isGroup) {
		          self._volume = vol;
		        }

		        // When the fade is complete, stop it and fire event.
		        if ((to < from && vol <= to) || (to > from && vol >= to)) {
		          clearInterval(sound._interval);
		          sound._interval = null;
		          sound._fadeTo = null;
		          self.volume(to, sound._id);
		          self._emit('fade', sound._id);
		        }
		      }, stepLen);
		    },

		    /**
		     * Internal method that stops the currently playing fade when
		     * a new fade starts, volume is changed or the sound is stopped.
		     * @param  {Number} id The sound id.
		     * @return {Howl}
		     */
		    _stopFade: function(id) {
		      var self = this;
		      var sound = self._soundById(id);

		      if (sound && sound._interval) {
		        if (self._webAudio) {
		          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
		        }

		        clearInterval(sound._interval);
		        sound._interval = null;
		        self.volume(sound._fadeTo, id);
		        sound._fadeTo = null;
		        self._emit('fade', id);
		      }

		      return self;
		    },

		    /**
		     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
		     *   loop() -> Returns the group's loop value.
		     *   loop(id) -> Returns the sound id's loop value.
		     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
		     *   loop(loop, id) -> Sets the loop value of passed sound id.
		     * @return {Howl/Boolean} Returns self or current loop value.
		     */
		    loop: function() {
		      var self = this;
		      var args = arguments;
		      var loop, id, sound;

		      // Determine the values for loop and id.
		      if (args.length === 0) {
		        // Return the grou's loop value.
		        return self._loop;
		      } else if (args.length === 1) {
		        if (typeof args[0] === 'boolean') {
		          loop = args[0];
		          self._loop = loop;
		        } else {
		          // Return this sound's loop value.
		          sound = self._soundById(parseInt(args[0], 10));
		          return sound ? sound._loop : false;
		        }
		      } else if (args.length === 2) {
		        loop = args[0];
		        id = parseInt(args[1], 10);
		      }

		      // If no id is passed, get all ID's to be looped.
		      var ids = self._getSoundIds(id);
		      for (var i=0; i<ids.length; i++) {
		        sound = self._soundById(ids[i]);

		        if (sound) {
		          sound._loop = loop;
		          if (self._webAudio && sound._node && sound._node.bufferSource) {
		            sound._node.bufferSource.loop = loop;
		            if (loop) {
		              sound._node.bufferSource.loopStart = sound._start || 0;
		              sound._node.bufferSource.loopEnd = sound._stop;

		              // If playing, restart playback to ensure looping updates.
		              if (self.playing(ids[i])) {
		                self.pause(ids[i], true);
		                self.play(ids[i], true);
		              }
		            }
		          }
		        }
		      }

		      return self;
		    },

		    /**
		     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
		     *   rate() -> Returns the first sound node's current playback rate.
		     *   rate(id) -> Returns the sound id's current playback rate.
		     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
		     *   rate(rate, id) -> Sets the playback rate of passed sound id.
		     * @return {Howl/Number} Returns self or the current playback rate.
		     */
		    rate: function() {
		      var self = this;
		      var args = arguments;
		      var rate, id;

		      // Determine the values based on arguments.
		      if (args.length === 0) {
		        // We will simply return the current rate of the first node.
		        id = self._sounds[0]._id;
		      } else if (args.length === 1) {
		        // First check if this is an ID, and if not, assume it is a new rate value.
		        var ids = self._getSoundIds();
		        var index = ids.indexOf(args[0]);
		        if (index >= 0) {
		          id = parseInt(args[0], 10);
		        } else {
		          rate = parseFloat(args[0]);
		        }
		      } else if (args.length === 2) {
		        rate = parseFloat(args[0]);
		        id = parseInt(args[1], 10);
		      }

		      // Update the playback rate or return the current value.
		      var sound;
		      if (typeof rate === 'number') {
		        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
		        if (self._state !== 'loaded' || self._playLock) {
		          self._queue.push({
		            event: 'rate',
		            action: function() {
		              self.rate.apply(self, args);
		            }
		          });

		          return self;
		        }

		        // Set the group rate.
		        if (typeof id === 'undefined') {
		          self._rate = rate;
		        }

		        // Update one or all volumes.
		        id = self._getSoundIds(id);
		        for (var i=0; i<id.length; i++) {
		          // Get the sound.
		          sound = self._soundById(id[i]);

		          if (sound) {
		            // Keep track of our position when the rate changed and update the playback
		            // start position so we can properly adjust the seek position for time elapsed.
		            if (self.playing(id[i])) {
		              sound._rateSeek = self.seek(id[i]);
		              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
		            }
		            sound._rate = rate;

		            // Change the playback rate.
		            if (self._webAudio && sound._node && sound._node.bufferSource) {
		              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
		            } else if (sound._node) {
		              sound._node.playbackRate = rate;
		            }

		            // Reset the timers.
		            var seek = self.seek(id[i]);
		            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
		            var timeout = (duration * 1000) / Math.abs(sound._rate);

		            // Start a new end timer if sound is already playing.
		            if (self._endTimers[id[i]] || !sound._paused) {
		              self._clearTimer(id[i]);
		              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
		            }

		            self._emit('rate', sound._id);
		          }
		        }
		      } else {
		        sound = self._soundById(id);
		        return sound ? sound._rate : self._rate;
		      }

		      return self;
		    },

		    /**
		     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
		     *   seek() -> Returns the first sound node's current seek position.
		     *   seek(id) -> Returns the sound id's current seek position.
		     *   seek(seek) -> Sets the seek position of the first sound node.
		     *   seek(seek, id) -> Sets the seek position of passed sound id.
		     * @return {Howl/Number} Returns self or the current seek position.
		     */
		    seek: function() {
		      var self = this;
		      var args = arguments;
		      var seek, id;

		      // Determine the values based on arguments.
		      if (args.length === 0) {
		        // We will simply return the current position of the first node.
		        if (self._sounds.length) {
		          id = self._sounds[0]._id;
		        }
		      } else if (args.length === 1) {
		        // First check if this is an ID, and if not, assume it is a new seek position.
		        var ids = self._getSoundIds();
		        var index = ids.indexOf(args[0]);
		        if (index >= 0) {
		          id = parseInt(args[0], 10);
		        } else if (self._sounds.length) {
		          id = self._sounds[0]._id;
		          seek = parseFloat(args[0]);
		        }
		      } else if (args.length === 2) {
		        seek = parseFloat(args[0]);
		        id = parseInt(args[1], 10);
		      }

		      // If there is no ID, bail out.
		      if (typeof id === 'undefined') {
		        return 0;
		      }

		      // If the sound hasn't loaded, add it to the load queue to seek when capable.
		      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
		        self._queue.push({
		          event: 'seek',
		          action: function() {
		            self.seek.apply(self, args);
		          }
		        });

		        return self;
		      }

		      // Get the sound.
		      var sound = self._soundById(id);

		      if (sound) {
		        if (typeof seek === 'number' && seek >= 0) {
		          // Pause the sound and update position for restarting playback.
		          var playing = self.playing(id);
		          if (playing) {
		            self.pause(id, true);
		          }

		          // Move the position of the track and cancel timer.
		          sound._seek = seek;
		          sound._ended = false;
		          self._clearTimer(id);

		          // Update the seek position for HTML5 Audio.
		          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
		            sound._node.currentTime = seek;
		          }

		          // Seek and emit when ready.
		          var seekAndEmit = function() {
		            // Restart the playback if the sound was playing.
		            if (playing) {
		              self.play(id, true);
		            }

		            self._emit('seek', id);
		          };

		          // Wait for the play lock to be unset before emitting (HTML5 Audio).
		          if (playing && !self._webAudio) {
		            var emitSeek = function() {
		              if (!self._playLock) {
		                seekAndEmit();
		              } else {
		                setTimeout(emitSeek, 0);
		              }
		            };
		            setTimeout(emitSeek, 0);
		          } else {
		            seekAndEmit();
		          }
		        } else {
		          if (self._webAudio) {
		            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
		            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
		            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
		          } else {
		            return sound._node.currentTime;
		          }
		        }
		      }

		      return self;
		    },

		    /**
		     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
		     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
		     * @return {Boolean} True if playing and false if not.
		     */
		    playing: function(id) {
		      var self = this;

		      // Check the passed sound ID (if any).
		      if (typeof id === 'number') {
		        var sound = self._soundById(id);
		        return sound ? !sound._paused : false;
		      }

		      // Otherwise, loop through all sounds and check if any are playing.
		      for (var i=0; i<self._sounds.length; i++) {
		        if (!self._sounds[i]._paused) {
		          return true;
		        }
		      }

		      return false;
		    },

		    /**
		     * Get the duration of this sound. Passing a sound id will return the sprite duration.
		     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
		     * @return {Number} Audio duration in seconds.
		     */
		    duration: function(id) {
		      var self = this;
		      var duration = self._duration;

		      // If we pass an ID, get the sound and return the sprite length.
		      var sound = self._soundById(id);
		      if (sound) {
		        duration = self._sprite[sound._sprite][1] / 1000;
		      }

		      return duration;
		    },

		    /**
		     * Returns the current loaded state of this Howl.
		     * @return {String} 'unloaded', 'loading', 'loaded'
		     */
		    state: function() {
		      return this._state;
		    },

		    /**
		     * Unload and destroy the current Howl object.
		     * This will immediately stop all sound instances attached to this group.
		     */
		    unload: function() {
		      var self = this;

		      // Stop playing any active sounds.
		      var sounds = self._sounds;
		      for (var i=0; i<sounds.length; i++) {
		        // Stop the sound if it is currently playing.
		        if (!sounds[i]._paused) {
		          self.stop(sounds[i]._id);
		        }

		        // Remove the source or disconnect.
		        if (!self._webAudio) {
		          // Set the source to 0-second silence to stop any downloading (except in IE).
		          self._clearSound(sounds[i]._node);

		          // Remove any event listeners.
		          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
		          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
		          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

		          // Release the Audio object back to the pool.
		          Howler._releaseHtml5Audio(sounds[i]._node);
		        }

		        // Empty out all of the nodes.
		        delete sounds[i]._node;

		        // Make sure all timers are cleared out.
		        self._clearTimer(sounds[i]._id);
		      }

		      // Remove the references in the global Howler object.
		      var index = Howler._howls.indexOf(self);
		      if (index >= 0) {
		        Howler._howls.splice(index, 1);
		      }

		      // Delete this sound from the cache (if no other Howl is using it).
		      var remCache = true;
		      for (i=0; i<Howler._howls.length; i++) {
		        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
		          remCache = false;
		          break;
		        }
		      }

		      if (cache && remCache) {
		        delete cache[self._src];
		      }

		      // Clear global errors.
		      Howler.noAudio = false;

		      // Clear out `self`.
		      self._state = 'unloaded';
		      self._sounds = [];
		      self = null;

		      return null;
		    },

		    /**
		     * Listen to a custom event.
		     * @param  {String}   event Event name.
		     * @param  {Function} fn    Listener to call.
		     * @param  {Number}   id    (optional) Only listen to events for this sound.
		     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
		     * @return {Howl}
		     */
		    on: function(event, fn, id, once) {
		      var self = this;
		      var events = self['_on' + event];

		      if (typeof fn === 'function') {
		        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
		      }

		      return self;
		    },

		    /**
		     * Remove a custom event. Call without parameters to remove all events.
		     * @param  {String}   event Event name.
		     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
		     * @param  {Number}   id    (optional) Only remove events for this sound.
		     * @return {Howl}
		     */
		    off: function(event, fn, id) {
		      var self = this;
		      var events = self['_on' + event];
		      var i = 0;

		      // Allow passing just an event and ID.
		      if (typeof fn === 'number') {
		        id = fn;
		        fn = null;
		      }

		      if (fn || id) {
		        // Loop through event store and remove the passed function.
		        for (i=0; i<events.length; i++) {
		          var isId = (id === events[i].id);
		          if (fn === events[i].fn && isId || !fn && isId) {
		            events.splice(i, 1);
		            break;
		          }
		        }
		      } else if (event) {
		        // Clear out all events of this type.
		        self['_on' + event] = [];
		      } else {
		        // Clear out all events of every type.
		        var keys = Object.keys(self);
		        for (i=0; i<keys.length; i++) {
		          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
		            self[keys[i]] = [];
		          }
		        }
		      }

		      return self;
		    },

		    /**
		     * Listen to a custom event and remove it once fired.
		     * @param  {String}   event Event name.
		     * @param  {Function} fn    Listener to call.
		     * @param  {Number}   id    (optional) Only listen to events for this sound.
		     * @return {Howl}
		     */
		    once: function(event, fn, id) {
		      var self = this;

		      // Setup the event listener.
		      self.on(event, fn, id, 1);

		      return self;
		    },

		    /**
		     * Emit all events of a specific type and pass the sound id.
		     * @param  {String} event Event name.
		     * @param  {Number} id    Sound ID.
		     * @param  {Number} msg   Message to go with event.
		     * @return {Howl}
		     */
		    _emit: function(event, id, msg) {
		      var self = this;
		      var events = self['_on' + event];

		      // Loop through event store and fire all functions.
		      for (var i=events.length-1; i>=0; i--) {
		        // Only fire the listener if the correct ID is used.
		        if (!events[i].id || events[i].id === id || event === 'load') {
		          setTimeout(function(fn) {
		            fn.call(this, id, msg);
		          }.bind(self, events[i].fn), 0);

		          // If this event was setup with `once`, remove it.
		          if (events[i].once) {
		            self.off(event, events[i].fn, events[i].id);
		          }
		        }
		      }

		      // Pass the event type into load queue so that it can continue stepping.
		      self._loadQueue(event);

		      return self;
		    },

		    /**
		     * Queue of actions initiated before the sound has loaded.
		     * These will be called in sequence, with the next only firing
		     * after the previous has finished executing (even if async like play).
		     * @return {Howl}
		     */
		    _loadQueue: function(event) {
		      var self = this;

		      if (self._queue.length > 0) {
		        var task = self._queue[0];

		        // Remove this task if a matching event was passed.
		        if (task.event === event) {
		          self._queue.shift();
		          self._loadQueue();
		        }

		        // Run the task if no event type is passed.
		        if (!event) {
		          task.action();
		        }
		      }

		      return self;
		    },

		    /**
		     * Fired when playback ends at the end of the duration.
		     * @param  {Sound} sound The sound object to work with.
		     * @return {Howl}
		     */
		    _ended: function(sound) {
		      var self = this;
		      var sprite = sound._sprite;

		      // If we are using IE and there was network latency we may be clipping
		      // audio before it completes playing. Lets check the node to make sure it
		      // believes it has completed, before ending the playback.
		      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
		        setTimeout(self._ended.bind(self, sound), 100);
		        return self;
		      }

		      // Should this sound loop?
		      var loop = !!(sound._loop || self._sprite[sprite][2]);

		      // Fire the ended event.
		      self._emit('end', sound._id);

		      // Restart the playback for HTML5 Audio loop.
		      if (!self._webAudio && loop) {
		        self.stop(sound._id, true).play(sound._id);
		      }

		      // Restart this timer if on a Web Audio loop.
		      if (self._webAudio && loop) {
		        self._emit('play', sound._id);
		        sound._seek = sound._start || 0;
		        sound._rateSeek = 0;
		        sound._playStart = Howler.ctx.currentTime;

		        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
		        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
		      }

		      // Mark the node as paused.
		      if (self._webAudio && !loop) {
		        sound._paused = true;
		        sound._ended = true;
		        sound._seek = sound._start || 0;
		        sound._rateSeek = 0;
		        self._clearTimer(sound._id);

		        // Clean up the buffer source.
		        self._cleanBuffer(sound._node);

		        // Attempt to auto-suspend AudioContext if no sounds are still playing.
		        Howler._autoSuspend();
		      }

		      // When using a sprite, end the track.
		      if (!self._webAudio && !loop) {
		        self.stop(sound._id, true);
		      }

		      return self;
		    },

		    /**
		     * Clear the end timer for a sound playback.
		     * @param  {Number} id The sound ID.
		     * @return {Howl}
		     */
		    _clearTimer: function(id) {
		      var self = this;

		      if (self._endTimers[id]) {
		        // Clear the timeout or remove the ended listener.
		        if (typeof self._endTimers[id] !== 'function') {
		          clearTimeout(self._endTimers[id]);
		        } else {
		          var sound = self._soundById(id);
		          if (sound && sound._node) {
		            sound._node.removeEventListener('ended', self._endTimers[id], false);
		          }
		        }

		        delete self._endTimers[id];
		      }

		      return self;
		    },

		    /**
		     * Return the sound identified by this ID, or return null.
		     * @param  {Number} id Sound ID
		     * @return {Object}    Sound object or null.
		     */
		    _soundById: function(id) {
		      var self = this;

		      // Loop through all sounds and find the one with this ID.
		      for (var i=0; i<self._sounds.length; i++) {
		        if (id === self._sounds[i]._id) {
		          return self._sounds[i];
		        }
		      }

		      return null;
		    },

		    /**
		     * Return an inactive sound from the pool or create a new one.
		     * @return {Sound} Sound playback object.
		     */
		    _inactiveSound: function() {
		      var self = this;

		      self._drain();

		      // Find the first inactive node to recycle.
		      for (var i=0; i<self._sounds.length; i++) {
		        if (self._sounds[i]._ended) {
		          return self._sounds[i].reset();
		        }
		      }

		      // If no inactive node was found, create a new one.
		      return new Sound(self);
		    },

		    /**
		     * Drain excess inactive sounds from the pool.
		     */
		    _drain: function() {
		      var self = this;
		      var limit = self._pool;
		      var cnt = 0;
		      var i = 0;

		      // If there are less sounds than the max pool size, we are done.
		      if (self._sounds.length < limit) {
		        return;
		      }

		      // Count the number of inactive sounds.
		      for (i=0; i<self._sounds.length; i++) {
		        if (self._sounds[i]._ended) {
		          cnt++;
		        }
		      }

		      // Remove excess inactive sounds, going in reverse order.
		      for (i=self._sounds.length - 1; i>=0; i--) {
		        if (cnt <= limit) {
		          return;
		        }

		        if (self._sounds[i]._ended) {
		          // Disconnect the audio source when using Web Audio.
		          if (self._webAudio && self._sounds[i]._node) {
		            self._sounds[i]._node.disconnect(0);
		          }

		          // Remove sounds until we have the pool size.
		          self._sounds.splice(i, 1);
		          cnt--;
		        }
		      }
		    },

		    /**
		     * Get all ID's from the sounds pool.
		     * @param  {Number} id Only return one ID if one is passed.
		     * @return {Array}    Array of IDs.
		     */
		    _getSoundIds: function(id) {
		      var self = this;

		      if (typeof id === 'undefined') {
		        var ids = [];
		        for (var i=0; i<self._sounds.length; i++) {
		          ids.push(self._sounds[i]._id);
		        }

		        return ids;
		      } else {
		        return [id];
		      }
		    },

		    /**
		     * Load the sound back into the buffer source.
		     * @param  {Sound} sound The sound object to work with.
		     * @return {Howl}
		     */
		    _refreshBuffer: function(sound) {
		      var self = this;

		      // Setup the buffer source for playback.
		      sound._node.bufferSource = Howler.ctx.createBufferSource();
		      sound._node.bufferSource.buffer = cache[self._src];

		      // Connect to the correct node.
		      if (sound._panner) {
		        sound._node.bufferSource.connect(sound._panner);
		      } else {
		        sound._node.bufferSource.connect(sound._node);
		      }

		      // Setup looping and playback rate.
		      sound._node.bufferSource.loop = sound._loop;
		      if (sound._loop) {
		        sound._node.bufferSource.loopStart = sound._start || 0;
		        sound._node.bufferSource.loopEnd = sound._stop || 0;
		      }
		      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

		      return self;
		    },

		    /**
		     * Prevent memory leaks by cleaning up the buffer source after playback.
		     * @param  {Object} node Sound's audio node containing the buffer source.
		     * @return {Howl}
		     */
		    _cleanBuffer: function(node) {
		      var self = this;
		      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

		      if (!node.bufferSource) {
		        return self;
		      }

		      if (Howler._scratchBuffer && node.bufferSource) {
		        node.bufferSource.onended = null;
		        node.bufferSource.disconnect(0);
		        if (isIOS) {
		          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
		        }
		      }
		      node.bufferSource = null;

		      return self;
		    },

		    /**
		     * Set the source to a 0-second silence to stop any downloading (except in IE).
		     * @param  {Object} node Audio node to clear.
		     */
		    _clearSound: function(node) {
		      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
		      if (!checkIE) {
		        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
		      }
		    }
		  };

		  /** Single Sound Methods **/
		  /***************************************************************************/

		  /**
		   * Setup the sound object, which each node attached to a Howl group is contained in.
		   * @param {Object} howl The Howl parent group.
		   */
		  var Sound = function(howl) {
		    this._parent = howl;
		    this.init();
		  };
		  Sound.prototype = {
		    /**
		     * Initialize a new Sound object.
		     * @return {Sound}
		     */
		    init: function() {
		      var self = this;
		      var parent = self._parent;

		      // Setup the default parameters.
		      self._muted = parent._muted;
		      self._loop = parent._loop;
		      self._volume = parent._volume;
		      self._rate = parent._rate;
		      self._seek = 0;
		      self._paused = true;
		      self._ended = true;
		      self._sprite = '__default';

		      // Generate a unique ID for this sound.
		      self._id = ++Howler._counter;

		      // Add itself to the parent's pool.
		      parent._sounds.push(self);

		      // Create the new node.
		      self.create();

		      return self;
		    },

		    /**
		     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
		     * @return {Sound}
		     */
		    create: function() {
		      var self = this;
		      var parent = self._parent;
		      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

		      if (parent._webAudio) {
		        // Create the gain node for controlling volume (the source will connect to this).
		        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
		        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
		        self._node.paused = true;
		        self._node.connect(Howler.masterGain);
		      } else if (!Howler.noAudio) {
		        // Get an unlocked Audio object from the pool.
		        self._node = Howler._obtainHtml5Audio();

		        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
		        self._errorFn = self._errorListener.bind(self);
		        self._node.addEventListener('error', self._errorFn, false);

		        // Listen for 'canplaythrough' event to let us know the sound is ready.
		        self._loadFn = self._loadListener.bind(self);
		        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

		        // Listen for the 'ended' event on the sound to account for edge-case where
		        // a finite sound has a duration of Infinity.
		        self._endFn = self._endListener.bind(self);
		        self._node.addEventListener('ended', self._endFn, false);

		        // Setup the new audio node.
		        self._node.src = parent._src;
		        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
		        self._node.volume = volume * Howler.volume();

		        // Begin loading the source.
		        self._node.load();
		      }

		      return self;
		    },

		    /**
		     * Reset the parameters of this sound to the original state (for recycle).
		     * @return {Sound}
		     */
		    reset: function() {
		      var self = this;
		      var parent = self._parent;

		      // Reset all of the parameters of this sound.
		      self._muted = parent._muted;
		      self._loop = parent._loop;
		      self._volume = parent._volume;
		      self._rate = parent._rate;
		      self._seek = 0;
		      self._rateSeek = 0;
		      self._paused = true;
		      self._ended = true;
		      self._sprite = '__default';

		      // Generate a new ID so that it isn't confused with the previous sound.
		      self._id = ++Howler._counter;

		      return self;
		    },

		    /**
		     * HTML5 Audio error listener callback.
		     */
		    _errorListener: function() {
		      var self = this;

		      // Fire an error event and pass back the code.
		      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

		      // Clear the event listener.
		      self._node.removeEventListener('error', self._errorFn, false);
		    },

		    /**
		     * HTML5 Audio canplaythrough listener callback.
		     */
		    _loadListener: function() {
		      var self = this;
		      var parent = self._parent;

		      // Round up the duration to account for the lower precision in HTML5 Audio.
		      parent._duration = Math.ceil(self._node.duration * 10) / 10;

		      // Setup a sprite if none is defined.
		      if (Object.keys(parent._sprite).length === 0) {
		        parent._sprite = {__default: [0, parent._duration * 1000]};
		      }

		      if (parent._state !== 'loaded') {
		        parent._state = 'loaded';
		        parent._emit('load');
		        parent._loadQueue();
		      }

		      // Clear the event listener.
		      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
		    },

		    /**
		     * HTML5 Audio ended listener callback.
		     */
		    _endListener: function() {
		      var self = this;
		      var parent = self._parent;

		      // Only handle the `ended`` event if the duration is Infinity.
		      if (parent._duration === Infinity) {
		        // Update the parent duration to match the real audio duration.
		        // Round up the duration to account for the lower precision in HTML5 Audio.
		        parent._duration = Math.ceil(self._node.duration * 10) / 10;

		        // Update the sprite that corresponds to the real duration.
		        if (parent._sprite.__default[1] === Infinity) {
		          parent._sprite.__default[1] = parent._duration * 1000;
		        }

		        // Run the regular ended method.
		        parent._ended(self);
		      }

		      // Clear the event listener since the duration is now correct.
		      self._node.removeEventListener('ended', self._endFn, false);
		    }
		  };

		  /** Helper Methods **/
		  /***************************************************************************/

		  var cache = {};

		  /**
		   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
		   * @param  {Howl} self
		   */
		  var loadBuffer = function(self) {
		    var url = self._src;

		    // Check if the buffer has already been cached and use it instead.
		    if (cache[url]) {
		      // Set the duration from the cache.
		      self._duration = cache[url].duration;

		      // Load the sound into this Howl.
		      loadSound(self);

		      return;
		    }

		    if (/^data:[^;]+;base64,/.test(url)) {
		      // Decode the base64 data URI without XHR, since some browsers don't support it.
		      var data = atob(url.split(',')[1]);
		      var dataView = new Uint8Array(data.length);
		      for (var i=0; i<data.length; ++i) {
		        dataView[i] = data.charCodeAt(i);
		      }

		      decodeAudioData(dataView.buffer, self);
		    } else {
		      // Load the buffer from the URL.
		      var xhr = new XMLHttpRequest();
		      xhr.open(self._xhr.method, url, true);
		      xhr.withCredentials = self._xhr.withCredentials;
		      xhr.responseType = 'arraybuffer';

		      // Apply any custom headers to the request.
		      if (self._xhr.headers) {
		        Object.keys(self._xhr.headers).forEach(function(key) {
		          xhr.setRequestHeader(key, self._xhr.headers[key]);
		        });
		      }

		      xhr.onload = function() {
		        // Make sure we get a successful response back.
		        var code = (xhr.status + '')[0];
		        if (code !== '0' && code !== '2' && code !== '3') {
		          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
		          return;
		        }

		        decodeAudioData(xhr.response, self);
		      };
		      xhr.onerror = function() {
		        // If there is an error, switch to HTML5 Audio.
		        if (self._webAudio) {
		          self._html5 = true;
		          self._webAudio = false;
		          self._sounds = [];
		          delete cache[url];
		          self.load();
		        }
		      };
		      safeXhrSend(xhr);
		    }
		  };

		  /**
		   * Send the XHR request wrapped in a try/catch.
		   * @param  {Object} xhr XHR to send.
		   */
		  var safeXhrSend = function(xhr) {
		    try {
		      xhr.send();
		    } catch (e) {
		      xhr.onerror();
		    }
		  };

		  /**
		   * Decode audio data from an array buffer.
		   * @param  {ArrayBuffer} arraybuffer The audio data.
		   * @param  {Howl}        self
		   */
		  var decodeAudioData = function(arraybuffer, self) {
		    // Fire a load error if something broke.
		    var error = function() {
		      self._emit('loaderror', null, 'Decoding audio data failed.');
		    };

		    // Load the sound on success.
		    var success = function(buffer) {
		      if (buffer && self._sounds.length > 0) {
		        cache[self._src] = buffer;
		        loadSound(self, buffer);
		      } else {
		        error();
		      }
		    };

		    // Decode the buffer into an audio source.
		    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
		      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
		    } else {
		      Howler.ctx.decodeAudioData(arraybuffer, success, error);
		    }
		  };

		  /**
		   * Sound is now loaded, so finish setting everything up and fire the loaded event.
		   * @param  {Howl} self
		   * @param  {Object} buffer The decoded buffer sound source.
		   */
		  var loadSound = function(self, buffer) {
		    // Set the duration.
		    if (buffer && !self._duration) {
		      self._duration = buffer.duration;
		    }

		    // Setup a sprite if none is defined.
		    if (Object.keys(self._sprite).length === 0) {
		      self._sprite = {__default: [0, self._duration * 1000]};
		    }

		    // Fire the loaded event.
		    if (self._state !== 'loaded') {
		      self._state = 'loaded';
		      self._emit('load');
		      self._loadQueue();
		    }
		  };

		  /**
		   * Setup the audio context when available, or switch to HTML5 Audio mode.
		   */
		  var setupAudioContext = function() {
		    // If we have already detected that Web Audio isn't supported, don't run this step again.
		    if (!Howler.usingWebAudio) {
		      return;
		    }

		    // Check if we are using Web Audio and setup the AudioContext if we are.
		    try {
		      if (typeof AudioContext !== 'undefined') {
		        Howler.ctx = new AudioContext();
		      } else if (typeof webkitAudioContext !== 'undefined') {
		        Howler.ctx = new webkitAudioContext();
		      } else {
		        Howler.usingWebAudio = false;
		      }
		    } catch(e) {
		      Howler.usingWebAudio = false;
		    }

		    // If the audio context creation still failed, set using web audio to false.
		    if (!Howler.ctx) {
		      Howler.usingWebAudio = false;
		    }

		    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
		    // If it is, disable Web Audio as it causes crashing.
		    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
		    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
		    var version = appVersion ? parseInt(appVersion[1], 10) : null;
		    if (iOS && version && version < 9) {
		      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
		      if (Howler._navigator && !safari) {
		        Howler.usingWebAudio = false;
		      }
		    }

		    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
		    if (Howler.usingWebAudio) {
		      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
		      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
		      Howler.masterGain.connect(Howler.ctx.destination);
		    }

		    // Re-run the setup on Howler.
		    Howler._setup();
		  };

		  // Add support for CommonJS libraries such as browserify.
		  {
		    exports.Howler = Howler;
		    exports.Howl = Howl;
		  }

		  // Add to global in Node.js (for testing, etc).
		  if (typeof commonjsGlobal !== 'undefined') {
		    commonjsGlobal.HowlerGlobal = HowlerGlobal;
		    commonjsGlobal.Howler = Howler;
		    commonjsGlobal.Howl = Howl;
		    commonjsGlobal.Sound = Sound;
		  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
		    window.HowlerGlobal = HowlerGlobal;
		    window.Howler = Howler;
		    window.Howl = Howl;
		    window.Sound = Sound;
		  }
		})();


		/*!
		 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
		 *  
		 *  howler.js v2.2.4
		 *  howlerjs.com
		 *
		 *  (c) 2013-2020, James Simpson of GoldFire Studios
		 *  goldfirestudios.com
		 *
		 *  MIT License
		 */

		(function() {

		  // Setup default properties.
		  HowlerGlobal.prototype._pos = [0, 0, 0];
		  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

		  /** Global Methods **/
		  /***************************************************************************/

		  /**
		   * Helper method to update the stereo panning position of all current Howls.
		   * Future Howls will not use this value unless explicitly set.
		   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
		   * @return {Howler/Number}     Self or current stereo panning value.
		   */
		  HowlerGlobal.prototype.stereo = function(pan) {
		    var self = this;

		    // Stop right here if not using Web Audio.
		    if (!self.ctx || !self.ctx.listener) {
		      return self;
		    }

		    // Loop through all Howls and update their stereo panning.
		    for (var i=self._howls.length-1; i>=0; i--) {
		      self._howls[i].stereo(pan);
		    }

		    return self;
		  };

		  /**
		   * Get/set the position of the listener in 3D cartesian space. Sounds using
		   * 3D position will be relative to the listener's position.
		   * @param  {Number} x The x-position of the listener.
		   * @param  {Number} y The y-position of the listener.
		   * @param  {Number} z The z-position of the listener.
		   * @return {Howler/Array}   Self or current listener position.
		   */
		  HowlerGlobal.prototype.pos = function(x, y, z) {
		    var self = this;

		    // Stop right here if not using Web Audio.
		    if (!self.ctx || !self.ctx.listener) {
		      return self;
		    }

		    // Set the defaults for optional 'y' & 'z'.
		    y = (typeof y !== 'number') ? self._pos[1] : y;
		    z = (typeof z !== 'number') ? self._pos[2] : z;

		    if (typeof x === 'number') {
		      self._pos = [x, y, z];

		      if (typeof self.ctx.listener.positionX !== 'undefined') {
		        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
		      } else {
		        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
		      }
		    } else {
		      return self._pos;
		    }

		    return self;
		  };

		  /**
		   * Get/set the direction the listener is pointing in the 3D cartesian space.
		   * A front and up vector must be provided. The front is the direction the
		   * face of the listener is pointing, and up is the direction the top of the
		   * listener is pointing. Thus, these values are expected to be at right angles
		   * from each other.
		   * @param  {Number} x   The x-orientation of the listener.
		   * @param  {Number} y   The y-orientation of the listener.
		   * @param  {Number} z   The z-orientation of the listener.
		   * @param  {Number} xUp The x-orientation of the top of the listener.
		   * @param  {Number} yUp The y-orientation of the top of the listener.
		   * @param  {Number} zUp The z-orientation of the top of the listener.
		   * @return {Howler/Array}     Returns self or the current orientation vectors.
		   */
		  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
		    var self = this;

		    // Stop right here if not using Web Audio.
		    if (!self.ctx || !self.ctx.listener) {
		      return self;
		    }

		    // Set the defaults for optional 'y' & 'z'.
		    var or = self._orientation;
		    y = (typeof y !== 'number') ? or[1] : y;
		    z = (typeof z !== 'number') ? or[2] : z;
		    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
		    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
		    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

		    if (typeof x === 'number') {
		      self._orientation = [x, y, z, xUp, yUp, zUp];

		      if (typeof self.ctx.listener.forwardX !== 'undefined') {
		        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
		        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
		      } else {
		        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
		      }
		    } else {
		      return or;
		    }

		    return self;
		  };

		  /** Group Methods **/
		  /***************************************************************************/

		  /**
		   * Add new properties to the core init.
		   * @param  {Function} _super Core init method.
		   * @return {Howl}
		   */
		  Howl.prototype.init = (function(_super) {
		    return function(o) {
		      var self = this;

		      // Setup user-defined default properties.
		      self._orientation = o.orientation || [1, 0, 0];
		      self._stereo = o.stereo || null;
		      self._pos = o.pos || null;
		      self._pannerAttr = {
		        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
		        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
		        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
		        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
		        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
		        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
		        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
		        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
		      };

		      // Setup event listeners.
		      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
		      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
		      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

		      // Complete initilization with howler.js core's init function.
		      return _super.call(this, o);
		    };
		  })(Howl.prototype.init);

		  /**
		   * Get/set the stereo panning of the audio source for this sound or all in the group.
		   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
		   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
		   * @return {Howl/Number}    Returns self or the current stereo panning value.
		   */
		  Howl.prototype.stereo = function(pan, id) {
		    var self = this;

		    // Stop right here if not using Web Audio.
		    if (!self._webAudio) {
		      return self;
		    }

		    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
		    if (self._state !== 'loaded') {
		      self._queue.push({
		        event: 'stereo',
		        action: function() {
		          self.stereo(pan, id);
		        }
		      });

		      return self;
		    }

		    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
		    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

		    // Setup the group's stereo panning if no ID is passed.
		    if (typeof id === 'undefined') {
		      // Return the group's stereo panning if no parameters are passed.
		      if (typeof pan === 'number') {
		        self._stereo = pan;
		        self._pos = [pan, 0, 0];
		      } else {
		        return self._stereo;
		      }
		    }

		    // Change the streo panning of one or all sounds in group.
		    var ids = self._getSoundIds(id);
		    for (var i=0; i<ids.length; i++) {
		      // Get the sound.
		      var sound = self._soundById(ids[i]);

		      if (sound) {
		        if (typeof pan === 'number') {
		          sound._stereo = pan;
		          sound._pos = [pan, 0, 0];

		          if (sound._node) {
		            // If we are falling back, make sure the panningModel is equalpower.
		            sound._pannerAttr.panningModel = 'equalpower';

		            // Check if there is a panner setup and create a new one if not.
		            if (!sound._panner || !sound._panner.pan) {
		              setupPanner(sound, pannerType);
		            }

		            if (pannerType === 'spatial') {
		              if (typeof sound._panner.positionX !== 'undefined') {
		                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
		                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
		                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
		              } else {
		                sound._panner.setPosition(pan, 0, 0);
		              }
		            } else {
		              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
		            }
		          }

		          self._emit('stereo', sound._id);
		        } else {
		          return sound._stereo;
		        }
		      }
		    }

		    return self;
		  };

		  /**
		   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
		   * @param  {Number} x  The x-position of the audio source.
		   * @param  {Number} y  The y-position of the audio source.
		   * @param  {Number} z  The z-position of the audio source.
		   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
		   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
		   */
		  Howl.prototype.pos = function(x, y, z, id) {
		    var self = this;

		    // Stop right here if not using Web Audio.
		    if (!self._webAudio) {
		      return self;
		    }

		    // If the sound hasn't loaded, add it to the load queue to change position when capable.
		    if (self._state !== 'loaded') {
		      self._queue.push({
		        event: 'pos',
		        action: function() {
		          self.pos(x, y, z, id);
		        }
		      });

		      return self;
		    }

		    // Set the defaults for optional 'y' & 'z'.
		    y = (typeof y !== 'number') ? 0 : y;
		    z = (typeof z !== 'number') ? -0.5 : z;

		    // Setup the group's spatial position if no ID is passed.
		    if (typeof id === 'undefined') {
		      // Return the group's spatial position if no parameters are passed.
		      if (typeof x === 'number') {
		        self._pos = [x, y, z];
		      } else {
		        return self._pos;
		      }
		    }

		    // Change the spatial position of one or all sounds in group.
		    var ids = self._getSoundIds(id);
		    for (var i=0; i<ids.length; i++) {
		      // Get the sound.
		      var sound = self._soundById(ids[i]);

		      if (sound) {
		        if (typeof x === 'number') {
		          sound._pos = [x, y, z];

		          if (sound._node) {
		            // Check if there is a panner setup and create a new one if not.
		            if (!sound._panner || sound._panner.pan) {
		              setupPanner(sound, 'spatial');
		            }

		            if (typeof sound._panner.positionX !== 'undefined') {
		              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
		              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
		              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
		            } else {
		              sound._panner.setPosition(x, y, z);
		            }
		          }

		          self._emit('pos', sound._id);
		        } else {
		          return sound._pos;
		        }
		      }
		    }

		    return self;
		  };

		  /**
		   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
		   * space. Depending on how direction the sound is, based on the `cone` attributes,
		   * a sound pointing away from the listener can be quiet or silent.
		   * @param  {Number} x  The x-orientation of the source.
		   * @param  {Number} y  The y-orientation of the source.
		   * @param  {Number} z  The z-orientation of the source.
		   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
		   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
		   */
		  Howl.prototype.orientation = function(x, y, z, id) {
		    var self = this;

		    // Stop right here if not using Web Audio.
		    if (!self._webAudio) {
		      return self;
		    }

		    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
		    if (self._state !== 'loaded') {
		      self._queue.push({
		        event: 'orientation',
		        action: function() {
		          self.orientation(x, y, z, id);
		        }
		      });

		      return self;
		    }

		    // Set the defaults for optional 'y' & 'z'.
		    y = (typeof y !== 'number') ? self._orientation[1] : y;
		    z = (typeof z !== 'number') ? self._orientation[2] : z;

		    // Setup the group's spatial orientation if no ID is passed.
		    if (typeof id === 'undefined') {
		      // Return the group's spatial orientation if no parameters are passed.
		      if (typeof x === 'number') {
		        self._orientation = [x, y, z];
		      } else {
		        return self._orientation;
		      }
		    }

		    // Change the spatial orientation of one or all sounds in group.
		    var ids = self._getSoundIds(id);
		    for (var i=0; i<ids.length; i++) {
		      // Get the sound.
		      var sound = self._soundById(ids[i]);

		      if (sound) {
		        if (typeof x === 'number') {
		          sound._orientation = [x, y, z];

		          if (sound._node) {
		            // Check if there is a panner setup and create a new one if not.
		            if (!sound._panner) {
		              // Make sure we have a position to setup the node with.
		              if (!sound._pos) {
		                sound._pos = self._pos || [0, 0, -0.5];
		              }

		              setupPanner(sound, 'spatial');
		            }

		            if (typeof sound._panner.orientationX !== 'undefined') {
		              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
		              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
		              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
		            } else {
		              sound._panner.setOrientation(x, y, z);
		            }
		          }

		          self._emit('orientation', sound._id);
		        } else {
		          return sound._orientation;
		        }
		      }
		    }

		    return self;
		  };

		  /**
		   * Get/set the panner node's attributes for a sound or group of sounds.
		   * This method can optionall take 0, 1 or 2 arguments.
		   *   pannerAttr() -> Returns the group's values.
		   *   pannerAttr(id) -> Returns the sound id's values.
		   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
		   *   pannerAttr(o, id) -> Set's the values of passed sound id.
		   *
		   *   Attributes:
		   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
		   *                      inside of which there will be no volume reduction.
		   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
		   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
		   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
		   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
		   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
		   *                     listener. Can be `linear`, `inverse` or `exponential.
		   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
		   *                   will not be reduced any further.
		   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
		   *                   This is simply a variable of the distance model and has a different effect depending on which model
		   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
		   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
		   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ]`
		   *                     with `inverse` and `exponential`.
		   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
		   *                     Can be `HRTF` or `equalpower`.
		   *
		   * @return {Howl/Object} Returns self or current panner attributes.
		   */
		  Howl.prototype.pannerAttr = function() {
		    var self = this;
		    var args = arguments;
		    var o, id, sound;

		    // Stop right here if not using Web Audio.
		    if (!self._webAudio) {
		      return self;
		    }

		    // Determine the values based on arguments.
		    if (args.length === 0) {
		      // Return the group's panner attribute values.
		      return self._pannerAttr;
		    } else if (args.length === 1) {
		      if (typeof args[0] === 'object') {
		        o = args[0];

		        // Set the grou's panner attribute values.
		        if (typeof id === 'undefined') {
		          if (!o.pannerAttr) {
		            o.pannerAttr = {
		              coneInnerAngle: o.coneInnerAngle,
		              coneOuterAngle: o.coneOuterAngle,
		              coneOuterGain: o.coneOuterGain,
		              distanceModel: o.distanceModel,
		              maxDistance: o.maxDistance,
		              refDistance: o.refDistance,
		              rolloffFactor: o.rolloffFactor,
		              panningModel: o.panningModel
		            };
		          }

		          self._pannerAttr = {
		            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
		            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
		            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
		            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
		            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
		            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
		            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
		            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
		          };
		        }
		      } else {
		        // Return this sound's panner attribute values.
		        sound = self._soundById(parseInt(args[0], 10));
		        return sound ? sound._pannerAttr : self._pannerAttr;
		      }
		    } else if (args.length === 2) {
		      o = args[0];
		      id = parseInt(args[1], 10);
		    }

		    // Update the values of the specified sounds.
		    var ids = self._getSoundIds(id);
		    for (var i=0; i<ids.length; i++) {
		      sound = self._soundById(ids[i]);

		      if (sound) {
		        // Merge the new values into the sound.
		        var pa = sound._pannerAttr;
		        pa = {
		          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
		          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
		          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
		          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
		          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
		          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
		          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
		          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
		        };

		        // Create a new panner node if one doesn't already exist.
		        var panner = sound._panner;
		        if (!panner) {
		          // Make sure we have a position to setup the node with.
		          if (!sound._pos) {
		            sound._pos = self._pos || [0, 0, -0.5];
		          }

		          // Create a new panner node.
		          setupPanner(sound, 'spatial');
		          panner = sound._panner;
		        }

		        // Update the panner values or create a new panner if none exists.
		        panner.coneInnerAngle = pa.coneInnerAngle;
		        panner.coneOuterAngle = pa.coneOuterAngle;
		        panner.coneOuterGain = pa.coneOuterGain;
		        panner.distanceModel = pa.distanceModel;
		        panner.maxDistance = pa.maxDistance;
		        panner.refDistance = pa.refDistance;
		        panner.rolloffFactor = pa.rolloffFactor;
		        panner.panningModel = pa.panningModel;
		      }
		    }

		    return self;
		  };

		  /** Single Sound Methods **/
		  /***************************************************************************/

		  /**
		   * Add new properties to the core Sound init.
		   * @param  {Function} _super Core Sound init method.
		   * @return {Sound}
		   */
		  Sound.prototype.init = (function(_super) {
		    return function() {
		      var self = this;
		      var parent = self._parent;

		      // Setup user-defined default properties.
		      self._orientation = parent._orientation;
		      self._stereo = parent._stereo;
		      self._pos = parent._pos;
		      self._pannerAttr = parent._pannerAttr;

		      // Complete initilization with howler.js core Sound's init function.
		      _super.call(this);

		      // If a stereo or position was specified, set it up.
		      if (self._stereo) {
		        parent.stereo(self._stereo);
		      } else if (self._pos) {
		        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
		      }
		    };
		  })(Sound.prototype.init);

		  /**
		   * Override the Sound.reset method to clean up properties from the spatial plugin.
		   * @param  {Function} _super Sound reset method.
		   * @return {Sound}
		   */
		  Sound.prototype.reset = (function(_super) {
		    return function() {
		      var self = this;
		      var parent = self._parent;

		      // Reset all spatial plugin properties on this sound.
		      self._orientation = parent._orientation;
		      self._stereo = parent._stereo;
		      self._pos = parent._pos;
		      self._pannerAttr = parent._pannerAttr;

		      // If a stereo or position was specified, set it up.
		      if (self._stereo) {
		        parent.stereo(self._stereo);
		      } else if (self._pos) {
		        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
		      } else if (self._panner) {
		        // Disconnect the panner.
		        self._panner.disconnect(0);
		        self._panner = undefined;
		        parent._refreshBuffer(self);
		      }

		      // Complete resetting of the sound.
		      return _super.call(this);
		    };
		  })(Sound.prototype.reset);

		  /** Helper Methods **/
		  /***************************************************************************/

		  /**
		   * Create a new panner node and save it on the sound.
		   * @param  {Sound} sound Specific sound to setup panning on.
		   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
		   */
		  var setupPanner = function(sound, type) {
		    type = type || 'spatial';

		    // Create the new panner node.
		    if (type === 'spatial') {
		      sound._panner = Howler.ctx.createPanner();
		      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
		      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
		      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
		      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
		      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
		      sound._panner.refDistance = sound._pannerAttr.refDistance;
		      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
		      sound._panner.panningModel = sound._pannerAttr.panningModel;

		      if (typeof sound._panner.positionX !== 'undefined') {
		        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
		        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
		        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
		      } else {
		        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
		      }

		      if (typeof sound._panner.orientationX !== 'undefined') {
		        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
		        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
		        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
		      } else {
		        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
		      }
		    } else {
		      sound._panner = Howler.ctx.createStereoPanner();
		      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
		    }

		    sound._panner.connect(sound._node);

		    // Update the connections.
		    if (!sound._paused) {
		      sound._parent.pause(sound._id, true).play(sound._id, true);
		    }
		  };
		})(); 
	} (howler));
	return howler;
}

var howlerExports = requireHowler();

var cjs = {};

var Observable = {};

var Subscriber = {};

var isFunction = {};

var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction;
	hasRequiredIsFunction = 1;
	Object.defineProperty(isFunction, "__esModule", { value: true });
	isFunction.isFunction = void 0;
	function isFunction$1(value) {
	    return typeof value === 'function';
	}
	isFunction.isFunction = isFunction$1;
	
	return isFunction;
}

var Subscription = {};

var UnsubscriptionError = {};

var createErrorClass = {};

var hasRequiredCreateErrorClass;

function requireCreateErrorClass () {
	if (hasRequiredCreateErrorClass) return createErrorClass;
	hasRequiredCreateErrorClass = 1;
	Object.defineProperty(createErrorClass, "__esModule", { value: true });
	createErrorClass.createErrorClass = void 0;
	function createErrorClass$1(createImpl) {
	    var _super = function (instance) {
	        Error.call(instance);
	        instance.stack = new Error().stack;
	    };
	    var ctorFunc = createImpl(_super);
	    ctorFunc.prototype = Object.create(Error.prototype);
	    ctorFunc.prototype.constructor = ctorFunc;
	    return ctorFunc;
	}
	createErrorClass.createErrorClass = createErrorClass$1;
	
	return createErrorClass;
}

var hasRequiredUnsubscriptionError;

function requireUnsubscriptionError () {
	if (hasRequiredUnsubscriptionError) return UnsubscriptionError;
	hasRequiredUnsubscriptionError = 1;
	Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
	UnsubscriptionError.UnsubscriptionError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	UnsubscriptionError.UnsubscriptionError = createErrorClass_1.createErrorClass(function (_super) {
	    return function UnsubscriptionErrorImpl(errors) {
	        _super(this);
	        this.message = errors
	            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
	            : '';
	        this.name = 'UnsubscriptionError';
	        this.errors = errors;
	    };
	});
	
	return UnsubscriptionError;
}

var arrRemove = {};

var hasRequiredArrRemove;

function requireArrRemove () {
	if (hasRequiredArrRemove) return arrRemove;
	hasRequiredArrRemove = 1;
	Object.defineProperty(arrRemove, "__esModule", { value: true });
	arrRemove.arrRemove = void 0;
	function arrRemove$1(arr, item) {
	    if (arr) {
	        var index = arr.indexOf(item);
	        0 <= index && arr.splice(index, 1);
	    }
	}
	arrRemove.arrRemove = arrRemove$1;
	
	return arrRemove;
}

var hasRequiredSubscription;

function requireSubscription () {
	if (hasRequiredSubscription) return Subscription;
	hasRequiredSubscription = 1;
	var __values = (Subscription && Subscription.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read = (Subscription && Subscription.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (Subscription && Subscription.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(Subscription, "__esModule", { value: true });
	Subscription.isSubscription = Subscription.EMPTY_SUBSCRIPTION = Subscription.Subscription = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var UnsubscriptionError_1 = /*@__PURE__*/ requireUnsubscriptionError();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var Subscription$1 = (function () {
	    function Subscription(initialTeardown) {
	        this.initialTeardown = initialTeardown;
	        this.closed = false;
	        this._parentage = null;
	        this._finalizers = null;
	    }
	    Subscription.prototype.unsubscribe = function () {
	        var e_1, _a, e_2, _b;
	        var errors;
	        if (!this.closed) {
	            this.closed = true;
	            var _parentage = this._parentage;
	            if (_parentage) {
	                this._parentage = null;
	                if (Array.isArray(_parentage)) {
	                    try {
	                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
	                            var parent_1 = _parentage_1_1.value;
	                            parent_1.remove(this);
	                        }
	                    }
	                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                    finally {
	                        try {
	                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
	                        }
	                        finally { if (e_1) throw e_1.error; }
	                    }
	                }
	                else {
	                    _parentage.remove(this);
	                }
	            }
	            var initialFinalizer = this.initialTeardown;
	            if (isFunction_1.isFunction(initialFinalizer)) {
	                try {
	                    initialFinalizer();
	                }
	                catch (e) {
	                    errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
	                }
	            }
	            var _finalizers = this._finalizers;
	            if (_finalizers) {
	                this._finalizers = null;
	                try {
	                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
	                        var finalizer = _finalizers_1_1.value;
	                        try {
	                            execFinalizer(finalizer);
	                        }
	                        catch (err) {
	                            errors = errors !== null && errors !== void 0 ? errors : [];
	                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
	                            }
	                            else {
	                                errors.push(err);
	                            }
	                        }
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	            if (errors) {
	                throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	            }
	        }
	    };
	    Subscription.prototype.add = function (teardown) {
	        var _a;
	        if (teardown && teardown !== this) {
	            if (this.closed) {
	                execFinalizer(teardown);
	            }
	            else {
	                if (teardown instanceof Subscription) {
	                    if (teardown.closed || teardown._hasParent(this)) {
	                        return;
	                    }
	                    teardown._addParent(this);
	                }
	                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
	            }
	        }
	    };
	    Subscription.prototype._hasParent = function (parent) {
	        var _parentage = this._parentage;
	        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _parentage = this._parentage;
	        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
	    };
	    Subscription.prototype._removeParent = function (parent) {
	        var _parentage = this._parentage;
	        if (_parentage === parent) {
	            this._parentage = null;
	        }
	        else if (Array.isArray(_parentage)) {
	            arrRemove_1.arrRemove(_parentage, parent);
	        }
	    };
	    Subscription.prototype.remove = function (teardown) {
	        var _finalizers = this._finalizers;
	        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
	        if (teardown instanceof Subscription) {
	            teardown._removeParent(this);
	        }
	    };
	    Subscription.EMPTY = (function () {
	        var empty = new Subscription();
	        empty.closed = true;
	        return empty;
	    })();
	    return Subscription;
	}());
	Subscription.Subscription = Subscription$1;
	Subscription.EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
	function isSubscription(value) {
	    return (value instanceof Subscription$1 ||
	        (value && 'closed' in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe)));
	}
	Subscription.isSubscription = isSubscription;
	function execFinalizer(finalizer) {
	    if (isFunction_1.isFunction(finalizer)) {
	        finalizer();
	    }
	    else {
	        finalizer.unsubscribe();
	    }
	}
	
	return Subscription;
}

var config = {};

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;
	Object.defineProperty(config, "__esModule", { value: true });
	config.config = void 0;
	config.config = {
	    onUnhandledError: null,
	    onStoppedNotification: null,
	    Promise: undefined,
	    useDeprecatedSynchronousErrorHandling: false,
	    useDeprecatedNextContext: false,
	};
	
	return config;
}

var reportUnhandledError = {};

var timeoutProvider = {};

var hasRequiredTimeoutProvider;

function requireTimeoutProvider () {
	if (hasRequiredTimeoutProvider) return timeoutProvider;
	hasRequiredTimeoutProvider = 1;
	(function (exports) {
		var __read = (timeoutProvider && timeoutProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (timeoutProvider && timeoutProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.timeoutProvider = void 0;
		exports.timeoutProvider = {
		    setTimeout: function (handler, timeout) {
		        var args = [];
		        for (var _i = 2; _i < arguments.length; _i++) {
		            args[_i - 2] = arguments[_i];
		        }
		        var delegate = exports.timeoutProvider.delegate;
		        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
		            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
		        }
		        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
		    },
		    clearTimeout: function (handle) {
		        var delegate = exports.timeoutProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
		    },
		    delegate: undefined,
		};
		
	} (timeoutProvider));
	return timeoutProvider;
}

var hasRequiredReportUnhandledError;

function requireReportUnhandledError () {
	if (hasRequiredReportUnhandledError) return reportUnhandledError;
	hasRequiredReportUnhandledError = 1;
	Object.defineProperty(reportUnhandledError, "__esModule", { value: true });
	reportUnhandledError.reportUnhandledError = void 0;
	var config_1 = /*@__PURE__*/ requireConfig();
	var timeoutProvider_1 = /*@__PURE__*/ requireTimeoutProvider();
	function reportUnhandledError$1(err) {
	    timeoutProvider_1.timeoutProvider.setTimeout(function () {
	        var onUnhandledError = config_1.config.onUnhandledError;
	        if (onUnhandledError) {
	            onUnhandledError(err);
	        }
	        else {
	            throw err;
	        }
	    });
	}
	reportUnhandledError.reportUnhandledError = reportUnhandledError$1;
	
	return reportUnhandledError;
}

var noop = {};

var hasRequiredNoop;

function requireNoop () {
	if (hasRequiredNoop) return noop;
	hasRequiredNoop = 1;
	Object.defineProperty(noop, "__esModule", { value: true });
	noop.noop = void 0;
	function noop$1() { }
	noop.noop = noop$1;
	
	return noop;
}

var NotificationFactories = {};

var hasRequiredNotificationFactories;

function requireNotificationFactories () {
	if (hasRequiredNotificationFactories) return NotificationFactories;
	hasRequiredNotificationFactories = 1;
	Object.defineProperty(NotificationFactories, "__esModule", { value: true });
	NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
	NotificationFactories.COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
	function errorNotification(error) {
	    return createNotification('E', undefined, error);
	}
	NotificationFactories.errorNotification = errorNotification;
	function nextNotification(value) {
	    return createNotification('N', value, undefined);
	}
	NotificationFactories.nextNotification = nextNotification;
	function createNotification(kind, value, error) {
	    return {
	        kind: kind,
	        value: value,
	        error: error,
	    };
	}
	NotificationFactories.createNotification = createNotification;
	
	return NotificationFactories;
}

var errorContext = {};

var hasRequiredErrorContext;

function requireErrorContext () {
	if (hasRequiredErrorContext) return errorContext;
	hasRequiredErrorContext = 1;
	Object.defineProperty(errorContext, "__esModule", { value: true });
	errorContext.captureError = errorContext.errorContext = void 0;
	var config_1 = /*@__PURE__*/ requireConfig();
	var context = null;
	function errorContext$1(cb) {
	    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
	        var isRoot = !context;
	        if (isRoot) {
	            context = { errorThrown: false, error: null };
	        }
	        cb();
	        if (isRoot) {
	            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
	            context = null;
	            if (errorThrown) {
	                throw error;
	            }
	        }
	    }
	    else {
	        cb();
	    }
	}
	errorContext.errorContext = errorContext$1;
	function captureError(err) {
	    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
	        context.errorThrown = true;
	        context.error = err;
	    }
	}
	errorContext.captureError = captureError;
	
	return errorContext;
}

var hasRequiredSubscriber;

function requireSubscriber () {
	if (hasRequiredSubscriber) return Subscriber;
	hasRequiredSubscriber = 1;
	(function (exports) {
		var __extends = (Subscriber && Subscriber.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
		var isFunction_1 = /*@__PURE__*/ requireIsFunction();
		var Subscription_1 = /*@__PURE__*/ requireSubscription();
		var config_1 = /*@__PURE__*/ requireConfig();
		var reportUnhandledError_1 = /*@__PURE__*/ requireReportUnhandledError();
		var noop_1 = /*@__PURE__*/ requireNoop();
		var NotificationFactories_1 = /*@__PURE__*/ requireNotificationFactories();
		var timeoutProvider_1 = /*@__PURE__*/ requireTimeoutProvider();
		var errorContext_1 = /*@__PURE__*/ requireErrorContext();
		var Subscriber$1 = (function (_super) {
		    __extends(Subscriber, _super);
		    function Subscriber(destination) {
		        var _this = _super.call(this) || this;
		        _this.isStopped = false;
		        if (destination) {
		            _this.destination = destination;
		            if (Subscription_1.isSubscription(destination)) {
		                destination.add(_this);
		            }
		        }
		        else {
		            _this.destination = exports.EMPTY_OBSERVER;
		        }
		        return _this;
		    }
		    Subscriber.create = function (next, error, complete) {
		        return new SafeSubscriber(next, error, complete);
		    };
		    Subscriber.prototype.next = function (value) {
		        if (this.isStopped) {
		            handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
		        }
		        else {
		            this._next(value);
		        }
		    };
		    Subscriber.prototype.error = function (err) {
		        if (this.isStopped) {
		            handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
		        }
		        else {
		            this.isStopped = true;
		            this._error(err);
		        }
		    };
		    Subscriber.prototype.complete = function () {
		        if (this.isStopped) {
		            handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
		        }
		        else {
		            this.isStopped = true;
		            this._complete();
		        }
		    };
		    Subscriber.prototype.unsubscribe = function () {
		        if (!this.closed) {
		            this.isStopped = true;
		            _super.prototype.unsubscribe.call(this);
		            this.destination = null;
		        }
		    };
		    Subscriber.prototype._next = function (value) {
		        this.destination.next(value);
		    };
		    Subscriber.prototype._error = function (err) {
		        try {
		            this.destination.error(err);
		        }
		        finally {
		            this.unsubscribe();
		        }
		    };
		    Subscriber.prototype._complete = function () {
		        try {
		            this.destination.complete();
		        }
		        finally {
		            this.unsubscribe();
		        }
		    };
		    return Subscriber;
		}(Subscription_1.Subscription));
		exports.Subscriber = Subscriber$1;
		var _bind = Function.prototype.bind;
		function bind(fn, thisArg) {
		    return _bind.call(fn, thisArg);
		}
		var ConsumerObserver = (function () {
		    function ConsumerObserver(partialObserver) {
		        this.partialObserver = partialObserver;
		    }
		    ConsumerObserver.prototype.next = function (value) {
		        var partialObserver = this.partialObserver;
		        if (partialObserver.next) {
		            try {
		                partialObserver.next(value);
		            }
		            catch (error) {
		                handleUnhandledError(error);
		            }
		        }
		    };
		    ConsumerObserver.prototype.error = function (err) {
		        var partialObserver = this.partialObserver;
		        if (partialObserver.error) {
		            try {
		                partialObserver.error(err);
		            }
		            catch (error) {
		                handleUnhandledError(error);
		            }
		        }
		        else {
		            handleUnhandledError(err);
		        }
		    };
		    ConsumerObserver.prototype.complete = function () {
		        var partialObserver = this.partialObserver;
		        if (partialObserver.complete) {
		            try {
		                partialObserver.complete();
		            }
		            catch (error) {
		                handleUnhandledError(error);
		            }
		        }
		    };
		    return ConsumerObserver;
		}());
		var SafeSubscriber = (function (_super) {
		    __extends(SafeSubscriber, _super);
		    function SafeSubscriber(observerOrNext, error, complete) {
		        var _this = _super.call(this) || this;
		        var partialObserver;
		        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
		            partialObserver = {
		                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
		                error: error !== null && error !== void 0 ? error : undefined,
		                complete: complete !== null && complete !== void 0 ? complete : undefined,
		            };
		        }
		        else {
		            var context_1;
		            if (_this && config_1.config.useDeprecatedNextContext) {
		                context_1 = Object.create(observerOrNext);
		                context_1.unsubscribe = function () { return _this.unsubscribe(); };
		                partialObserver = {
		                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
		                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
		                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
		                };
		            }
		            else {
		                partialObserver = observerOrNext;
		            }
		        }
		        _this.destination = new ConsumerObserver(partialObserver);
		        return _this;
		    }
		    return SafeSubscriber;
		}(Subscriber$1));
		exports.SafeSubscriber = SafeSubscriber;
		function handleUnhandledError(error) {
		    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
		        errorContext_1.captureError(error);
		    }
		    else {
		        reportUnhandledError_1.reportUnhandledError(error);
		    }
		}
		function defaultErrorHandler(err) {
		    throw err;
		}
		function handleStoppedNotification(notification, subscriber) {
		    var onStoppedNotification = config_1.config.onStoppedNotification;
		    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
		}
		exports.EMPTY_OBSERVER = {
		    closed: true,
		    next: noop_1.noop,
		    error: defaultErrorHandler,
		    complete: noop_1.noop,
		};
		
	} (Subscriber));
	return Subscriber;
}

var observable = {};

var hasRequiredObservable$1;

function requireObservable$1 () {
	if (hasRequiredObservable$1) return observable;
	hasRequiredObservable$1 = 1;
	Object.defineProperty(observable, "__esModule", { value: true });
	observable.observable = void 0;
	observable.observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();
	
	return observable;
}

var pipe = {};

var identity = {};

var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity;
	hasRequiredIdentity = 1;
	Object.defineProperty(identity, "__esModule", { value: true });
	identity.identity = void 0;
	function identity$1(x) {
	    return x;
	}
	identity.identity = identity$1;
	
	return identity;
}

var hasRequiredPipe;

function requirePipe () {
	if (hasRequiredPipe) return pipe;
	hasRequiredPipe = 1;
	Object.defineProperty(pipe, "__esModule", { value: true });
	pipe.pipeFromArray = pipe.pipe = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function pipe$1() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i] = arguments[_i];
	    }
	    return pipeFromArray(fns);
	}
	pipe.pipe = pipe$1;
	function pipeFromArray(fns) {
	    if (fns.length === 0) {
	        return identity_1.identity;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}
	pipe.pipeFromArray = pipeFromArray;
	
	return pipe;
}

var hasRequiredObservable;

function requireObservable () {
	if (hasRequiredObservable) return Observable;
	hasRequiredObservable = 1;
	Object.defineProperty(Observable, "__esModule", { value: true });
	Observable.Observable = void 0;
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var observable_1 = /*@__PURE__*/ requireObservable$1();
	var pipe_1 = /*@__PURE__*/ requirePipe();
	var config_1 = /*@__PURE__*/ requireConfig();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var errorContext_1 = /*@__PURE__*/ requireErrorContext();
	var Observable$1 = (function () {
	    function Observable(subscribe) {
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var _this = this;
	        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
	        errorContext_1.errorContext(function () {
	            var _a = _this, operator = _a.operator, source = _a.source;
	            subscriber.add(operator
	                ?
	                    operator.call(subscriber, source)
	                : source
	                    ?
	                        _this._subscribe(subscriber)
	                    :
	                        _this._trySubscribe(subscriber));
	        });
	        return subscriber;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.error(err);
	        }
	    };
	    Observable.prototype.forEach = function (next, promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var subscriber = new Subscriber_1.SafeSubscriber({
	                next: function (value) {
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscriber.unsubscribe();
	                    }
	                },
	                error: reject,
	                complete: resolve,
	            });
	            _this.subscribe(subscriber);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        var _a;
	        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
	    };
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i] = arguments[_i];
	        }
	        return pipe_1.pipeFromArray(operations)(this);
	    };
	    Observable.prototype.toPromise = function (promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	Observable.Observable = Observable$1;
	function getPromiseCtor(promiseCtor) {
	    var _a;
	    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
	}
	function isObserver(value) {
	    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
	}
	function isSubscriber(value) {
	    return (value && value instanceof Subscriber_1.Subscriber) || (isObserver(value) && Subscription_1.isSubscription(value));
	}
	
	return Observable;
}

var ConnectableObservable = {};

var refCount = {};

var lift = {};

var hasRequiredLift;

function requireLift () {
	if (hasRequiredLift) return lift;
	hasRequiredLift = 1;
	Object.defineProperty(lift, "__esModule", { value: true });
	lift.operate = lift.hasLift = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function hasLift(source) {
	    return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
	}
	lift.hasLift = hasLift;
	function operate(init) {
	    return function (source) {
	        if (hasLift(source)) {
	            return source.lift(function (liftedSource) {
	                try {
	                    return init(liftedSource, this);
	                }
	                catch (err) {
	                    this.error(err);
	                }
	            });
	        }
	        throw new TypeError('Unable to lift unknown Observable type');
	    };
	}
	lift.operate = operate;
	
	return lift;
}

var OperatorSubscriber = {};

var hasRequiredOperatorSubscriber;

function requireOperatorSubscriber () {
	if (hasRequiredOperatorSubscriber) return OperatorSubscriber;
	hasRequiredOperatorSubscriber = 1;
	var __extends = (OperatorSubscriber && OperatorSubscriber.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(OperatorSubscriber, "__esModule", { value: true });
	OperatorSubscriber.OperatorSubscriber = OperatorSubscriber.createOperatorSubscriber = void 0;
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
	    return new OperatorSubscriber$1(destination, onNext, onComplete, onError, onFinalize);
	}
	OperatorSubscriber.createOperatorSubscriber = createOperatorSubscriber;
	var OperatorSubscriber$1 = (function (_super) {
	    __extends(OperatorSubscriber, _super);
	    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
	        var _this = _super.call(this, destination) || this;
	        _this.onFinalize = onFinalize;
	        _this.shouldUnsubscribe = shouldUnsubscribe;
	        _this._next = onNext
	            ? function (value) {
	                try {
	                    onNext(value);
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	            }
	            : _super.prototype._next;
	        _this._error = onError
	            ? function (err) {
	                try {
	                    onError(err);
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	                finally {
	                    this.unsubscribe();
	                }
	            }
	            : _super.prototype._error;
	        _this._complete = onComplete
	            ? function () {
	                try {
	                    onComplete();
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	                finally {
	                    this.unsubscribe();
	                }
	            }
	            : _super.prototype._complete;
	        return _this;
	    }
	    OperatorSubscriber.prototype.unsubscribe = function () {
	        var _a;
	        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
	            var closed_1 = this.closed;
	            _super.prototype.unsubscribe.call(this);
	            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
	        }
	    };
	    return OperatorSubscriber;
	}(Subscriber_1.Subscriber));
	OperatorSubscriber.OperatorSubscriber = OperatorSubscriber$1;
	
	return OperatorSubscriber;
}

var hasRequiredRefCount;

function requireRefCount () {
	if (hasRequiredRefCount) return refCount;
	hasRequiredRefCount = 1;
	Object.defineProperty(refCount, "__esModule", { value: true });
	refCount.refCount = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function refCount$1() {
	    return lift_1.operate(function (source, subscriber) {
	        var connection = null;
	        source._refCount++;
	        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
	            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
	                connection = null;
	                return;
	            }
	            var sharedConnection = source._connection;
	            var conn = connection;
	            connection = null;
	            if (sharedConnection && (!conn || sharedConnection === conn)) {
	                sharedConnection.unsubscribe();
	            }
	            subscriber.unsubscribe();
	        });
	        source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            connection = source.connect();
	        }
	    });
	}
	refCount.refCount = refCount$1;
	
	return refCount;
}

var hasRequiredConnectableObservable;

function requireConnectableObservable () {
	if (hasRequiredConnectableObservable) return ConnectableObservable;
	hasRequiredConnectableObservable = 1;
	var __extends = (ConnectableObservable && ConnectableObservable.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ConnectableObservable, "__esModule", { value: true });
	ConnectableObservable.ConnectableObservable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var refCount_1 = /*@__PURE__*/ requireRefCount();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var lift_1 = /*@__PURE__*/ requireLift();
	var ConnectableObservable$1 = (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        var _this = _super.call(this) || this;
	        _this.source = source;
	        _this.subjectFactory = subjectFactory;
	        _this._subject = null;
	        _this._refCount = 0;
	        _this._connection = null;
	        if (lift_1.hasLift(source)) {
	            _this.lift = source.lift;
	        }
	        return _this;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype._teardown = function () {
	        this._refCount = 0;
	        var _connection = this._connection;
	        this._subject = this._connection = null;
	        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var _this = this;
	        var connection = this._connection;
	        if (!connection) {
	            connection = this._connection = new Subscription_1.Subscription();
	            var subject_1 = this.getSubject();
	            connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function () {
	                _this._teardown();
	                subject_1.complete();
	            }, function (err) {
	                _this._teardown();
	                subject_1.error(err);
	            }, function () { return _this._teardown(); })));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1.Subscription.EMPTY;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return refCount_1.refCount()(this);
	    };
	    return ConnectableObservable;
	}(Observable_1.Observable));
	ConnectableObservable.ConnectableObservable = ConnectableObservable$1;
	
	return ConnectableObservable;
}

var animationFrames = {};

var performanceTimestampProvider = {};

var hasRequiredPerformanceTimestampProvider;

function requirePerformanceTimestampProvider () {
	if (hasRequiredPerformanceTimestampProvider) return performanceTimestampProvider;
	hasRequiredPerformanceTimestampProvider = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.performanceTimestampProvider = void 0;
		exports.performanceTimestampProvider = {
		    now: function () {
		        return (exports.performanceTimestampProvider.delegate || performance).now();
		    },
		    delegate: undefined,
		};
		
	} (performanceTimestampProvider));
	return performanceTimestampProvider;
}

var animationFrameProvider = {};

var hasRequiredAnimationFrameProvider;

function requireAnimationFrameProvider () {
	if (hasRequiredAnimationFrameProvider) return animationFrameProvider;
	hasRequiredAnimationFrameProvider = 1;
	(function (exports) {
		var __read = (animationFrameProvider && animationFrameProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (animationFrameProvider && animationFrameProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.animationFrameProvider = void 0;
		var Subscription_1 = /*@__PURE__*/ requireSubscription();
		exports.animationFrameProvider = {
		    schedule: function (callback) {
		        var request = requestAnimationFrame;
		        var cancel = cancelAnimationFrame;
		        var delegate = exports.animationFrameProvider.delegate;
		        if (delegate) {
		            request = delegate.requestAnimationFrame;
		            cancel = delegate.cancelAnimationFrame;
		        }
		        var handle = request(function (timestamp) {
		            cancel = undefined;
		            callback(timestamp);
		        });
		        return new Subscription_1.Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });
		    },
		    requestAnimationFrame: function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var delegate = exports.animationFrameProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
		    },
		    cancelAnimationFrame: function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var delegate = exports.animationFrameProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
		    },
		    delegate: undefined,
		};
		
	} (animationFrameProvider));
	return animationFrameProvider;
}

var hasRequiredAnimationFrames;

function requireAnimationFrames () {
	if (hasRequiredAnimationFrames) return animationFrames;
	hasRequiredAnimationFrames = 1;
	Object.defineProperty(animationFrames, "__esModule", { value: true });
	animationFrames.animationFrames = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var performanceTimestampProvider_1 = /*@__PURE__*/ requirePerformanceTimestampProvider();
	var animationFrameProvider_1 = /*@__PURE__*/ requireAnimationFrameProvider();
	function animationFrames$1(timestampProvider) {
	    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
	}
	animationFrames.animationFrames = animationFrames$1;
	function animationFramesFactory(timestampProvider) {
	    return new Observable_1.Observable(function (subscriber) {
	        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
	        var start = provider.now();
	        var id = 0;
	        var run = function () {
	            if (!subscriber.closed) {
	                id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function (timestamp) {
	                    id = 0;
	                    var now = provider.now();
	                    subscriber.next({
	                        timestamp: timestampProvider ? now : timestamp,
	                        elapsed: now - start,
	                    });
	                    run();
	                });
	            }
	        };
	        run();
	        return function () {
	            if (id) {
	                animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
	            }
	        };
	    });
	}
	var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
	
	return animationFrames;
}

var Subject = {};

var ObjectUnsubscribedError = {};

var hasRequiredObjectUnsubscribedError;

function requireObjectUnsubscribedError () {
	if (hasRequiredObjectUnsubscribedError) return ObjectUnsubscribedError;
	hasRequiredObjectUnsubscribedError = 1;
	Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
	ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function (_super) {
	    return function ObjectUnsubscribedErrorImpl() {
	        _super(this);
	        this.name = 'ObjectUnsubscribedError';
	        this.message = 'object unsubscribed';
	    };
	});
	
	return ObjectUnsubscribedError;
}

var hasRequiredSubject;

function requireSubject () {
	if (hasRequiredSubject) return Subject;
	hasRequiredSubject = 1;
	var __extends = (Subject && Subject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values = (Subject && Subject.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Subject, "__esModule", { value: true });
	Subject.AnonymousSubject = Subject.Subject = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var ObjectUnsubscribedError_1 = /*@__PURE__*/ requireObjectUnsubscribedError();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var errorContext_1 = /*@__PURE__*/ requireErrorContext();
	var Subject$1 = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        var _this = _super.call(this) || this;
	        _this.closed = false;
	        _this.currentObservers = null;
	        _this.observers = [];
	        _this.isStopped = false;
	        _this.hasError = false;
	        _this.thrownError = null;
	        return _this;
	    }
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype._throwIfClosed = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	    };
	    Subject.prototype.next = function (value) {
	        var _this = this;
	        errorContext_1.errorContext(function () {
	            var e_1, _a;
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                if (!_this.currentObservers) {
	                    _this.currentObservers = Array.from(_this.observers);
	                }
	                try {
	                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
	                        var observer = _c.value;
	                        observer.next(value);
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	            }
	        });
	    };
	    Subject.prototype.error = function (err) {
	        var _this = this;
	        errorContext_1.errorContext(function () {
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                _this.hasError = _this.isStopped = true;
	                _this.thrownError = err;
	                var observers = _this.observers;
	                while (observers.length) {
	                    observers.shift().error(err);
	                }
	            }
	        });
	    };
	    Subject.prototype.complete = function () {
	        var _this = this;
	        errorContext_1.errorContext(function () {
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                _this.isStopped = true;
	                var observers = _this.observers;
	                while (observers.length) {
	                    observers.shift().complete();
	                }
	            }
	        });
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = this.closed = true;
	        this.observers = this.currentObservers = null;
	    };
	    Object.defineProperty(Subject.prototype, "observed", {
	        get: function () {
	            var _a;
	            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Subject.prototype._trySubscribe = function (subscriber) {
	        this._throwIfClosed();
	        return _super.prototype._trySubscribe.call(this, subscriber);
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        this._throwIfClosed();
	        this._checkFinalizedStatuses(subscriber);
	        return this._innerSubscribe(subscriber);
	    };
	    Subject.prototype._innerSubscribe = function (subscriber) {
	        var _this = this;
	        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
	        if (hasError || isStopped) {
	            return Subscription_1.EMPTY_SUBSCRIPTION;
	        }
	        this.currentObservers = null;
	        observers.push(subscriber);
	        return new Subscription_1.Subscription(function () {
	            _this.currentObservers = null;
	            arrRemove_1.arrRemove(observers, subscriber);
	        });
	    };
	    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
	        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
	        if (hasError) {
	            subscriber.error(thrownError);
	        }
	        else if (isStopped) {
	            subscriber.complete();
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	Subject.Subject = Subject$1;
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        var _this = _super.call(this) || this;
	        _this.destination = destination;
	        _this.source = source;
	        return _this;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var _a, _b;
	        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
	    };
	    return AnonymousSubject;
	}(Subject$1));
	Subject.AnonymousSubject = AnonymousSubject;
	
	return Subject;
}

var BehaviorSubject = {};

var hasRequiredBehaviorSubject;

function requireBehaviorSubject () {
	if (hasRequiredBehaviorSubject) return BehaviorSubject;
	hasRequiredBehaviorSubject = 1;
	var __extends = (BehaviorSubject && BehaviorSubject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(BehaviorSubject, "__esModule", { value: true });
	BehaviorSubject.BehaviorSubject = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var BehaviorSubject$1 = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        var _this = _super.call(this) || this;
	        _this._value = _value;
	        return _this;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: false,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        !subscription.closed && subscriber.next(this._value);
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
	        if (hasError) {
	            throw thrownError;
	        }
	        this._throwIfClosed();
	        return _value;
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, (this._value = value));
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	BehaviorSubject.BehaviorSubject = BehaviorSubject$1;
	
	return BehaviorSubject;
}

var ReplaySubject = {};

var dateTimestampProvider = {};

var hasRequiredDateTimestampProvider;

function requireDateTimestampProvider () {
	if (hasRequiredDateTimestampProvider) return dateTimestampProvider;
	hasRequiredDateTimestampProvider = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.dateTimestampProvider = void 0;
		exports.dateTimestampProvider = {
		    now: function () {
		        return (exports.dateTimestampProvider.delegate || Date).now();
		    },
		    delegate: undefined,
		};
		
	} (dateTimestampProvider));
	return dateTimestampProvider;
}

var hasRequiredReplaySubject;

function requireReplaySubject () {
	if (hasRequiredReplaySubject) return ReplaySubject;
	hasRequiredReplaySubject = 1;
	var __extends = (ReplaySubject && ReplaySubject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ReplaySubject, "__esModule", { value: true });
	ReplaySubject.ReplaySubject = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var dateTimestampProvider_1 = /*@__PURE__*/ requireDateTimestampProvider();
	var ReplaySubject$1 = (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
	        if (_bufferSize === void 0) { _bufferSize = Infinity; }
	        if (_windowTime === void 0) { _windowTime = Infinity; }
	        if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider_1.dateTimestampProvider; }
	        var _this = _super.call(this) || this;
	        _this._bufferSize = _bufferSize;
	        _this._windowTime = _windowTime;
	        _this._timestampProvider = _timestampProvider;
	        _this._buffer = [];
	        _this._infiniteTimeWindow = true;
	        _this._infiniteTimeWindow = _windowTime === Infinity;
	        _this._bufferSize = Math.max(1, _bufferSize);
	        _this._windowTime = Math.max(1, _windowTime);
	        return _this;
	    }
	    ReplaySubject.prototype.next = function (value) {
	        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
	        if (!isStopped) {
	            _buffer.push(value);
	            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
	        }
	        this._trimBuffer();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        this._throwIfClosed();
	        this._trimBuffer();
	        var subscription = this._innerSubscribe(subscriber);
	        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
	        var copy = _buffer.slice();
	        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
	            subscriber.next(copy[i]);
	        }
	        this._checkFinalizedStatuses(subscriber);
	        return subscription;
	    };
	    ReplaySubject.prototype._trimBuffer = function () {
	        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
	        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
	        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
	        if (!_infiniteTimeWindow) {
	            var now = _timestampProvider.now();
	            var last = 0;
	            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
	                last = i;
	            }
	            last && _buffer.splice(0, last + 1);
	        }
	    };
	    return ReplaySubject;
	}(Subject_1.Subject));
	ReplaySubject.ReplaySubject = ReplaySubject$1;
	
	return ReplaySubject;
}

var AsyncSubject = {};

var hasRequiredAsyncSubject;

function requireAsyncSubject () {
	if (hasRequiredAsyncSubject) return AsyncSubject;
	hasRequiredAsyncSubject = 1;
	var __extends = (AsyncSubject && AsyncSubject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsyncSubject, "__esModule", { value: true });
	AsyncSubject.AsyncSubject = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var AsyncSubject$1 = (function (_super) {
	    __extends(AsyncSubject, _super);
	    function AsyncSubject() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._value = null;
	        _this._hasValue = false;
	        _this._isComplete = false;
	        return _this;
	    }
	    AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
	        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
	        if (hasError) {
	            subscriber.error(thrownError);
	        }
	        else if (isStopped || _isComplete) {
	            _hasValue && subscriber.next(_value);
	            subscriber.complete();
	        }
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._value = value;
	            this._hasValue = true;
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
	        if (!_isComplete) {
	            this._isComplete = true;
	            _hasValue && _super.prototype.next.call(this, _value);
	            _super.prototype.complete.call(this);
	        }
	    };
	    return AsyncSubject;
	}(Subject_1.Subject));
	AsyncSubject.AsyncSubject = AsyncSubject$1;
	
	return AsyncSubject;
}

var asap = {};

var AsapAction = {};

var AsyncAction = {};

var Action = {};

var hasRequiredAction;

function requireAction () {
	if (hasRequiredAction) return Action;
	hasRequiredAction = 1;
	var __extends = (Action && Action.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(Action, "__esModule", { value: true });
	Action.Action = void 0;
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var Action$1 = (function (_super) {
	    __extends(Action, _super);
	    function Action(scheduler, work) {
	        return _super.call(this) || this;
	    }
	    Action.prototype.schedule = function (state, delay) {
	        return this;
	    };
	    return Action;
	}(Subscription_1.Subscription));
	Action.Action = Action$1;
	
	return Action;
}

var intervalProvider = {};

var hasRequiredIntervalProvider;

function requireIntervalProvider () {
	if (hasRequiredIntervalProvider) return intervalProvider;
	hasRequiredIntervalProvider = 1;
	(function (exports) {
		var __read = (intervalProvider && intervalProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (intervalProvider && intervalProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.intervalProvider = void 0;
		exports.intervalProvider = {
		    setInterval: function (handler, timeout) {
		        var args = [];
		        for (var _i = 2; _i < arguments.length; _i++) {
		            args[_i - 2] = arguments[_i];
		        }
		        var delegate = exports.intervalProvider.delegate;
		        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
		            return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
		        }
		        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
		    },
		    clearInterval: function (handle) {
		        var delegate = exports.intervalProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
		    },
		    delegate: undefined,
		};
		
	} (intervalProvider));
	return intervalProvider;
}

var hasRequiredAsyncAction;

function requireAsyncAction () {
	if (hasRequiredAsyncAction) return AsyncAction;
	hasRequiredAsyncAction = 1;
	var __extends = (AsyncAction && AsyncAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsyncAction, "__esModule", { value: true });
	AsyncAction.AsyncAction = void 0;
	var Action_1 = /*@__PURE__*/ requireAction();
	var intervalProvider_1 = /*@__PURE__*/ requireIntervalProvider();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var AsyncAction$1 = (function (_super) {
	    __extends(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.pending = false;
	        return _this;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        var _a;
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        this.state = state;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.pending = true;
	        this.delay = delay;
	        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay != null && this.delay === delay && this.pending === false) {
	            return id;
	        }
	        if (id != null) {
	            intervalProvider_1.intervalProvider.clearInterval(id);
	        }
	        return undefined;
	    };
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, _delay) {
	        var errored = false;
	        var errorValue;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = e ? e : new Error('Scheduled action threw falsy error');
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            var _a = this, id = _a.id, scheduler = _a.scheduler;
	            var actions = scheduler.actions;
	            this.work = this.state = this.scheduler = null;
	            this.pending = false;
	            arrRemove_1.arrRemove(actions, this);
	            if (id != null) {
	                this.id = this.recycleAsyncId(scheduler, id, null);
	            }
	            this.delay = null;
	            _super.prototype.unsubscribe.call(this);
	        }
	    };
	    return AsyncAction;
	}(Action_1.Action));
	AsyncAction.AsyncAction = AsyncAction$1;
	
	return AsyncAction;
}

var immediateProvider = {};

var Immediate = {};

var hasRequiredImmediate;

function requireImmediate () {
	if (hasRequiredImmediate) return Immediate;
	hasRequiredImmediate = 1;
	Object.defineProperty(Immediate, "__esModule", { value: true });
	Immediate.TestTools = Immediate.Immediate = void 0;
	var nextHandle = 1;
	var resolved;
	var activeHandles = {};
	function findAndClearHandle(handle) {
	    if (handle in activeHandles) {
	        delete activeHandles[handle];
	        return true;
	    }
	    return false;
	}
	Immediate.Immediate = {
	    setImmediate: function (cb) {
	        var handle = nextHandle++;
	        activeHandles[handle] = true;
	        if (!resolved) {
	            resolved = Promise.resolve();
	        }
	        resolved.then(function () { return findAndClearHandle(handle) && cb(); });
	        return handle;
	    },
	    clearImmediate: function (handle) {
	        findAndClearHandle(handle);
	    },
	};
	Immediate.TestTools = {
	    pending: function () {
	        return Object.keys(activeHandles).length;
	    }
	};
	
	return Immediate;
}

var hasRequiredImmediateProvider;

function requireImmediateProvider () {
	if (hasRequiredImmediateProvider) return immediateProvider;
	hasRequiredImmediateProvider = 1;
	(function (exports) {
		var __read = (immediateProvider && immediateProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (immediateProvider && immediateProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.immediateProvider = void 0;
		var Immediate_1 = /*@__PURE__*/ requireImmediate();
		var setImmediate = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
		exports.immediateProvider = {
		    setImmediate: function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var delegate = exports.immediateProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
		    },
		    clearImmediate: function (handle) {
		        var delegate = exports.immediateProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
		    },
		    delegate: undefined,
		};
		
	} (immediateProvider));
	return immediateProvider;
}

var hasRequiredAsapAction;

function requireAsapAction () {
	if (hasRequiredAsapAction) return AsapAction;
	hasRequiredAsapAction = 1;
	var __extends = (AsapAction && AsapAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsapAction, "__esModule", { value: true });
	AsapAction.AsapAction = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var immediateProvider_1 = /*@__PURE__*/ requireImmediateProvider();
	var AsapAction$1 = (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        var _a;
	        if (delay === void 0) { delay = 0; }
	        if (delay != null ? delay > 0 : this.delay > 0) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        var actions = scheduler.actions;
	        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
	            immediateProvider_1.immediateProvider.clearImmediate(id);
	            if (scheduler._scheduled === id) {
	                scheduler._scheduled = undefined;
	            }
	        }
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction_1.AsyncAction));
	AsapAction.AsapAction = AsapAction$1;
	
	return AsapAction;
}

var AsapScheduler = {};

var AsyncScheduler = {};

var Scheduler = {};

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return Scheduler;
	hasRequiredScheduler = 1;
	Object.defineProperty(Scheduler, "__esModule", { value: true });
	Scheduler.Scheduler = void 0;
	var dateTimestampProvider_1 = /*@__PURE__*/ requireDateTimestampProvider();
	var Scheduler$1 = (function () {
	    function Scheduler(schedulerActionCtor, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.schedulerActionCtor = schedulerActionCtor;
	        this.now = now;
	    }
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.schedulerActionCtor(this, work).schedule(state, delay);
	    };
	    Scheduler.now = dateTimestampProvider_1.dateTimestampProvider.now;
	    return Scheduler;
	}());
	Scheduler.Scheduler = Scheduler$1;
	
	return Scheduler;
}

var hasRequiredAsyncScheduler;

function requireAsyncScheduler () {
	if (hasRequiredAsyncScheduler) return AsyncScheduler;
	hasRequiredAsyncScheduler = 1;
	var __extends = (AsyncScheduler && AsyncScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsyncScheduler, "__esModule", { value: true });
	AsyncScheduler.AsyncScheduler = void 0;
	var Scheduler_1 = /*@__PURE__*/ requireScheduler();
	var AsyncScheduler$1 = (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
	        var _this = _super.call(this, SchedulerAction, now) || this;
	        _this.actions = [];
	        _this._active = false;
	        return _this;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this._active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this._active = true;
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions.shift()));
	        this._active = false;
	        if (error) {
	            while ((action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler_1.Scheduler));
	AsyncScheduler.AsyncScheduler = AsyncScheduler$1;
	
	return AsyncScheduler;
}

var hasRequiredAsapScheduler;

function requireAsapScheduler () {
	if (hasRequiredAsapScheduler) return AsapScheduler;
	hasRequiredAsapScheduler = 1;
	var __extends = (AsapScheduler && AsapScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsapScheduler, "__esModule", { value: true });
	AsapScheduler.AsapScheduler = void 0;
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var AsapScheduler$1 = (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this._active = true;
	        var flushId = this._scheduled;
	        this._scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        action = action || actions.shift();
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions[0]) && action.id === flushId && actions.shift());
	        this._active = false;
	        if (error) {
	            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	AsapScheduler.AsapScheduler = AsapScheduler$1;
	
	return AsapScheduler;
}

var hasRequiredAsap;

function requireAsap () {
	if (hasRequiredAsap) return asap;
	hasRequiredAsap = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.asap = exports.asapScheduler = void 0;
		var AsapAction_1 = /*@__PURE__*/ requireAsapAction();
		var AsapScheduler_1 = /*@__PURE__*/ requireAsapScheduler();
		exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
		exports.asap = exports.asapScheduler;
		
	} (asap));
	return asap;
}

var async = {};

var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.async = exports.asyncScheduler = void 0;
		var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
		var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
		exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
		exports.async = exports.asyncScheduler;
		
	} (async));
	return async;
}

var queue = {};

var QueueAction = {};

var hasRequiredQueueAction;

function requireQueueAction () {
	if (hasRequiredQueueAction) return QueueAction;
	hasRequiredQueueAction = 1;
	var __extends = (QueueAction && QueueAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(QueueAction, "__esModule", { value: true });
	QueueAction.QueueAction = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var QueueAction$1 = (function (_super) {
	    __extends(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.flush(this);
	        return 0;
	    };
	    return QueueAction;
	}(AsyncAction_1.AsyncAction));
	QueueAction.QueueAction = QueueAction$1;
	
	return QueueAction;
}

var QueueScheduler = {};

var hasRequiredQueueScheduler;

function requireQueueScheduler () {
	if (hasRequiredQueueScheduler) return QueueScheduler;
	hasRequiredQueueScheduler = 1;
	var __extends = (QueueScheduler && QueueScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(QueueScheduler, "__esModule", { value: true });
	QueueScheduler.QueueScheduler = void 0;
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var QueueScheduler$1 = (function (_super) {
	    __extends(QueueScheduler, _super);
	    function QueueScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return QueueScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	QueueScheduler.QueueScheduler = QueueScheduler$1;
	
	return QueueScheduler;
}

var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue;
	hasRequiredQueue = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.queue = exports.queueScheduler = void 0;
		var QueueAction_1 = /*@__PURE__*/ requireQueueAction();
		var QueueScheduler_1 = /*@__PURE__*/ requireQueueScheduler();
		exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
		exports.queue = exports.queueScheduler;
		
	} (queue));
	return queue;
}

var animationFrame = {};

var AnimationFrameAction = {};

var hasRequiredAnimationFrameAction;

function requireAnimationFrameAction () {
	if (hasRequiredAnimationFrameAction) return AnimationFrameAction;
	hasRequiredAnimationFrameAction = 1;
	var __extends = (AnimationFrameAction && AnimationFrameAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AnimationFrameAction, "__esModule", { value: true });
	AnimationFrameAction.AnimationFrameAction = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var animationFrameProvider_1 = /*@__PURE__*/ requireAnimationFrameProvider();
	var AnimationFrameAction$1 = (function (_super) {
	    __extends(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        var _a;
	        if (delay === void 0) { delay = 0; }
	        if (delay != null ? delay > 0 : this.delay > 0) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        var actions = scheduler.actions;
	        if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
	            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
	            scheduler._scheduled = undefined;
	        }
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction_1.AsyncAction));
	AnimationFrameAction.AnimationFrameAction = AnimationFrameAction$1;
	
	return AnimationFrameAction;
}

var AnimationFrameScheduler = {};

var hasRequiredAnimationFrameScheduler;

function requireAnimationFrameScheduler () {
	if (hasRequiredAnimationFrameScheduler) return AnimationFrameScheduler;
	hasRequiredAnimationFrameScheduler = 1;
	var __extends = (AnimationFrameScheduler && AnimationFrameScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AnimationFrameScheduler, "__esModule", { value: true });
	AnimationFrameScheduler.AnimationFrameScheduler = void 0;
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var AnimationFrameScheduler$1 = (function (_super) {
	    __extends(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this._active = true;
	        var flushId;
	        if (action) {
	            flushId = action.id;
	        }
	        else {
	            flushId = this._scheduled;
	            this._scheduled = undefined;
	        }
	        var actions = this.actions;
	        var error;
	        action = action || actions.shift();
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions[0]) && action.id === flushId && actions.shift());
	        this._active = false;
	        if (error) {
	            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	AnimationFrameScheduler.AnimationFrameScheduler = AnimationFrameScheduler$1;
	
	return AnimationFrameScheduler;
}

var hasRequiredAnimationFrame;

function requireAnimationFrame () {
	if (hasRequiredAnimationFrame) return animationFrame;
	hasRequiredAnimationFrame = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.animationFrame = exports.animationFrameScheduler = void 0;
		var AnimationFrameAction_1 = /*@__PURE__*/ requireAnimationFrameAction();
		var AnimationFrameScheduler_1 = /*@__PURE__*/ requireAnimationFrameScheduler();
		exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
		exports.animationFrame = exports.animationFrameScheduler;
		
	} (animationFrame));
	return animationFrame;
}

var VirtualTimeScheduler = {};

var hasRequiredVirtualTimeScheduler;

function requireVirtualTimeScheduler () {
	if (hasRequiredVirtualTimeScheduler) return VirtualTimeScheduler;
	hasRequiredVirtualTimeScheduler = 1;
	var __extends = (VirtualTimeScheduler && VirtualTimeScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(VirtualTimeScheduler, "__esModule", { value: true });
	VirtualTimeScheduler.VirtualAction = VirtualTimeScheduler.VirtualTimeScheduler = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var VirtualTimeScheduler$1 = (function (_super) {
	    __extends(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
	        if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }
	        if (maxFrames === void 0) { maxFrames = Infinity; }
	        var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;
	        _this.maxFrames = maxFrames;
	        _this.frame = 0;
	        _this.index = -1;
	        return _this;
	    }
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error;
	        var action;
	        while ((action = actions[0]) && action.delay <= maxFrames) {
	            actions.shift();
	            this.frame = action.delay;
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        }
	        if (error) {
	            while ((action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	VirtualTimeScheduler.VirtualTimeScheduler = VirtualTimeScheduler$1;
	var VirtualAction = (function (_super) {
	    __extends(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) { index = (scheduler.index += 1); }
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.index = index;
	        _this.active = true;
	        _this.index = scheduler.index = index;
	        return _this;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (Number.isFinite(delay)) {
	            if (!this.id) {
	                return _super.prototype.schedule.call(this, state, delay);
	            }
	            this.active = false;
	            var action = new VirtualAction(this.scheduler, this.work);
	            this.add(action);
	            return action.schedule(state, delay);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return 1;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        return undefined;
	    };
	    VirtualAction.prototype._execute = function (state, delay) {
	        if (this.active === true) {
	            return _super.prototype._execute.call(this, state, delay);
	        }
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction_1.AsyncAction));
	VirtualTimeScheduler.VirtualAction = VirtualAction;
	
	return VirtualTimeScheduler;
}

var Notification = {};

var empty = {};

var hasRequiredEmpty;

function requireEmpty () {
	if (hasRequiredEmpty) return empty;
	hasRequiredEmpty = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.empty = exports.EMPTY = void 0;
		var Observable_1 = /*@__PURE__*/ requireObservable();
		exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
		function empty(scheduler) {
		    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
		}
		exports.empty = empty;
		function emptyScheduled(scheduler) {
		    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
		}
		
	} (empty));
	return empty;
}

var of = {};

var args = {};

var isScheduler = {};

var hasRequiredIsScheduler;

function requireIsScheduler () {
	if (hasRequiredIsScheduler) return isScheduler;
	hasRequiredIsScheduler = 1;
	Object.defineProperty(isScheduler, "__esModule", { value: true });
	isScheduler.isScheduler = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isScheduler$1(value) {
	    return value && isFunction_1.isFunction(value.schedule);
	}
	isScheduler.isScheduler = isScheduler$1;
	
	return isScheduler;
}

var hasRequiredArgs;

function requireArgs () {
	if (hasRequiredArgs) return args;
	hasRequiredArgs = 1;
	Object.defineProperty(args, "__esModule", { value: true });
	args.popNumber = args.popScheduler = args.popResultSelector = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	function last(arr) {
	    return arr[arr.length - 1];
	}
	function popResultSelector(args) {
	    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
	}
	args.popResultSelector = popResultSelector;
	function popScheduler(args) {
	    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
	}
	args.popScheduler = popScheduler;
	function popNumber(args, defaultValue) {
	    return typeof last(args) === 'number' ? args.pop() : defaultValue;
	}
	args.popNumber = popNumber;
	
	return args;
}

var from = {};

var scheduled = {};

var scheduleObservable = {};

var innerFrom = {};

var isArrayLike = {};

var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike;
	hasRequiredIsArrayLike = 1;
	Object.defineProperty(isArrayLike, "__esModule", { value: true });
	isArrayLike.isArrayLike = void 0;
	isArrayLike.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
	
	return isArrayLike;
}

var isPromise = {};

var hasRequiredIsPromise;

function requireIsPromise () {
	if (hasRequiredIsPromise) return isPromise;
	hasRequiredIsPromise = 1;
	Object.defineProperty(isPromise, "__esModule", { value: true });
	isPromise.isPromise = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isPromise$1(value) {
	    return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
	}
	isPromise.isPromise = isPromise$1;
	
	return isPromise;
}

var isInteropObservable = {};

var hasRequiredIsInteropObservable;

function requireIsInteropObservable () {
	if (hasRequiredIsInteropObservable) return isInteropObservable;
	hasRequiredIsInteropObservable = 1;
	Object.defineProperty(isInteropObservable, "__esModule", { value: true });
	isInteropObservable.isInteropObservable = void 0;
	var observable_1 = /*@__PURE__*/ requireObservable$1();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isInteropObservable$1(input) {
	    return isFunction_1.isFunction(input[observable_1.observable]);
	}
	isInteropObservable.isInteropObservable = isInteropObservable$1;
	
	return isInteropObservable;
}

var isAsyncIterable = {};

var hasRequiredIsAsyncIterable;

function requireIsAsyncIterable () {
	if (hasRequiredIsAsyncIterable) return isAsyncIterable;
	hasRequiredIsAsyncIterable = 1;
	Object.defineProperty(isAsyncIterable, "__esModule", { value: true });
	isAsyncIterable.isAsyncIterable = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isAsyncIterable$1(obj) {
	    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
	}
	isAsyncIterable.isAsyncIterable = isAsyncIterable$1;
	
	return isAsyncIterable;
}

var throwUnobservableError = {};

var hasRequiredThrowUnobservableError;

function requireThrowUnobservableError () {
	if (hasRequiredThrowUnobservableError) return throwUnobservableError;
	hasRequiredThrowUnobservableError = 1;
	Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
	throwUnobservableError.createInvalidObservableTypeError = void 0;
	function createInvalidObservableTypeError(input) {
	    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
	}
	throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
	
	return throwUnobservableError;
}

var isIterable = {};

var iterator = {};

var hasRequiredIterator;

function requireIterator () {
	if (hasRequiredIterator) return iterator;
	hasRequiredIterator = 1;
	Object.defineProperty(iterator, "__esModule", { value: true });
	iterator.iterator = iterator.getSymbolIterator = void 0;
	function getSymbolIterator() {
	    if (typeof Symbol !== 'function' || !Symbol.iterator) {
	        return '@@iterator';
	    }
	    return Symbol.iterator;
	}
	iterator.getSymbolIterator = getSymbolIterator;
	iterator.iterator = getSymbolIterator();
	
	return iterator;
}

var hasRequiredIsIterable;

function requireIsIterable () {
	if (hasRequiredIsIterable) return isIterable;
	hasRequiredIsIterable = 1;
	Object.defineProperty(isIterable, "__esModule", { value: true });
	isIterable.isIterable = void 0;
	var iterator_1 = /*@__PURE__*/ requireIterator();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isIterable$1(input) {
	    return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
	}
	isIterable.isIterable = isIterable$1;
	
	return isIterable;
}

var isReadableStreamLike = {};

var hasRequiredIsReadableStreamLike;

function requireIsReadableStreamLike () {
	if (hasRequiredIsReadableStreamLike) return isReadableStreamLike;
	hasRequiredIsReadableStreamLike = 1;
	var __generator = (isReadableStreamLike && isReadableStreamLike.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __await = (isReadableStreamLike && isReadableStreamLike.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
	var __asyncGenerator = (isReadableStreamLike && isReadableStreamLike.__asyncGenerator) || function (thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	};
	Object.defineProperty(isReadableStreamLike, "__esModule", { value: true });
	isReadableStreamLike.isReadableStreamLike = isReadableStreamLike.readableStreamLikeToAsyncGenerator = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function readableStreamLikeToAsyncGenerator(readableStream) {
	    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
	        var reader, _a, value, done;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    reader = readableStream.getReader();
	                    _b.label = 1;
	                case 1:
	                    _b.trys.push([1, , 9, 10]);
	                    _b.label = 2;
	                case 2:
	                    return [4, __await(reader.read())];
	                case 3:
	                    _a = _b.sent(), value = _a.value, done = _a.done;
	                    if (!done) return [3, 5];
	                    return [4, __await(void 0)];
	                case 4: return [2, _b.sent()];
	                case 5: return [4, __await(value)];
	                case 6: return [4, _b.sent()];
	                case 7:
	                    _b.sent();
	                    return [3, 2];
	                case 8: return [3, 10];
	                case 9:
	                    reader.releaseLock();
	                    return [7];
	                case 10: return [2];
	            }
	        });
	    });
	}
	isReadableStreamLike.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
	function isReadableStreamLike$1(obj) {
	    return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
	}
	isReadableStreamLike.isReadableStreamLike = isReadableStreamLike$1;
	
	return isReadableStreamLike;
}

var hasRequiredInnerFrom;

function requireInnerFrom () {
	if (hasRequiredInnerFrom) return innerFrom;
	hasRequiredInnerFrom = 1;
	var __awaiter = (innerFrom && innerFrom.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (innerFrom && innerFrom.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __asyncValues = (innerFrom && innerFrom.__asyncValues) || function (o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	};
	var __values = (innerFrom && innerFrom.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(innerFrom, "__esModule", { value: true });
	innerFrom.fromReadableStreamLike = innerFrom.fromAsyncIterable = innerFrom.fromIterable = innerFrom.fromPromise = innerFrom.fromArrayLike = innerFrom.fromInteropObservable = innerFrom.innerFrom = void 0;
	var isArrayLike_1 = /*@__PURE__*/ requireIsArrayLike();
	var isPromise_1 = /*@__PURE__*/ requireIsPromise();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isInteropObservable_1 = /*@__PURE__*/ requireIsInteropObservable();
	var isAsyncIterable_1 = /*@__PURE__*/ requireIsAsyncIterable();
	var throwUnobservableError_1 = /*@__PURE__*/ requireThrowUnobservableError();
	var isIterable_1 = /*@__PURE__*/ requireIsIterable();
	var isReadableStreamLike_1 = /*@__PURE__*/ requireIsReadableStreamLike();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var reportUnhandledError_1 = /*@__PURE__*/ requireReportUnhandledError();
	var observable_1 = /*@__PURE__*/ requireObservable$1();
	function innerFrom$1(input) {
	    if (input instanceof Observable_1.Observable) {
	        return input;
	    }
	    if (input != null) {
	        if (isInteropObservable_1.isInteropObservable(input)) {
	            return fromInteropObservable(input);
	        }
	        if (isArrayLike_1.isArrayLike(input)) {
	            return fromArrayLike(input);
	        }
	        if (isPromise_1.isPromise(input)) {
	            return fromPromise(input);
	        }
	        if (isAsyncIterable_1.isAsyncIterable(input)) {
	            return fromAsyncIterable(input);
	        }
	        if (isIterable_1.isIterable(input)) {
	            return fromIterable(input);
	        }
	        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
	            return fromReadableStreamLike(input);
	        }
	    }
	    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
	}
	innerFrom.innerFrom = innerFrom$1;
	function fromInteropObservable(obj) {
	    return new Observable_1.Observable(function (subscriber) {
	        var obs = obj[observable_1.observable]();
	        if (isFunction_1.isFunction(obs.subscribe)) {
	            return obs.subscribe(subscriber);
	        }
	        throw new TypeError('Provided object does not correctly implement Symbol.observable');
	    });
	}
	innerFrom.fromInteropObservable = fromInteropObservable;
	function fromArrayLike(array) {
	    return new Observable_1.Observable(function (subscriber) {
	        for (var i = 0; i < array.length && !subscriber.closed; i++) {
	            subscriber.next(array[i]);
	        }
	        subscriber.complete();
	    });
	}
	innerFrom.fromArrayLike = fromArrayLike;
	function fromPromise(promise) {
	    return new Observable_1.Observable(function (subscriber) {
	        promise
	            .then(function (value) {
	            if (!subscriber.closed) {
	                subscriber.next(value);
	                subscriber.complete();
	            }
	        }, function (err) { return subscriber.error(err); })
	            .then(null, reportUnhandledError_1.reportUnhandledError);
	    });
	}
	innerFrom.fromPromise = fromPromise;
	function fromIterable(iterable) {
	    return new Observable_1.Observable(function (subscriber) {
	        var e_1, _a;
	        try {
	            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
	                var value = iterable_1_1.value;
	                subscriber.next(value);
	                if (subscriber.closed) {
	                    return;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        subscriber.complete();
	    });
	}
	innerFrom.fromIterable = fromIterable;
	function fromAsyncIterable(asyncIterable) {
	    return new Observable_1.Observable(function (subscriber) {
	        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
	    });
	}
	innerFrom.fromAsyncIterable = fromAsyncIterable;
	function fromReadableStreamLike(readableStream) {
	    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
	}
	innerFrom.fromReadableStreamLike = fromReadableStreamLike;
	function process(asyncIterable, subscriber) {
	    var asyncIterable_1, asyncIterable_1_1;
	    var e_2, _a;
	    return __awaiter(this, void 0, void 0, function () {
	        var value, e_2_1;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    _b.trys.push([0, 5, 6, 11]);
	                    asyncIterable_1 = __asyncValues(asyncIterable);
	                    _b.label = 1;
	                case 1: return [4, asyncIterable_1.next()];
	                case 2:
	                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
	                    value = asyncIterable_1_1.value;
	                    subscriber.next(value);
	                    if (subscriber.closed) {
	                        return [2];
	                    }
	                    _b.label = 3;
	                case 3: return [3, 1];
	                case 4: return [3, 11];
	                case 5:
	                    e_2_1 = _b.sent();
	                    e_2 = { error: e_2_1 };
	                    return [3, 11];
	                case 6:
	                    _b.trys.push([6, , 9, 10]);
	                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
	                    return [4, _a.call(asyncIterable_1)];
	                case 7:
	                    _b.sent();
	                    _b.label = 8;
	                case 8: return [3, 10];
	                case 9:
	                    if (e_2) throw e_2.error;
	                    return [7];
	                case 10: return [7];
	                case 11:
	                    subscriber.complete();
	                    return [2];
	            }
	        });
	    });
	}
	
	return innerFrom;
}

var observeOn = {};

var executeSchedule = {};

var hasRequiredExecuteSchedule;

function requireExecuteSchedule () {
	if (hasRequiredExecuteSchedule) return executeSchedule;
	hasRequiredExecuteSchedule = 1;
	Object.defineProperty(executeSchedule, "__esModule", { value: true });
	executeSchedule.executeSchedule = void 0;
	function executeSchedule$1(parentSubscription, scheduler, work, delay, repeat) {
	    if (delay === void 0) { delay = 0; }
	    if (repeat === void 0) { repeat = false; }
	    var scheduleSubscription = scheduler.schedule(function () {
	        work();
	        if (repeat) {
	            parentSubscription.add(this.schedule(null, delay));
	        }
	        else {
	            this.unsubscribe();
	        }
	    }, delay);
	    parentSubscription.add(scheduleSubscription);
	    if (!repeat) {
	        return scheduleSubscription;
	    }
	}
	executeSchedule.executeSchedule = executeSchedule$1;
	
	return executeSchedule;
}

var hasRequiredObserveOn;

function requireObserveOn () {
	if (hasRequiredObserveOn) return observeOn;
	hasRequiredObserveOn = 1;
	Object.defineProperty(observeOn, "__esModule", { value: true });
	observeOn.observeOn = void 0;
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function observeOn$1(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
	    });
	}
	observeOn.observeOn = observeOn$1;
	
	return observeOn;
}

var subscribeOn = {};

var hasRequiredSubscribeOn;

function requireSubscribeOn () {
	if (hasRequiredSubscribeOn) return subscribeOn;
	hasRequiredSubscribeOn = 1;
	Object.defineProperty(subscribeOn, "__esModule", { value: true });
	subscribeOn.subscribeOn = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	function subscribeOn$1(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return lift_1.operate(function (source, subscriber) {
	        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
	    });
	}
	subscribeOn.subscribeOn = subscribeOn$1;
	
	return subscribeOn;
}

var hasRequiredScheduleObservable;

function requireScheduleObservable () {
	if (hasRequiredScheduleObservable) return scheduleObservable;
	hasRequiredScheduleObservable = 1;
	Object.defineProperty(scheduleObservable, "__esModule", { value: true });
	scheduleObservable.scheduleObservable = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var observeOn_1 = /*@__PURE__*/ requireObserveOn();
	var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
	function scheduleObservable$1(input, scheduler) {
	    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	}
	scheduleObservable.scheduleObservable = scheduleObservable$1;
	
	return scheduleObservable;
}

var schedulePromise = {};

var hasRequiredSchedulePromise;

function requireSchedulePromise () {
	if (hasRequiredSchedulePromise) return schedulePromise;
	hasRequiredSchedulePromise = 1;
	Object.defineProperty(schedulePromise, "__esModule", { value: true });
	schedulePromise.schedulePromise = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var observeOn_1 = /*@__PURE__*/ requireObserveOn();
	var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
	function schedulePromise$1(input, scheduler) {
	    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	}
	schedulePromise.schedulePromise = schedulePromise$1;
	
	return schedulePromise;
}

var scheduleArray = {};

var hasRequiredScheduleArray;

function requireScheduleArray () {
	if (hasRequiredScheduleArray) return scheduleArray;
	hasRequiredScheduleArray = 1;
	Object.defineProperty(scheduleArray, "__esModule", { value: true });
	scheduleArray.scheduleArray = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	function scheduleArray$1(input, scheduler) {
	    return new Observable_1.Observable(function (subscriber) {
	        var i = 0;
	        return scheduler.schedule(function () {
	            if (i === input.length) {
	                subscriber.complete();
	            }
	            else {
	                subscriber.next(input[i++]);
	                if (!subscriber.closed) {
	                    this.schedule();
	                }
	            }
	        });
	    });
	}
	scheduleArray.scheduleArray = scheduleArray$1;
	
	return scheduleArray;
}

var scheduleIterable = {};

var hasRequiredScheduleIterable;

function requireScheduleIterable () {
	if (hasRequiredScheduleIterable) return scheduleIterable;
	hasRequiredScheduleIterable = 1;
	Object.defineProperty(scheduleIterable, "__esModule", { value: true });
	scheduleIterable.scheduleIterable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var iterator_1 = /*@__PURE__*/ requireIterator();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function scheduleIterable$1(input, scheduler) {
	    return new Observable_1.Observable(function (subscriber) {
	        var iterator;
	        executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	            iterator = input[iterator_1.iterator]();
	            executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	                var _a;
	                var value;
	                var done;
	                try {
	                    (_a = iterator.next(), value = _a.value, done = _a.done);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (done) {
	                    subscriber.complete();
	                }
	                else {
	                    subscriber.next(value);
	                }
	            }, 0, true);
	        });
	        return function () { return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };
	    });
	}
	scheduleIterable.scheduleIterable = scheduleIterable$1;
	
	return scheduleIterable;
}

var scheduleAsyncIterable = {};

var hasRequiredScheduleAsyncIterable;

function requireScheduleAsyncIterable () {
	if (hasRequiredScheduleAsyncIterable) return scheduleAsyncIterable;
	hasRequiredScheduleAsyncIterable = 1;
	Object.defineProperty(scheduleAsyncIterable, "__esModule", { value: true });
	scheduleAsyncIterable.scheduleAsyncIterable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function scheduleAsyncIterable$1(input, scheduler) {
	    if (!input) {
	        throw new Error('Iterable cannot be null');
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	            var iterator = input[Symbol.asyncIterator]();
	            executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	                iterator.next().then(function (result) {
	                    if (result.done) {
	                        subscriber.complete();
	                    }
	                    else {
	                        subscriber.next(result.value);
	                    }
	                });
	            }, 0, true);
	        });
	    });
	}
	scheduleAsyncIterable.scheduleAsyncIterable = scheduleAsyncIterable$1;
	
	return scheduleAsyncIterable;
}

var scheduleReadableStreamLike = {};

var hasRequiredScheduleReadableStreamLike;

function requireScheduleReadableStreamLike () {
	if (hasRequiredScheduleReadableStreamLike) return scheduleReadableStreamLike;
	hasRequiredScheduleReadableStreamLike = 1;
	Object.defineProperty(scheduleReadableStreamLike, "__esModule", { value: true });
	scheduleReadableStreamLike.scheduleReadableStreamLike = void 0;
	var scheduleAsyncIterable_1 = /*@__PURE__*/ requireScheduleAsyncIterable();
	var isReadableStreamLike_1 = /*@__PURE__*/ requireIsReadableStreamLike();
	function scheduleReadableStreamLike$1(input, scheduler) {
	    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
	}
	scheduleReadableStreamLike.scheduleReadableStreamLike = scheduleReadableStreamLike$1;
	
	return scheduleReadableStreamLike;
}

var hasRequiredScheduled;

function requireScheduled () {
	if (hasRequiredScheduled) return scheduled;
	hasRequiredScheduled = 1;
	Object.defineProperty(scheduled, "__esModule", { value: true });
	scheduled.scheduled = void 0;
	var scheduleObservable_1 = /*@__PURE__*/ requireScheduleObservable();
	var schedulePromise_1 = /*@__PURE__*/ requireSchedulePromise();
	var scheduleArray_1 = /*@__PURE__*/ requireScheduleArray();
	var scheduleIterable_1 = /*@__PURE__*/ requireScheduleIterable();
	var scheduleAsyncIterable_1 = /*@__PURE__*/ requireScheduleAsyncIterable();
	var isInteropObservable_1 = /*@__PURE__*/ requireIsInteropObservable();
	var isPromise_1 = /*@__PURE__*/ requireIsPromise();
	var isArrayLike_1 = /*@__PURE__*/ requireIsArrayLike();
	var isIterable_1 = /*@__PURE__*/ requireIsIterable();
	var isAsyncIterable_1 = /*@__PURE__*/ requireIsAsyncIterable();
	var throwUnobservableError_1 = /*@__PURE__*/ requireThrowUnobservableError();
	var isReadableStreamLike_1 = /*@__PURE__*/ requireIsReadableStreamLike();
	var scheduleReadableStreamLike_1 = /*@__PURE__*/ requireScheduleReadableStreamLike();
	function scheduled$1(input, scheduler) {
	    if (input != null) {
	        if (isInteropObservable_1.isInteropObservable(input)) {
	            return scheduleObservable_1.scheduleObservable(input, scheduler);
	        }
	        if (isArrayLike_1.isArrayLike(input)) {
	            return scheduleArray_1.scheduleArray(input, scheduler);
	        }
	        if (isPromise_1.isPromise(input)) {
	            return schedulePromise_1.schedulePromise(input, scheduler);
	        }
	        if (isAsyncIterable_1.isAsyncIterable(input)) {
	            return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
	        }
	        if (isIterable_1.isIterable(input)) {
	            return scheduleIterable_1.scheduleIterable(input, scheduler);
	        }
	        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
	            return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
	        }
	    }
	    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
	}
	scheduled.scheduled = scheduled$1;
	
	return scheduled;
}

var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from;
	hasRequiredFrom = 1;
	Object.defineProperty(from, "__esModule", { value: true });
	from.from = void 0;
	var scheduled_1 = /*@__PURE__*/ requireScheduled();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function from$1(input, scheduler) {
	    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
	}
	from.from = from$1;
	
	return from;
}

var hasRequiredOf;

function requireOf () {
	if (hasRequiredOf) return of;
	hasRequiredOf = 1;
	Object.defineProperty(of, "__esModule", { value: true });
	of.of = void 0;
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom();
	function of$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    return from_1.from(args, scheduler);
	}
	of.of = of$1;
	
	return of;
}

var throwError = {};

var hasRequiredThrowError;

function requireThrowError () {
	if (hasRequiredThrowError) return throwError;
	hasRequiredThrowError = 1;
	Object.defineProperty(throwError, "__esModule", { value: true });
	throwError.throwError = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function throwError$1(errorOrErrorFactory, scheduler) {
	    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };
	    var init = function (subscriber) { return subscriber.error(errorFactory()); };
	    return new Observable_1.Observable(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);
	}
	throwError.throwError = throwError$1;
	
	return throwError;
}

var hasRequiredNotification;

function requireNotification () {
	if (hasRequiredNotification) return Notification;
	hasRequiredNotification = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
		var empty_1 = /*@__PURE__*/ requireEmpty();
		var of_1 = /*@__PURE__*/ requireOf();
		var throwError_1 = /*@__PURE__*/ requireThrowError();
		var isFunction_1 = /*@__PURE__*/ requireIsFunction();
		(function (NotificationKind) {
		    NotificationKind["NEXT"] = "N";
		    NotificationKind["ERROR"] = "E";
		    NotificationKind["COMPLETE"] = "C";
		})(exports.NotificationKind || (exports.NotificationKind = {}));
		var Notification = (function () {
		    function Notification(kind, value, error) {
		        this.kind = kind;
		        this.value = value;
		        this.error = error;
		        this.hasValue = kind === 'N';
		    }
		    Notification.prototype.observe = function (observer) {
		        return observeNotification(this, observer);
		    };
		    Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {
		        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
		        return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
		    };
		    Notification.prototype.accept = function (nextOrObserver, error, complete) {
		        var _a;
		        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)
		            ? this.observe(nextOrObserver)
		            : this.do(nextOrObserver, error, complete);
		    };
		    Notification.prototype.toObservable = function () {
		        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
		        var result = kind === 'N'
		            ?
		                of_1.of(value)
		            :
		                kind === 'E'
		                    ?
		                        throwError_1.throwError(function () { return error; })
		                    :
		                        kind === 'C'
		                            ?
		                                empty_1.EMPTY
		                            :
		                                0;
		        if (!result) {
		            throw new TypeError("Unexpected notification kind " + kind);
		        }
		        return result;
		    };
		    Notification.createNext = function (value) {
		        return new Notification('N', value);
		    };
		    Notification.createError = function (err) {
		        return new Notification('E', undefined, err);
		    };
		    Notification.createComplete = function () {
		        return Notification.completeNotification;
		    };
		    Notification.completeNotification = new Notification('C');
		    return Notification;
		}());
		exports.Notification = Notification;
		function observeNotification(notification, observer) {
		    var _a, _b, _c;
		    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
		    if (typeof kind !== 'string') {
		        throw new TypeError('Invalid notification, missing "kind"');
		    }
		    kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
		}
		exports.observeNotification = observeNotification;
		
	} (Notification));
	return Notification;
}

var isObservable = {};

var hasRequiredIsObservable;

function requireIsObservable () {
	if (hasRequiredIsObservable) return isObservable;
	hasRequiredIsObservable = 1;
	Object.defineProperty(isObservable, "__esModule", { value: true });
	isObservable.isObservable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isObservable$1(obj) {
	    return !!obj && (obj instanceof Observable_1.Observable || (isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe)));
	}
	isObservable.isObservable = isObservable$1;
	
	return isObservable;
}

var lastValueFrom = {};

var EmptyError = {};

var hasRequiredEmptyError;

function requireEmptyError () {
	if (hasRequiredEmptyError) return EmptyError;
	hasRequiredEmptyError = 1;
	Object.defineProperty(EmptyError, "__esModule", { value: true });
	EmptyError.EmptyError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	EmptyError.EmptyError = createErrorClass_1.createErrorClass(function (_super) {
	    return function EmptyErrorImpl() {
	        _super(this);
	        this.name = 'EmptyError';
	        this.message = 'no elements in sequence';
	    };
	});
	
	return EmptyError;
}

var hasRequiredLastValueFrom;

function requireLastValueFrom () {
	if (hasRequiredLastValueFrom) return lastValueFrom;
	hasRequiredLastValueFrom = 1;
	Object.defineProperty(lastValueFrom, "__esModule", { value: true });
	lastValueFrom.lastValueFrom = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	function lastValueFrom$1(source, config) {
	    var hasConfig = typeof config === 'object';
	    return new Promise(function (resolve, reject) {
	        var _hasValue = false;
	        var _value;
	        source.subscribe({
	            next: function (value) {
	                _value = value;
	                _hasValue = true;
	            },
	            error: reject,
	            complete: function () {
	                if (_hasValue) {
	                    resolve(_value);
	                }
	                else if (hasConfig) {
	                    resolve(config.defaultValue);
	                }
	                else {
	                    reject(new EmptyError_1.EmptyError());
	                }
	            },
	        });
	    });
	}
	lastValueFrom.lastValueFrom = lastValueFrom$1;
	
	return lastValueFrom;
}

var firstValueFrom = {};

var hasRequiredFirstValueFrom;

function requireFirstValueFrom () {
	if (hasRequiredFirstValueFrom) return firstValueFrom;
	hasRequiredFirstValueFrom = 1;
	Object.defineProperty(firstValueFrom, "__esModule", { value: true });
	firstValueFrom.firstValueFrom = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	function firstValueFrom$1(source, config) {
	    var hasConfig = typeof config === 'object';
	    return new Promise(function (resolve, reject) {
	        var subscriber = new Subscriber_1.SafeSubscriber({
	            next: function (value) {
	                resolve(value);
	                subscriber.unsubscribe();
	            },
	            error: reject,
	            complete: function () {
	                if (hasConfig) {
	                    resolve(config.defaultValue);
	                }
	                else {
	                    reject(new EmptyError_1.EmptyError());
	                }
	            },
	        });
	        source.subscribe(subscriber);
	    });
	}
	firstValueFrom.firstValueFrom = firstValueFrom$1;
	
	return firstValueFrom;
}

var ArgumentOutOfRangeError = {};

var hasRequiredArgumentOutOfRangeError;

function requireArgumentOutOfRangeError () {
	if (hasRequiredArgumentOutOfRangeError) return ArgumentOutOfRangeError;
	hasRequiredArgumentOutOfRangeError = 1;
	Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
	ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function (_super) {
	    return function ArgumentOutOfRangeErrorImpl() {
	        _super(this);
	        this.name = 'ArgumentOutOfRangeError';
	        this.message = 'argument out of range';
	    };
	});
	
	return ArgumentOutOfRangeError;
}

var NotFoundError = {};

var hasRequiredNotFoundError;

function requireNotFoundError () {
	if (hasRequiredNotFoundError) return NotFoundError;
	hasRequiredNotFoundError = 1;
	Object.defineProperty(NotFoundError, "__esModule", { value: true });
	NotFoundError.NotFoundError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	NotFoundError.NotFoundError = createErrorClass_1.createErrorClass(function (_super) {
	    return function NotFoundErrorImpl(message) {
	        _super(this);
	        this.name = 'NotFoundError';
	        this.message = message;
	    };
	});
	
	return NotFoundError;
}

var SequenceError = {};

var hasRequiredSequenceError;

function requireSequenceError () {
	if (hasRequiredSequenceError) return SequenceError;
	hasRequiredSequenceError = 1;
	Object.defineProperty(SequenceError, "__esModule", { value: true });
	SequenceError.SequenceError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	SequenceError.SequenceError = createErrorClass_1.createErrorClass(function (_super) {
	    return function SequenceErrorImpl(message) {
	        _super(this);
	        this.name = 'SequenceError';
	        this.message = message;
	    };
	});
	
	return SequenceError;
}

var timeout = {};

var isDate = {};

var hasRequiredIsDate;

function requireIsDate () {
	if (hasRequiredIsDate) return isDate;
	hasRequiredIsDate = 1;
	Object.defineProperty(isDate, "__esModule", { value: true });
	isDate.isValidDate = void 0;
	function isValidDate(value) {
	    return value instanceof Date && !isNaN(value);
	}
	isDate.isValidDate = isValidDate;
	
	return isDate;
}

var hasRequiredTimeout;

function requireTimeout () {
	if (hasRequiredTimeout) return timeout;
	hasRequiredTimeout = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.timeout = exports.TimeoutError = void 0;
		var async_1 = /*@__PURE__*/ requireAsync();
		var isDate_1 = /*@__PURE__*/ requireIsDate();
		var lift_1 = /*@__PURE__*/ requireLift();
		var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
		var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
		var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
		var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
		exports.TimeoutError = createErrorClass_1.createErrorClass(function (_super) {
		    return function TimeoutErrorImpl(info) {
		        if (info === void 0) { info = null; }
		        _super(this);
		        this.message = 'Timeout has occurred';
		        this.name = 'TimeoutError';
		        this.info = info;
		    };
		});
		function timeout(config, schedulerArg) {
		    var _a = (isDate_1.isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
		    if (first == null && each == null) {
		        throw new TypeError('No timeout provided.');
		    }
		    return lift_1.operate(function (source, subscriber) {
		        var originalSourceSubscription;
		        var timerSubscription;
		        var lastValue = null;
		        var seen = 0;
		        var startTimer = function (delay) {
		            timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
		                try {
		                    originalSourceSubscription.unsubscribe();
		                    innerFrom_1.innerFrom(_with({
		                        meta: meta,
		                        lastValue: lastValue,
		                        seen: seen,
		                    })).subscribe(subscriber);
		                }
		                catch (err) {
		                    subscriber.error(err);
		                }
		            }, delay);
		        };
		        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
		            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
		            seen++;
		            subscriber.next((lastValue = value));
		            each > 0 && startTimer(each);
		        }, undefined, undefined, function () {
		            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
		                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
		            }
		            lastValue = null;
		        }));
		        !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
		    });
		}
		exports.timeout = timeout;
		function timeoutErrorFactory(info) {
		    throw new exports.TimeoutError(info);
		}
		
	} (timeout));
	return timeout;
}

var bindCallback = {};

var bindCallbackInternals = {};

var mapOneOrManyArgs = {};

var map = {};

var hasRequiredMap;

function requireMap () {
	if (hasRequiredMap) return map;
	hasRequiredMap = 1;
	Object.defineProperty(map, "__esModule", { value: true });
	map.map = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function map$1(project, thisArg) {
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            subscriber.next(project.call(thisArg, value, index++));
	        }));
	    });
	}
	map.map = map$1;
	
	return map;
}

var hasRequiredMapOneOrManyArgs;

function requireMapOneOrManyArgs () {
	if (hasRequiredMapOneOrManyArgs) return mapOneOrManyArgs;
	hasRequiredMapOneOrManyArgs = 1;
	var __read = (mapOneOrManyArgs && mapOneOrManyArgs.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (mapOneOrManyArgs && mapOneOrManyArgs.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(mapOneOrManyArgs, "__esModule", { value: true });
	mapOneOrManyArgs.mapOneOrManyArgs = void 0;
	var map_1 = /*@__PURE__*/ requireMap();
	var isArray = Array.isArray;
	function callOrApply(fn, args) {
	    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
	}
	function mapOneOrManyArgs$1(fn) {
	    return map_1.map(function (args) { return callOrApply(fn, args); });
	}
	mapOneOrManyArgs.mapOneOrManyArgs = mapOneOrManyArgs$1;
	
	return mapOneOrManyArgs;
}

var hasRequiredBindCallbackInternals;

function requireBindCallbackInternals () {
	if (hasRequiredBindCallbackInternals) return bindCallbackInternals;
	hasRequiredBindCallbackInternals = 1;
	var __read = (bindCallbackInternals && bindCallbackInternals.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (bindCallbackInternals && bindCallbackInternals.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(bindCallbackInternals, "__esModule", { value: true });
	bindCallbackInternals.bindCallbackInternals = void 0;
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var observeOn_1 = /*@__PURE__*/ requireObserveOn();
	var AsyncSubject_1 = /*@__PURE__*/ requireAsyncSubject();
	function bindCallbackInternals$1(isNodeStyle, callbackFunc, resultSelector, scheduler) {
	    if (resultSelector) {
	        if (isScheduler_1.isScheduler(resultSelector)) {
	            scheduler = resultSelector;
	        }
	        else {
	            return function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                return bindCallbackInternals$1(isNodeStyle, callbackFunc, scheduler)
	                    .apply(this, args)
	                    .pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
	            };
	        }
	    }
	    if (scheduler) {
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return bindCallbackInternals$1(isNodeStyle, callbackFunc)
	                .apply(this, args)
	                .pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	        };
	    }
	    return function () {
	        var _this = this;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var subject = new AsyncSubject_1.AsyncSubject();
	        var uninitialized = true;
	        return new Observable_1.Observable(function (subscriber) {
	            var subs = subject.subscribe(subscriber);
	            if (uninitialized) {
	                uninitialized = false;
	                var isAsync_1 = false;
	                var isComplete_1 = false;
	                callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
	                    function () {
	                        var results = [];
	                        for (var _i = 0; _i < arguments.length; _i++) {
	                            results[_i] = arguments[_i];
	                        }
	                        if (isNodeStyle) {
	                            var err = results.shift();
	                            if (err != null) {
	                                subject.error(err);
	                                return;
	                            }
	                        }
	                        subject.next(1 < results.length ? results : results[0]);
	                        isComplete_1 = true;
	                        if (isAsync_1) {
	                            subject.complete();
	                        }
	                    },
	                ]));
	                if (isComplete_1) {
	                    subject.complete();
	                }
	                isAsync_1 = true;
	            }
	            return subs;
	        });
	    };
	}
	bindCallbackInternals.bindCallbackInternals = bindCallbackInternals$1;
	
	return bindCallbackInternals;
}

var hasRequiredBindCallback;

function requireBindCallback () {
	if (hasRequiredBindCallback) return bindCallback;
	hasRequiredBindCallback = 1;
	Object.defineProperty(bindCallback, "__esModule", { value: true });
	bindCallback.bindCallback = void 0;
	var bindCallbackInternals_1 = /*@__PURE__*/ requireBindCallbackInternals();
	function bindCallback$1(callbackFunc, resultSelector, scheduler) {
	    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
	}
	bindCallback.bindCallback = bindCallback$1;
	
	return bindCallback;
}

var bindNodeCallback = {};

var hasRequiredBindNodeCallback;

function requireBindNodeCallback () {
	if (hasRequiredBindNodeCallback) return bindNodeCallback;
	hasRequiredBindNodeCallback = 1;
	Object.defineProperty(bindNodeCallback, "__esModule", { value: true });
	bindNodeCallback.bindNodeCallback = void 0;
	var bindCallbackInternals_1 = /*@__PURE__*/ requireBindCallbackInternals();
	function bindNodeCallback$1(callbackFunc, resultSelector, scheduler) {
	    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
	}
	bindNodeCallback.bindNodeCallback = bindNodeCallback$1;
	
	return bindNodeCallback;
}

var combineLatest$1 = {};

var argsArgArrayOrObject = {};

var hasRequiredArgsArgArrayOrObject;

function requireArgsArgArrayOrObject () {
	if (hasRequiredArgsArgArrayOrObject) return argsArgArrayOrObject;
	hasRequiredArgsArgArrayOrObject = 1;
	Object.defineProperty(argsArgArrayOrObject, "__esModule", { value: true });
	argsArgArrayOrObject.argsArgArrayOrObject = void 0;
	var isArray = Array.isArray;
	var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
	function argsArgArrayOrObject$1(args) {
	    if (args.length === 1) {
	        var first_1 = args[0];
	        if (isArray(first_1)) {
	            return { args: first_1, keys: null };
	        }
	        if (isPOJO(first_1)) {
	            var keys = getKeys(first_1);
	            return {
	                args: keys.map(function (key) { return first_1[key]; }),
	                keys: keys,
	            };
	        }
	    }
	    return { args: args, keys: null };
	}
	argsArgArrayOrObject.argsArgArrayOrObject = argsArgArrayOrObject$1;
	function isPOJO(obj) {
	    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
	}
	
	return argsArgArrayOrObject;
}

var createObject = {};

var hasRequiredCreateObject;

function requireCreateObject () {
	if (hasRequiredCreateObject) return createObject;
	hasRequiredCreateObject = 1;
	Object.defineProperty(createObject, "__esModule", { value: true });
	createObject.createObject = void 0;
	function createObject$1(keys, values) {
	    return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
	}
	createObject.createObject = createObject$1;
	
	return createObject;
}

var hasRequiredCombineLatest$1;

function requireCombineLatest$1 () {
	if (hasRequiredCombineLatest$1) return combineLatest$1;
	hasRequiredCombineLatest$1 = 1;
	Object.defineProperty(combineLatest$1, "__esModule", { value: true });
	combineLatest$1.combineLatestInit = combineLatest$1.combineLatest = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var argsArgArrayOrObject_1 = /*@__PURE__*/ requireArgsArgArrayOrObject();
	var from_1 = /*@__PURE__*/ requireFrom();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var args_1 = /*@__PURE__*/ requireArgs();
	var createObject_1 = /*@__PURE__*/ requireCreateObject();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function combineLatest() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    var resultSelector = args_1.popResultSelector(args);
	    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
	    if (observables.length === 0) {
	        return from_1.from([], scheduler);
	    }
	    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys
	        ?
	            function (values) { return createObject_1.createObject(keys, values); }
	        :
	            identity_1.identity));
	    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
	}
	combineLatest$1.combineLatest = combineLatest;
	function combineLatestInit(observables, scheduler, valueTransform) {
	    if (valueTransform === void 0) { valueTransform = identity_1.identity; }
	    return function (subscriber) {
	        maybeSchedule(scheduler, function () {
	            var length = observables.length;
	            var values = new Array(length);
	            var active = length;
	            var remainingFirstValues = length;
	            var _loop_1 = function (i) {
	                maybeSchedule(scheduler, function () {
	                    var source = from_1.from(observables[i], scheduler);
	                    var hasFirstValue = false;
	                    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                        values[i] = value;
	                        if (!hasFirstValue) {
	                            hasFirstValue = true;
	                            remainingFirstValues--;
	                        }
	                        if (!remainingFirstValues) {
	                            subscriber.next(valueTransform(values.slice()));
	                        }
	                    }, function () {
	                        if (!--active) {
	                            subscriber.complete();
	                        }
	                    }));
	                }, subscriber);
	            };
	            for (var i = 0; i < length; i++) {
	                _loop_1(i);
	            }
	        }, subscriber);
	    };
	}
	combineLatest$1.combineLatestInit = combineLatestInit;
	function maybeSchedule(scheduler, execute, subscription) {
	    if (scheduler) {
	        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
	    }
	    else {
	        execute();
	    }
	}
	
	return combineLatest$1;
}

var concat$1 = {};

var concatAll = {};

var mergeAll = {};

var mergeMap = {};

var mergeInternals = {};

var hasRequiredMergeInternals;

function requireMergeInternals () {
	if (hasRequiredMergeInternals) return mergeInternals;
	hasRequiredMergeInternals = 1;
	Object.defineProperty(mergeInternals, "__esModule", { value: true });
	mergeInternals.mergeInternals = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function mergeInternals$1(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
	    var buffer = [];
	    var active = 0;
	    var index = 0;
	    var isComplete = false;
	    var checkComplete = function () {
	        if (isComplete && !buffer.length && !active) {
	            subscriber.complete();
	        }
	    };
	    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
	    var doInnerSub = function (value) {
	        expand && subscriber.next(value);
	        active++;
	        var innerComplete = false;
	        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) {
	            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
	            if (expand) {
	                outerNext(innerValue);
	            }
	            else {
	                subscriber.next(innerValue);
	            }
	        }, function () {
	            innerComplete = true;
	        }, undefined, function () {
	            if (innerComplete) {
	                try {
	                    active--;
	                    var _loop_1 = function () {
	                        var bufferedValue = buffer.shift();
	                        if (innerSubScheduler) {
	                            executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
	                        }
	                        else {
	                            doInnerSub(bufferedValue);
	                        }
	                    };
	                    while (buffer.length && active < concurrent) {
	                        _loop_1();
	                    }
	                    checkComplete();
	                }
	                catch (err) {
	                    subscriber.error(err);
	                }
	            }
	        }));
	    };
	    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function () {
	        isComplete = true;
	        checkComplete();
	    }));
	    return function () {
	        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
	    };
	}
	mergeInternals.mergeInternals = mergeInternals$1;
	
	return mergeInternals;
}

var hasRequiredMergeMap;

function requireMergeMap () {
	if (hasRequiredMergeMap) return mergeMap;
	hasRequiredMergeMap = 1;
	Object.defineProperty(mergeMap, "__esModule", { value: true });
	mergeMap.mergeMap = void 0;
	var map_1 = /*@__PURE__*/ requireMap();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeInternals_1 = /*@__PURE__*/ requireMergeInternals();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function mergeMap$1(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    if (isFunction_1.isFunction(resultSelector)) {
	        return mergeMap$1(function (a, i) { return map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom_1.innerFrom(project(a, i))); }, concurrent);
	    }
	    else if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return lift_1.operate(function (source, subscriber) { return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent); });
	}
	mergeMap.mergeMap = mergeMap$1;
	
	return mergeMap;
}

var hasRequiredMergeAll;

function requireMergeAll () {
	if (hasRequiredMergeAll) return mergeAll;
	hasRequiredMergeAll = 1;
	Object.defineProperty(mergeAll, "__esModule", { value: true });
	mergeAll.mergeAll = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function mergeAll$1(concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
	}
	mergeAll.mergeAll = mergeAll$1;
	
	return mergeAll;
}

var hasRequiredConcatAll;

function requireConcatAll () {
	if (hasRequiredConcatAll) return concatAll;
	hasRequiredConcatAll = 1;
	Object.defineProperty(concatAll, "__esModule", { value: true });
	concatAll.concatAll = void 0;
	var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
	function concatAll$1() {
	    return mergeAll_1.mergeAll(1);
	}
	concatAll.concatAll = concatAll$1;
	
	return concatAll;
}

var hasRequiredConcat$1;

function requireConcat$1 () {
	if (hasRequiredConcat$1) return concat$1;
	hasRequiredConcat$1 = 1;
	Object.defineProperty(concat$1, "__esModule", { value: true });
	concat$1.concat = void 0;
	var concatAll_1 = /*@__PURE__*/ requireConcatAll();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom();
	function concat() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
	}
	concat$1.concat = concat;
	
	return concat$1;
}

var connectable = {};

var defer = {};

var hasRequiredDefer;

function requireDefer () {
	if (hasRequiredDefer) return defer;
	hasRequiredDefer = 1;
	Object.defineProperty(defer, "__esModule", { value: true });
	defer.defer = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function defer$1(observableFactory) {
	    return new Observable_1.Observable(function (subscriber) {
	        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
	    });
	}
	defer.defer = defer$1;
	
	return defer;
}

var hasRequiredConnectable;

function requireConnectable () {
	if (hasRequiredConnectable) return connectable;
	hasRequiredConnectable = 1;
	Object.defineProperty(connectable, "__esModule", { value: true });
	connectable.connectable = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var defer_1 = /*@__PURE__*/ requireDefer();
	var DEFAULT_CONFIG = {
	    connector: function () { return new Subject_1.Subject(); },
	    resetOnDisconnect: true,
	};
	function connectable$1(source, config) {
	    if (config === void 0) { config = DEFAULT_CONFIG; }
	    var connection = null;
	    var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
	    var subject = connector();
	    var result = new Observable_1.Observable(function (subscriber) {
	        return subject.subscribe(subscriber);
	    });
	    result.connect = function () {
	        if (!connection || connection.closed) {
	            connection = defer_1.defer(function () { return source; }).subscribe(subject);
	            if (resetOnDisconnect) {
	                connection.add(function () { return (subject = connector()); });
	            }
	        }
	        return connection;
	    };
	    return result;
	}
	connectable.connectable = connectable$1;
	
	return connectable;
}

var forkJoin = {};

var hasRequiredForkJoin;

function requireForkJoin () {
	if (hasRequiredForkJoin) return forkJoin;
	hasRequiredForkJoin = 1;
	Object.defineProperty(forkJoin, "__esModule", { value: true });
	forkJoin.forkJoin = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var argsArgArrayOrObject_1 = /*@__PURE__*/ requireArgsArgArrayOrObject();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var args_1 = /*@__PURE__*/ requireArgs();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var createObject_1 = /*@__PURE__*/ requireCreateObject();
	function forkJoin$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = args_1.popResultSelector(args);
	    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
	    var result = new Observable_1.Observable(function (subscriber) {
	        var length = sources.length;
	        if (!length) {
	            subscriber.complete();
	            return;
	        }
	        var values = new Array(length);
	        var remainingCompletions = length;
	        var remainingEmissions = length;
	        var _loop_1 = function (sourceIndex) {
	            var hasValue = false;
	            innerFrom_1.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                if (!hasValue) {
	                    hasValue = true;
	                    remainingEmissions--;
	                }
	                values[sourceIndex] = value;
	            }, function () { return remainingCompletions--; }, undefined, function () {
	                if (!remainingCompletions || !hasValue) {
	                    if (!remainingEmissions) {
	                        subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
	                    }
	                    subscriber.complete();
	                }
	            }));
	        };
	        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
	            _loop_1(sourceIndex);
	        }
	    });
	    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
	}
	forkJoin.forkJoin = forkJoin$1;
	
	return forkJoin;
}

var fromEvent = {};

var hasRequiredFromEvent;

function requireFromEvent () {
	if (hasRequiredFromEvent) return fromEvent;
	hasRequiredFromEvent = 1;
	var __read = (fromEvent && fromEvent.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	Object.defineProperty(fromEvent, "__esModule", { value: true });
	fromEvent.fromEvent = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var isArrayLike_1 = /*@__PURE__*/ requireIsArrayLike();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var nodeEventEmitterMethods = ['addListener', 'removeListener'];
	var eventTargetMethods = ['addEventListener', 'removeEventListener'];
	var jqueryMethods = ['on', 'off'];
	function fromEvent$1(target, eventName, options, resultSelector) {
	    if (isFunction_1.isFunction(options)) {
	        resultSelector = options;
	        options = undefined;
	    }
	    if (resultSelector) {
	        return fromEvent$1(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
	    }
	    var _a = __read(isEventTarget(target)
	        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
	        :
	            isNodeStyleEventEmitter(target)
	                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
	                : isJQueryStyleEventEmitter(target)
	                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
	                    : [], 2), add = _a[0], remove = _a[1];
	    if (!add) {
	        if (isArrayLike_1.isArrayLike(target)) {
	            return mergeMap_1.mergeMap(function (subTarget) { return fromEvent$1(subTarget, eventName, options); })(innerFrom_1.innerFrom(target));
	        }
	    }
	    if (!add) {
	        throw new TypeError('Invalid event target');
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        var handler = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return subscriber.next(1 < args.length ? args : args[0]);
	        };
	        add(handler);
	        return function () { return remove(handler); };
	    });
	}
	fromEvent.fromEvent = fromEvent$1;
	function toCommonHandlerRegistry(target, eventName) {
	    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
	}
	function isNodeStyleEventEmitter(target) {
	    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
	}
	function isJQueryStyleEventEmitter(target) {
	    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
	}
	function isEventTarget(target) {
	    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
	}
	
	return fromEvent;
}

var fromEventPattern = {};

var hasRequiredFromEventPattern;

function requireFromEventPattern () {
	if (hasRequiredFromEventPattern) return fromEventPattern;
	hasRequiredFromEventPattern = 1;
	Object.defineProperty(fromEventPattern, "__esModule", { value: true });
	fromEventPattern.fromEventPattern = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	function fromEventPattern$1(addHandler, removeHandler, resultSelector) {
	    if (resultSelector) {
	        return fromEventPattern$1(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        var handler = function () {
	            var e = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                e[_i] = arguments[_i];
	            }
	            return subscriber.next(e.length === 1 ? e[0] : e);
	        };
	        var retValue = addHandler(handler);
	        return isFunction_1.isFunction(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;
	    });
	}
	fromEventPattern.fromEventPattern = fromEventPattern$1;
	
	return fromEventPattern;
}

var generate = {};

var hasRequiredGenerate;

function requireGenerate () {
	if (hasRequiredGenerate) return generate;
	hasRequiredGenerate = 1;
	var __generator = (generate && generate.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(generate, "__esModule", { value: true });
	generate.generate = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	var defer_1 = /*@__PURE__*/ requireDefer();
	var scheduleIterable_1 = /*@__PURE__*/ requireScheduleIterable();
	function generate$1(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
	    var _a, _b;
	    var resultSelector;
	    var initialState;
	    if (arguments.length === 1) {
	        (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler);
	    }
	    else {
	        initialState = initialStateOrOptions;
	        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
	            resultSelector = identity_1.identity;
	            scheduler = resultSelectorOrScheduler;
	        }
	        else {
	            resultSelector = resultSelectorOrScheduler;
	        }
	    }
	    function gen() {
	        var state;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    state = initialState;
	                    _a.label = 1;
	                case 1:
	                    if (!(!condition || condition(state))) return [3, 4];
	                    return [4, resultSelector(state)];
	                case 2:
	                    _a.sent();
	                    _a.label = 3;
	                case 3:
	                    state = iterate(state);
	                    return [3, 1];
	                case 4: return [2];
	            }
	        });
	    }
	    return defer_1.defer((scheduler
	        ?
	            function () { return scheduleIterable_1.scheduleIterable(gen(), scheduler); }
	        :
	            gen));
	}
	generate.generate = generate$1;
	
	return generate;
}

var iif = {};

var hasRequiredIif;

function requireIif () {
	if (hasRequiredIif) return iif;
	hasRequiredIif = 1;
	Object.defineProperty(iif, "__esModule", { value: true });
	iif.iif = void 0;
	var defer_1 = /*@__PURE__*/ requireDefer();
	function iif$1(condition, trueResult, falseResult) {
	    return defer_1.defer(function () { return (condition() ? trueResult : falseResult); });
	}
	iif.iif = iif$1;
	
	return iif;
}

var interval = {};

var timer = {};

var hasRequiredTimer;

function requireTimer () {
	if (hasRequiredTimer) return timer;
	hasRequiredTimer = 1;
	Object.defineProperty(timer, "__esModule", { value: true });
	timer.timer = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var async_1 = /*@__PURE__*/ requireAsync();
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	var isDate_1 = /*@__PURE__*/ requireIsDate();
	function timer$1(dueTime, intervalOrScheduler, scheduler) {
	    if (dueTime === void 0) { dueTime = 0; }
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var intervalDuration = -1;
	    if (intervalOrScheduler != null) {
	        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
	            scheduler = intervalOrScheduler;
	        }
	        else {
	            intervalDuration = intervalOrScheduler;
	        }
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
	        if (due < 0) {
	            due = 0;
	        }
	        var n = 0;
	        return scheduler.schedule(function () {
	            if (!subscriber.closed) {
	                subscriber.next(n++);
	                if (0 <= intervalDuration) {
	                    this.schedule(undefined, intervalDuration);
	                }
	                else {
	                    subscriber.complete();
	                }
	            }
	        }, due);
	    });
	}
	timer.timer = timer$1;
	
	return timer;
}

var hasRequiredInterval;

function requireInterval () {
	if (hasRequiredInterval) return interval;
	hasRequiredInterval = 1;
	Object.defineProperty(interval, "__esModule", { value: true });
	interval.interval = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function interval$1(period, scheduler) {
	    if (period === void 0) { period = 0; }
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    if (period < 0) {
	        period = 0;
	    }
	    return timer_1.timer(period, period, scheduler);
	}
	interval.interval = interval$1;
	
	return interval;
}

var merge$1 = {};

var hasRequiredMerge$1;

function requireMerge$1 () {
	if (hasRequiredMerge$1) return merge$1;
	hasRequiredMerge$1 = 1;
	Object.defineProperty(merge$1, "__esModule", { value: true });
	merge$1.merge = void 0;
	var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom();
	function merge() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    var concurrent = args_1.popNumber(args, Infinity);
	    var sources = args;
	    return !sources.length
	        ?
	            empty_1.EMPTY
	        : sources.length === 1
	            ?
	                innerFrom_1.innerFrom(sources[0])
	            :
	                mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
	}
	merge$1.merge = merge;
	
	return merge$1;
}

var never = {};

var hasRequiredNever;

function requireNever () {
	if (hasRequiredNever) return never;
	hasRequiredNever = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.never = exports.NEVER = void 0;
		var Observable_1 = /*@__PURE__*/ requireObservable();
		var noop_1 = /*@__PURE__*/ requireNoop();
		exports.NEVER = new Observable_1.Observable(noop_1.noop);
		function never() {
		    return exports.NEVER;
		}
		exports.never = never;
		
	} (never));
	return never;
}

var onErrorResumeNext = {};

var argsOrArgArray = {};

var hasRequiredArgsOrArgArray;

function requireArgsOrArgArray () {
	if (hasRequiredArgsOrArgArray) return argsOrArgArray;
	hasRequiredArgsOrArgArray = 1;
	Object.defineProperty(argsOrArgArray, "__esModule", { value: true });
	argsOrArgArray.argsOrArgArray = void 0;
	var isArray = Array.isArray;
	function argsOrArgArray$1(args) {
	    return args.length === 1 && isArray(args[0]) ? args[0] : args;
	}
	argsOrArgArray.argsOrArgArray = argsOrArgArray$1;
	
	return argsOrArgArray;
}

var hasRequiredOnErrorResumeNext;

function requireOnErrorResumeNext () {
	if (hasRequiredOnErrorResumeNext) return onErrorResumeNext;
	hasRequiredOnErrorResumeNext = 1;
	Object.defineProperty(onErrorResumeNext, "__esModule", { value: true });
	onErrorResumeNext.onErrorResumeNext = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function onErrorResumeNext$1() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
	    return new Observable_1.Observable(function (subscriber) {
	        var sourceIndex = 0;
	        var subscribeNext = function () {
	            if (sourceIndex < nextSources.length) {
	                var nextSource = void 0;
	                try {
	                    nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
	                }
	                catch (err) {
	                    subscribeNext();
	                    return;
	                }
	                var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
	                nextSource.subscribe(innerSubscriber);
	                innerSubscriber.add(subscribeNext);
	            }
	            else {
	                subscriber.complete();
	            }
	        };
	        subscribeNext();
	    });
	}
	onErrorResumeNext.onErrorResumeNext = onErrorResumeNext$1;
	
	return onErrorResumeNext;
}

var pairs = {};

var hasRequiredPairs;

function requirePairs () {
	if (hasRequiredPairs) return pairs;
	hasRequiredPairs = 1;
	Object.defineProperty(pairs, "__esModule", { value: true });
	pairs.pairs = void 0;
	var from_1 = /*@__PURE__*/ requireFrom();
	function pairs$1(obj, scheduler) {
	    return from_1.from(Object.entries(obj), scheduler);
	}
	pairs.pairs = pairs$1;
	
	return pairs;
}

var partition$1 = {};

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	not.not = void 0;
	function not$1(pred, thisArg) {
	    return function (value, index) { return !pred.call(thisArg, value, index); };
	}
	not.not = not$1;
	
	return not;
}

var filter = {};

var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	Object.defineProperty(filter, "__esModule", { value: true });
	filter.filter = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function filter$1(predicate, thisArg) {
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
	    });
	}
	filter.filter = filter$1;
	
	return filter;
}

var hasRequiredPartition$1;

function requirePartition$1 () {
	if (hasRequiredPartition$1) return partition$1;
	hasRequiredPartition$1 = 1;
	Object.defineProperty(partition$1, "__esModule", { value: true });
	partition$1.partition = void 0;
	var not_1 = /*@__PURE__*/ requireNot();
	var filter_1 = /*@__PURE__*/ requireFilter();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function partition(source, predicate, thisArg) {
	    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
	}
	partition$1.partition = partition;
	
	return partition$1;
}

var race$1 = {};

var hasRequiredRace$1;

function requireRace$1 () {
	if (hasRequiredRace$1) return race$1;
	hasRequiredRace$1 = 1;
	Object.defineProperty(race$1, "__esModule", { value: true });
	race$1.raceInit = race$1.race = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function race() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    sources = argsOrArgArray_1.argsOrArgArray(sources);
	    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
	}
	race$1.race = race;
	function raceInit(sources) {
	    return function (subscriber) {
	        var subscriptions = [];
	        var _loop_1 = function (i) {
	            subscriptions.push(innerFrom_1.innerFrom(sources[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                if (subscriptions) {
	                    for (var s = 0; s < subscriptions.length; s++) {
	                        s !== i && subscriptions[s].unsubscribe();
	                    }
	                    subscriptions = null;
	                }
	                subscriber.next(value);
	            })));
	        };
	        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
	            _loop_1(i);
	        }
	    };
	}
	race$1.raceInit = raceInit;
	
	return race$1;
}

var range = {};

var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;
	Object.defineProperty(range, "__esModule", { value: true });
	range.range = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	function range$1(start, count, scheduler) {
	    if (count == null) {
	        count = start;
	        start = 0;
	    }
	    if (count <= 0) {
	        return empty_1.EMPTY;
	    }
	    var end = count + start;
	    return new Observable_1.Observable(scheduler
	        ?
	            function (subscriber) {
	                var n = start;
	                return scheduler.schedule(function () {
	                    if (n < end) {
	                        subscriber.next(n++);
	                        this.schedule();
	                    }
	                    else {
	                        subscriber.complete();
	                    }
	                });
	            }
	        :
	            function (subscriber) {
	                var n = start;
	                while (n < end && !subscriber.closed) {
	                    subscriber.next(n++);
	                }
	                subscriber.complete();
	            });
	}
	range.range = range$1;
	
	return range;
}

var using = {};

var hasRequiredUsing;

function requireUsing () {
	if (hasRequiredUsing) return using;
	hasRequiredUsing = 1;
	Object.defineProperty(using, "__esModule", { value: true });
	using.using = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	function using$1(resourceFactory, observableFactory) {
	    return new Observable_1.Observable(function (subscriber) {
	        var resource = resourceFactory();
	        var result = observableFactory(resource);
	        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
	        source.subscribe(subscriber);
	        return function () {
	            if (resource) {
	                resource.unsubscribe();
	            }
	        };
	    });
	}
	using.using = using$1;
	
	return using;
}

var zip$1 = {};

var hasRequiredZip$1;

function requireZip$1 () {
	if (hasRequiredZip$1) return zip$1;
	hasRequiredZip$1 = 1;
	var __read = (zip$1 && zip$1.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (zip$1 && zip$1.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(zip$1, "__esModule", { value: true });
	zip$1.zip = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var args_1 = /*@__PURE__*/ requireArgs();
	function zip() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = args_1.popResultSelector(args);
	    var sources = argsOrArgArray_1.argsOrArgArray(args);
	    return sources.length
	        ? new Observable_1.Observable(function (subscriber) {
	            var buffers = sources.map(function () { return []; });
	            var completed = sources.map(function () { return false; });
	            subscriber.add(function () {
	                buffers = completed = null;
	            });
	            var _loop_1 = function (sourceIndex) {
	                innerFrom_1.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                    buffers[sourceIndex].push(value);
	                    if (buffers.every(function (buffer) { return buffer.length; })) {
	                        var result = buffers.map(function (buffer) { return buffer.shift(); });
	                        subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
	                        if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {
	                            subscriber.complete();
	                        }
	                    }
	                }, function () {
	                    completed[sourceIndex] = true;
	                    !buffers[sourceIndex].length && subscriber.complete();
	                }));
	            };
	            for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
	                _loop_1(sourceIndex);
	            }
	            return function () {
	                buffers = completed = null;
	            };
	        })
	        : empty_1.EMPTY;
	}
	zip$1.zip = zip;
	
	return zip$1;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	
	return types;
}

var audit = {};

var hasRequiredAudit;

function requireAudit () {
	if (hasRequiredAudit) return audit;
	hasRequiredAudit = 1;
	Object.defineProperty(audit, "__esModule", { value: true });
	audit.audit = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function audit$1(durationSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        var durationSubscriber = null;
	        var isComplete = false;
	        var endDuration = function () {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            durationSubscriber = null;
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	            isComplete && subscriber.complete();
	        };
	        var cleanupDuration = function () {
	            durationSubscriber = null;
	            isComplete && subscriber.complete();
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            lastValue = value;
	            if (!durationSubscriber) {
	                innerFrom_1.innerFrom(durationSelector(value)).subscribe((durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));
	            }
	        }, function () {
	            isComplete = true;
	            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
	        }));
	    });
	}
	audit.audit = audit$1;
	
	return audit;
}

var auditTime = {};

var hasRequiredAuditTime;

function requireAuditTime () {
	if (hasRequiredAuditTime) return auditTime;
	hasRequiredAuditTime = 1;
	Object.defineProperty(auditTime, "__esModule", { value: true });
	auditTime.auditTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var audit_1 = /*@__PURE__*/ requireAudit();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function auditTime$1(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
	}
	auditTime.auditTime = auditTime$1;
	
	return auditTime;
}

var buffer = {};

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	Object.defineProperty(buffer, "__esModule", { value: true });
	buffer.buffer = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function buffer$1(closingNotifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var currentBuffer = [];
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
	            subscriber.next(currentBuffer);
	            subscriber.complete();
	        }));
	        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            var b = currentBuffer;
	            currentBuffer = [];
	            subscriber.next(b);
	        }, noop_1.noop));
	        return function () {
	            currentBuffer = null;
	        };
	    });
	}
	buffer.buffer = buffer$1;
	
	return buffer;
}

var bufferCount = {};

var hasRequiredBufferCount;

function requireBufferCount () {
	if (hasRequiredBufferCount) return bufferCount;
	hasRequiredBufferCount = 1;
	var __values = (bufferCount && bufferCount.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferCount, "__esModule", { value: true });
	bufferCount.bufferCount = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	function bufferCount$1(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
	    return lift_1.operate(function (source, subscriber) {
	        var buffers = [];
	        var count = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a, e_2, _b;
	            var toEmit = null;
	            if (count++ % startBufferEvery === 0) {
	                buffers.push([]);
	            }
	            try {
	                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	                    var buffer = buffers_1_1.value;
	                    buffer.push(value);
	                    if (bufferSize <= buffer.length) {
	                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
	                        toEmit.push(buffer);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            if (toEmit) {
	                try {
	                    for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
	                        var buffer = toEmit_1_1.value;
	                        arrRemove_1.arrRemove(buffers, buffer);
	                        subscriber.next(buffer);
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	        }, function () {
	            var e_3, _a;
	            try {
	                for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
	                    var buffer = buffers_2_1.value;
	                    subscriber.next(buffer);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	            subscriber.complete();
	        }, undefined, function () {
	            buffers = null;
	        }));
	    });
	}
	bufferCount.bufferCount = bufferCount$1;
	
	return bufferCount;
}

var bufferTime = {};

var hasRequiredBufferTime;

function requireBufferTime () {
	if (hasRequiredBufferTime) return bufferTime;
	hasRequiredBufferTime = 1;
	var __values = (bufferTime && bufferTime.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferTime, "__esModule", { value: true });
	bufferTime.bufferTime = void 0;
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var async_1 = /*@__PURE__*/ requireAsync();
	var args_1 = /*@__PURE__*/ requireArgs();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function bufferTime$1(bufferTimeSpan) {
	    var _a, _b;
	    var otherArgs = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherArgs[_i - 1] = arguments[_i];
	    }
	    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
	    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	    var maxBufferSize = otherArgs[1] || Infinity;
	    return lift_1.operate(function (source, subscriber) {
	        var bufferRecords = [];
	        var restartOnEmit = false;
	        var emit = function (record) {
	            var buffer = record.buffer, subs = record.subs;
	            subs.unsubscribe();
	            arrRemove_1.arrRemove(bufferRecords, record);
	            subscriber.next(buffer);
	            restartOnEmit && startBuffer();
	        };
	        var startBuffer = function () {
	            if (bufferRecords) {
	                var subs = new Subscription_1.Subscription();
	                subscriber.add(subs);
	                var buffer = [];
	                var record_1 = {
	                    buffer: buffer,
	                    subs: subs,
	                };
	                bufferRecords.push(record_1);
	                executeSchedule_1.executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);
	            }
	        };
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
	        }
	        else {
	            restartOnEmit = true;
	        }
	        startBuffer();
	        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            var recordsCopy = bufferRecords.slice();
	            try {
	                for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
	                    var record = recordsCopy_1_1.value;
	                    var buffer = record.buffer;
	                    buffer.push(value);
	                    maxBufferSize <= buffer.length && emit(record);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
	                subscriber.next(bufferRecords.shift().buffer);
	            }
	            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
	            subscriber.complete();
	            subscriber.unsubscribe();
	        }, undefined, function () { return (bufferRecords = null); });
	        source.subscribe(bufferTimeSubscriber);
	    });
	}
	bufferTime.bufferTime = bufferTime$1;
	
	return bufferTime;
}

var bufferToggle = {};

var hasRequiredBufferToggle;

function requireBufferToggle () {
	if (hasRequiredBufferToggle) return bufferToggle;
	hasRequiredBufferToggle = 1;
	var __values = (bufferToggle && bufferToggle.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferToggle, "__esModule", { value: true });
	bufferToggle.bufferToggle = void 0;
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	function bufferToggle$1(openings, closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var buffers = [];
	        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (openValue) {
	            var buffer = [];
	            buffers.push(buffer);
	            var closingSubscription = new Subscription_1.Subscription();
	            var emitBuffer = function () {
	                arrRemove_1.arrRemove(buffers, buffer);
	                subscriber.next(buffer);
	                closingSubscription.unsubscribe();
	            };
	            closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
	        }, noop_1.noop));
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            try {
	                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	                    var buffer = buffers_1_1.value;
	                    buffer.push(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (buffers.length > 0) {
	                subscriber.next(buffers.shift());
	            }
	            subscriber.complete();
	        }));
	    });
	}
	bufferToggle.bufferToggle = bufferToggle$1;
	
	return bufferToggle;
}

var bufferWhen = {};

var hasRequiredBufferWhen;

function requireBufferWhen () {
	if (hasRequiredBufferWhen) return bufferWhen;
	hasRequiredBufferWhen = 1;
	Object.defineProperty(bufferWhen, "__esModule", { value: true });
	bufferWhen.bufferWhen = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function bufferWhen$1(closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var buffer = null;
	        var closingSubscriber = null;
	        var openBuffer = function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            var b = buffer;
	            buffer = [];
	            b && subscriber.next(b);
	            innerFrom_1.innerFrom(closingSelector()).subscribe((closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop)));
	        };
	        openBuffer();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {
	            buffer && subscriber.next(buffer);
	            subscriber.complete();
	        }, undefined, function () { return (buffer = closingSubscriber = null); }));
	    });
	}
	bufferWhen.bufferWhen = bufferWhen$1;
	
	return bufferWhen;
}

var catchError = {};

var hasRequiredCatchError;

function requireCatchError () {
	if (hasRequiredCatchError) return catchError;
	hasRequiredCatchError = 1;
	Object.defineProperty(catchError, "__esModule", { value: true });
	catchError.catchError = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var lift_1 = /*@__PURE__*/ requireLift();
	function catchError$1(selector) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSub = null;
	        var syncUnsub = false;
	        var handledResult;
	        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	            handledResult = innerFrom_1.innerFrom(selector(err, catchError$1(selector)(source)));
	            if (innerSub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                handledResult.subscribe(subscriber);
	            }
	            else {
	                syncUnsub = true;
	            }
	        }));
	        if (syncUnsub) {
	            innerSub.unsubscribe();
	            innerSub = null;
	            handledResult.subscribe(subscriber);
	        }
	    });
	}
	catchError.catchError = catchError$1;
	
	return catchError;
}

var combineAll = {};

var combineLatestAll = {};

var joinAllInternals = {};

var toArray = {};

var reduce = {};

var scanInternals = {};

var hasRequiredScanInternals;

function requireScanInternals () {
	if (hasRequiredScanInternals) return scanInternals;
	hasRequiredScanInternals = 1;
	Object.defineProperty(scanInternals, "__esModule", { value: true });
	scanInternals.scanInternals = void 0;
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function scanInternals$1(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
	    return function (source, subscriber) {
	        var hasState = hasSeed;
	        var state = seed;
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var i = index++;
	            state = hasState
	                ?
	                    accumulator(state, value, i)
	                :
	                    ((hasState = true), value);
	            emitOnNext && subscriber.next(state);
	        }, emitBeforeComplete &&
	            (function () {
	                hasState && subscriber.next(state);
	                subscriber.complete();
	            })));
	    };
	}
	scanInternals.scanInternals = scanInternals$1;
	
	return scanInternals;
}

var hasRequiredReduce;

function requireReduce () {
	if (hasRequiredReduce) return reduce;
	hasRequiredReduce = 1;
	Object.defineProperty(reduce, "__esModule", { value: true });
	reduce.reduce = void 0;
	var scanInternals_1 = /*@__PURE__*/ requireScanInternals();
	var lift_1 = /*@__PURE__*/ requireLift();
	function reduce$1(accumulator, seed) {
	    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
	}
	reduce.reduce = reduce$1;
	
	return reduce;
}

var hasRequiredToArray;

function requireToArray () {
	if (hasRequiredToArray) return toArray;
	hasRequiredToArray = 1;
	Object.defineProperty(toArray, "__esModule", { value: true });
	toArray.toArray = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	var lift_1 = /*@__PURE__*/ requireLift();
	var arrReducer = function (arr, value) { return (arr.push(value), arr); };
	function toArray$1() {
	    return lift_1.operate(function (source, subscriber) {
	        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
	    });
	}
	toArray.toArray = toArray$1;
	
	return toArray;
}

var hasRequiredJoinAllInternals;

function requireJoinAllInternals () {
	if (hasRequiredJoinAllInternals) return joinAllInternals;
	hasRequiredJoinAllInternals = 1;
	Object.defineProperty(joinAllInternals, "__esModule", { value: true });
	joinAllInternals.joinAllInternals = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var pipe_1 = /*@__PURE__*/ requirePipe();
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var toArray_1 = /*@__PURE__*/ requireToArray();
	function joinAllInternals$1(joinFn, project) {
	    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
	}
	joinAllInternals.joinAllInternals = joinAllInternals$1;
	
	return joinAllInternals;
}

var hasRequiredCombineLatestAll;

function requireCombineLatestAll () {
	if (hasRequiredCombineLatestAll) return combineLatestAll;
	hasRequiredCombineLatestAll = 1;
	Object.defineProperty(combineLatestAll, "__esModule", { value: true });
	combineLatestAll.combineLatestAll = void 0;
	var combineLatest_1 = /*@__PURE__*/ requireCombineLatest$1();
	var joinAllInternals_1 = /*@__PURE__*/ requireJoinAllInternals();
	function combineLatestAll$1(project) {
	    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
	}
	combineLatestAll.combineLatestAll = combineLatestAll$1;
	
	return combineLatestAll;
}

var hasRequiredCombineAll;

function requireCombineAll () {
	if (hasRequiredCombineAll) return combineAll;
	hasRequiredCombineAll = 1;
	Object.defineProperty(combineAll, "__esModule", { value: true });
	combineAll.combineAll = void 0;
	var combineLatestAll_1 = /*@__PURE__*/ requireCombineLatestAll();
	combineAll.combineAll = combineLatestAll_1.combineLatestAll;
	
	return combineAll;
}

var combineLatestWith = {};

var combineLatest = {};

var hasRequiredCombineLatest;

function requireCombineLatest () {
	if (hasRequiredCombineLatest) return combineLatest;
	hasRequiredCombineLatest = 1;
	var __read = (combineLatest && combineLatest.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (combineLatest && combineLatest.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(combineLatest, "__esModule", { value: true });
	combineLatest.combineLatest = void 0;
	var combineLatest_1 = /*@__PURE__*/ requireCombineLatest$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var pipe_1 = /*@__PURE__*/ requirePipe();
	var args_1 = /*@__PURE__*/ requireArgs();
	function combineLatest$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = args_1.popResultSelector(args);
	    return resultSelector
	        ? pipe_1.pipe(combineLatest$1.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector))
	        : lift_1.operate(function (source, subscriber) {
	            combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
	        });
	}
	combineLatest.combineLatest = combineLatest$1;
	
	return combineLatest;
}

var hasRequiredCombineLatestWith;

function requireCombineLatestWith () {
	if (hasRequiredCombineLatestWith) return combineLatestWith;
	hasRequiredCombineLatestWith = 1;
	var __read = (combineLatestWith && combineLatestWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (combineLatestWith && combineLatestWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(combineLatestWith, "__esModule", { value: true });
	combineLatestWith.combineLatestWith = void 0;
	var combineLatest_1 = /*@__PURE__*/ requireCombineLatest();
	function combineLatestWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
	}
	combineLatestWith.combineLatestWith = combineLatestWith$1;
	
	return combineLatestWith;
}

var concatMap = {};

var hasRequiredConcatMap;

function requireConcatMap () {
	if (hasRequiredConcatMap) return concatMap;
	hasRequiredConcatMap = 1;
	Object.defineProperty(concatMap, "__esModule", { value: true });
	concatMap.concatMap = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function concatMap$1(project, resultSelector) {
	    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
	}
	concatMap.concatMap = concatMap$1;
	
	return concatMap;
}

var concatMapTo = {};

var hasRequiredConcatMapTo;

function requireConcatMapTo () {
	if (hasRequiredConcatMapTo) return concatMapTo;
	hasRequiredConcatMapTo = 1;
	Object.defineProperty(concatMapTo, "__esModule", { value: true });
	concatMapTo.concatMapTo = void 0;
	var concatMap_1 = /*@__PURE__*/ requireConcatMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function concatMapTo$1(innerObservable, resultSelector) {
	    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function () { return innerObservable; }, resultSelector) : concatMap_1.concatMap(function () { return innerObservable; });
	}
	concatMapTo.concatMapTo = concatMapTo$1;
	
	return concatMapTo;
}

var concatWith = {};

var concat = {};

var hasRequiredConcat;

function requireConcat () {
	if (hasRequiredConcat) return concat;
	hasRequiredConcat = 1;
	var __read = (concat && concat.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (concat && concat.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(concat, "__esModule", { value: true });
	concat.concat = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var concatAll_1 = /*@__PURE__*/ requireConcatAll();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom();
	function concat$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    return lift_1.operate(function (source, subscriber) {
	        concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
	    });
	}
	concat.concat = concat$1;
	
	return concat;
}

var hasRequiredConcatWith;

function requireConcatWith () {
	if (hasRequiredConcatWith) return concatWith;
	hasRequiredConcatWith = 1;
	var __read = (concatWith && concatWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (concatWith && concatWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(concatWith, "__esModule", { value: true });
	concatWith.concatWith = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat();
	function concatWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));
	}
	concatWith.concatWith = concatWith$1;
	
	return concatWith;
}

var connect = {};

var fromSubscribable = {};

var hasRequiredFromSubscribable;

function requireFromSubscribable () {
	if (hasRequiredFromSubscribable) return fromSubscribable;
	hasRequiredFromSubscribable = 1;
	Object.defineProperty(fromSubscribable, "__esModule", { value: true });
	fromSubscribable.fromSubscribable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	function fromSubscribable$1(subscribable) {
	    return new Observable_1.Observable(function (subscriber) { return subscribable.subscribe(subscriber); });
	}
	fromSubscribable.fromSubscribable = fromSubscribable$1;
	
	return fromSubscribable;
}

var hasRequiredConnect;

function requireConnect () {
	if (hasRequiredConnect) return connect;
	hasRequiredConnect = 1;
	Object.defineProperty(connect, "__esModule", { value: true });
	connect.connect = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var fromSubscribable_1 = /*@__PURE__*/ requireFromSubscribable();
	var DEFAULT_CONFIG = {
	    connector: function () { return new Subject_1.Subject(); },
	};
	function connect$1(selector, config) {
	    if (config === void 0) { config = DEFAULT_CONFIG; }
	    var connector = config.connector;
	    return lift_1.operate(function (source, subscriber) {
	        var subject = connector();
	        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
	        subscriber.add(source.subscribe(subject));
	    });
	}
	connect.connect = connect$1;
	
	return connect;
}

var count = {};

var hasRequiredCount;

function requireCount () {
	if (hasRequiredCount) return count;
	hasRequiredCount = 1;
	Object.defineProperty(count, "__esModule", { value: true });
	count.count = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	function count$1(predicate) {
	    return reduce_1.reduce(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);
	}
	count.count = count$1;
	
	return count;
}

var debounce = {};

var hasRequiredDebounce;

function requireDebounce () {
	if (hasRequiredDebounce) return debounce;
	hasRequiredDebounce = 1;
	Object.defineProperty(debounce, "__esModule", { value: true });
	debounce.debounce = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function debounce$1(durationSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        var durationSubscriber = null;
	        var emit = function () {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            durationSubscriber = null;
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            hasValue = true;
	            lastValue = value;
	            durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
	            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
	        }, function () {
	            emit();
	            subscriber.complete();
	        }, undefined, function () {
	            lastValue = durationSubscriber = null;
	        }));
	    });
	}
	debounce.debounce = debounce$1;
	
	return debounce;
}

var debounceTime = {};

var hasRequiredDebounceTime;

function requireDebounceTime () {
	if (hasRequiredDebounceTime) return debounceTime;
	hasRequiredDebounceTime = 1;
	Object.defineProperty(debounceTime, "__esModule", { value: true });
	debounceTime.debounceTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function debounceTime$1(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return lift_1.operate(function (source, subscriber) {
	        var activeTask = null;
	        var lastValue = null;
	        var lastTime = null;
	        var emit = function () {
	            if (activeTask) {
	                activeTask.unsubscribe();
	                activeTask = null;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        };
	        function emitWhenIdle() {
	            var targetTime = lastTime + dueTime;
	            var now = scheduler.now();
	            if (now < targetTime) {
	                activeTask = this.schedule(undefined, targetTime - now);
	                subscriber.add(activeTask);
	                return;
	            }
	            emit();
	        }
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            lastValue = value;
	            lastTime = scheduler.now();
	            if (!activeTask) {
	                activeTask = scheduler.schedule(emitWhenIdle, dueTime);
	                subscriber.add(activeTask);
	            }
	        }, function () {
	            emit();
	            subscriber.complete();
	        }, undefined, function () {
	            lastValue = activeTask = null;
	        }));
	    });
	}
	debounceTime.debounceTime = debounceTime$1;
	
	return debounceTime;
}

var defaultIfEmpty = {};

var hasRequiredDefaultIfEmpty;

function requireDefaultIfEmpty () {
	if (hasRequiredDefaultIfEmpty) return defaultIfEmpty;
	hasRequiredDefaultIfEmpty = 1;
	Object.defineProperty(defaultIfEmpty, "__esModule", { value: true });
	defaultIfEmpty.defaultIfEmpty = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function defaultIfEmpty$1(defaultValue) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            subscriber.next(value);
	        }, function () {
	            if (!hasValue) {
	                subscriber.next(defaultValue);
	            }
	            subscriber.complete();
	        }));
	    });
	}
	defaultIfEmpty.defaultIfEmpty = defaultIfEmpty$1;
	
	return defaultIfEmpty;
}

var delay = {};

var delayWhen = {};

var take = {};

var hasRequiredTake;

function requireTake () {
	if (hasRequiredTake) return take;
	hasRequiredTake = 1;
	Object.defineProperty(take, "__esModule", { value: true });
	take.take = void 0;
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function take$1(count) {
	    return count <= 0
	        ?
	            function () { return empty_1.EMPTY; }
	        : lift_1.operate(function (source, subscriber) {
	            var seen = 0;
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                if (++seen <= count) {
	                    subscriber.next(value);
	                    if (count <= seen) {
	                        subscriber.complete();
	                    }
	                }
	            }));
	        });
	}
	take.take = take$1;
	
	return take;
}

var ignoreElements = {};

var hasRequiredIgnoreElements;

function requireIgnoreElements () {
	if (hasRequiredIgnoreElements) return ignoreElements;
	hasRequiredIgnoreElements = 1;
	Object.defineProperty(ignoreElements, "__esModule", { value: true });
	ignoreElements.ignoreElements = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	function ignoreElements$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
	    });
	}
	ignoreElements.ignoreElements = ignoreElements$1;
	
	return ignoreElements;
}

var mapTo = {};

var hasRequiredMapTo;

function requireMapTo () {
	if (hasRequiredMapTo) return mapTo;
	hasRequiredMapTo = 1;
	Object.defineProperty(mapTo, "__esModule", { value: true });
	mapTo.mapTo = void 0;
	var map_1 = /*@__PURE__*/ requireMap();
	function mapTo$1(value) {
	    return map_1.map(function () { return value; });
	}
	mapTo.mapTo = mapTo$1;
	
	return mapTo;
}

var hasRequiredDelayWhen;

function requireDelayWhen () {
	if (hasRequiredDelayWhen) return delayWhen;
	hasRequiredDelayWhen = 1;
	Object.defineProperty(delayWhen, "__esModule", { value: true });
	delayWhen.delayWhen = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat$1();
	var take_1 = /*@__PURE__*/ requireTake();
	var ignoreElements_1 = /*@__PURE__*/ requireIgnoreElements();
	var mapTo_1 = /*@__PURE__*/ requireMapTo();
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function delayWhen$1(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return function (source) {
	            return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen$1(delayDurationSelector)));
	        };
	    }
	    return mergeMap_1.mergeMap(function (value, index) { return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value)); });
	}
	delayWhen.delayWhen = delayWhen$1;
	
	return delayWhen;
}

var hasRequiredDelay;

function requireDelay () {
	if (hasRequiredDelay) return delay;
	hasRequiredDelay = 1;
	Object.defineProperty(delay, "__esModule", { value: true });
	delay.delay = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var delayWhen_1 = /*@__PURE__*/ requireDelayWhen();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function delay$1(due, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    var duration = timer_1.timer(due, scheduler);
	    return delayWhen_1.delayWhen(function () { return duration; });
	}
	delay.delay = delay$1;
	
	return delay;
}

var dematerialize = {};

var hasRequiredDematerialize;

function requireDematerialize () {
	if (hasRequiredDematerialize) return dematerialize;
	hasRequiredDematerialize = 1;
	Object.defineProperty(dematerialize, "__esModule", { value: true });
	dematerialize.dematerialize = void 0;
	var Notification_1 = /*@__PURE__*/ requireNotification();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function dematerialize$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (notification) { return Notification_1.observeNotification(notification, subscriber); }));
	    });
	}
	dematerialize.dematerialize = dematerialize$1;
	
	return dematerialize;
}

var distinct = {};

var hasRequiredDistinct;

function requireDistinct () {
	if (hasRequiredDistinct) return distinct;
	hasRequiredDistinct = 1;
	Object.defineProperty(distinct, "__esModule", { value: true });
	distinct.distinct = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function distinct$1(keySelector, flushes) {
	    return lift_1.operate(function (source, subscriber) {
	        var distinctKeys = new Set();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var key = keySelector ? keySelector(value) : value;
	            if (!distinctKeys.has(key)) {
	                distinctKeys.add(key);
	                subscriber.next(value);
	            }
	        }));
	        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop_1.noop));
	    });
	}
	distinct.distinct = distinct$1;
	
	return distinct;
}

var distinctUntilChanged = {};

var hasRequiredDistinctUntilChanged;

function requireDistinctUntilChanged () {
	if (hasRequiredDistinctUntilChanged) return distinctUntilChanged;
	hasRequiredDistinctUntilChanged = 1;
	Object.defineProperty(distinctUntilChanged, "__esModule", { value: true });
	distinctUntilChanged.distinctUntilChanged = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function distinctUntilChanged$1(comparator, keySelector) {
	    if (keySelector === void 0) { keySelector = identity_1.identity; }
	    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
	    return lift_1.operate(function (source, subscriber) {
	        var previousKey;
	        var first = true;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var currentKey = keySelector(value);
	            if (first || !comparator(previousKey, currentKey)) {
	                first = false;
	                previousKey = currentKey;
	                subscriber.next(value);
	            }
	        }));
	    });
	}
	distinctUntilChanged.distinctUntilChanged = distinctUntilChanged$1;
	function defaultCompare(a, b) {
	    return a === b;
	}
	
	return distinctUntilChanged;
}

var distinctUntilKeyChanged = {};

var hasRequiredDistinctUntilKeyChanged;

function requireDistinctUntilKeyChanged () {
	if (hasRequiredDistinctUntilKeyChanged) return distinctUntilKeyChanged;
	hasRequiredDistinctUntilKeyChanged = 1;
	Object.defineProperty(distinctUntilKeyChanged, "__esModule", { value: true });
	distinctUntilKeyChanged.distinctUntilKeyChanged = void 0;
	var distinctUntilChanged_1 = /*@__PURE__*/ requireDistinctUntilChanged();
	function distinctUntilKeyChanged$1(key, compare) {
	    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return (compare ? compare(x[key], y[key]) : x[key] === y[key]); });
	}
	distinctUntilKeyChanged.distinctUntilKeyChanged = distinctUntilKeyChanged$1;
	
	return distinctUntilKeyChanged;
}

var elementAt = {};

var throwIfEmpty = {};

var hasRequiredThrowIfEmpty;

function requireThrowIfEmpty () {
	if (hasRequiredThrowIfEmpty) return throwIfEmpty;
	hasRequiredThrowIfEmpty = 1;
	Object.defineProperty(throwIfEmpty, "__esModule", { value: true });
	throwIfEmpty.throwIfEmpty = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function throwIfEmpty$1(errorFactory) {
	    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            subscriber.next(value);
	        }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
	    });
	}
	throwIfEmpty.throwIfEmpty = throwIfEmpty$1;
	function defaultErrorFactory() {
	    return new EmptyError_1.EmptyError();
	}
	
	return throwIfEmpty;
}

var hasRequiredElementAt;

function requireElementAt () {
	if (hasRequiredElementAt) return elementAt;
	hasRequiredElementAt = 1;
	Object.defineProperty(elementAt, "__esModule", { value: true });
	elementAt.elementAt = void 0;
	var ArgumentOutOfRangeError_1 = /*@__PURE__*/ requireArgumentOutOfRangeError();
	var filter_1 = /*@__PURE__*/ requireFilter();
	var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
	var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
	var take_1 = /*@__PURE__*/ requireTake();
	function elementAt$1(index, defaultValue) {
	    if (index < 0) {
	        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
	    }
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); }));
	    };
	}
	elementAt.elementAt = elementAt$1;
	
	return elementAt;
}

var endWith = {};

var hasRequiredEndWith;

function requireEndWith () {
	if (hasRequiredEndWith) return endWith;
	hasRequiredEndWith = 1;
	var __read = (endWith && endWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (endWith && endWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(endWith, "__esModule", { value: true });
	endWith.endWith = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat$1();
	var of_1 = /*@__PURE__*/ requireOf();
	function endWith$1() {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values)))); };
	}
	endWith.endWith = endWith$1;
	
	return endWith;
}

var every = {};

var hasRequiredEvery;

function requireEvery () {
	if (hasRequiredEvery) return every;
	hasRequiredEvery = 1;
	Object.defineProperty(every, "__esModule", { value: true });
	every.every = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function every$1(predicate, thisArg) {
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            if (!predicate.call(thisArg, value, index++, source)) {
	                subscriber.next(false);
	                subscriber.complete();
	            }
	        }, function () {
	            subscriber.next(true);
	            subscriber.complete();
	        }));
	    });
	}
	every.every = every$1;
	
	return every;
}

var exhaust = {};

var exhaustAll = {};

var exhaustMap = {};

var hasRequiredExhaustMap;

function requireExhaustMap () {
	if (hasRequiredExhaustMap) return exhaustMap;
	hasRequiredExhaustMap = 1;
	Object.defineProperty(exhaustMap, "__esModule", { value: true });
	exhaustMap.exhaustMap = void 0;
	var map_1 = /*@__PURE__*/ requireMap();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function exhaustMap$1(project, resultSelector) {
	    if (resultSelector) {
	        return function (source) {
	            return source.pipe(exhaustMap$1(function (a, i) { return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }));
	        };
	    }
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        var innerSub = null;
	        var isComplete = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (outerValue) {
	            if (!innerSub) {
	                innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {
	                    innerSub = null;
	                    isComplete && subscriber.complete();
	                });
	                innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
	            }
	        }, function () {
	            isComplete = true;
	            !innerSub && subscriber.complete();
	        }));
	    });
	}
	exhaustMap.exhaustMap = exhaustMap$1;
	
	return exhaustMap;
}

var hasRequiredExhaustAll;

function requireExhaustAll () {
	if (hasRequiredExhaustAll) return exhaustAll;
	hasRequiredExhaustAll = 1;
	Object.defineProperty(exhaustAll, "__esModule", { value: true });
	exhaustAll.exhaustAll = void 0;
	var exhaustMap_1 = /*@__PURE__*/ requireExhaustMap();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function exhaustAll$1() {
	    return exhaustMap_1.exhaustMap(identity_1.identity);
	}
	exhaustAll.exhaustAll = exhaustAll$1;
	
	return exhaustAll;
}

var hasRequiredExhaust;

function requireExhaust () {
	if (hasRequiredExhaust) return exhaust;
	hasRequiredExhaust = 1;
	Object.defineProperty(exhaust, "__esModule", { value: true });
	exhaust.exhaust = void 0;
	var exhaustAll_1 = /*@__PURE__*/ requireExhaustAll();
	exhaust.exhaust = exhaustAll_1.exhaustAll;
	
	return exhaust;
}

var expand = {};

var hasRequiredExpand;

function requireExpand () {
	if (hasRequiredExpand) return expand;
	hasRequiredExpand = 1;
	Object.defineProperty(expand, "__esModule", { value: true });
	expand.expand = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeInternals_1 = /*@__PURE__*/ requireMergeInternals();
	function expand$1(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
	    return lift_1.operate(function (source, subscriber) {
	        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
	    });
	}
	expand.expand = expand$1;
	
	return expand;
}

var finalize = {};

var hasRequiredFinalize;

function requireFinalize () {
	if (hasRequiredFinalize) return finalize;
	hasRequiredFinalize = 1;
	Object.defineProperty(finalize, "__esModule", { value: true });
	finalize.finalize = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	function finalize$1(callback) {
	    return lift_1.operate(function (source, subscriber) {
	        try {
	            source.subscribe(subscriber);
	        }
	        finally {
	            subscriber.add(callback);
	        }
	    });
	}
	finalize.finalize = finalize$1;
	
	return finalize;
}

var find = {};

var hasRequiredFind;

function requireFind () {
	if (hasRequiredFind) return find;
	hasRequiredFind = 1;
	Object.defineProperty(find, "__esModule", { value: true });
	find.createFind = find.find = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function find$1(predicate, thisArg) {
	    return lift_1.operate(createFind(predicate, thisArg, 'value'));
	}
	find.find = find$1;
	function createFind(predicate, thisArg, emit) {
	    var findIndex = emit === 'index';
	    return function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var i = index++;
	            if (predicate.call(thisArg, value, i, source)) {
	                subscriber.next(findIndex ? i : value);
	                subscriber.complete();
	            }
	        }, function () {
	            subscriber.next(findIndex ? -1 : undefined);
	            subscriber.complete();
	        }));
	    };
	}
	find.createFind = createFind;
	
	return find;
}

var findIndex = {};

var hasRequiredFindIndex;

function requireFindIndex () {
	if (hasRequiredFindIndex) return findIndex;
	hasRequiredFindIndex = 1;
	Object.defineProperty(findIndex, "__esModule", { value: true });
	findIndex.findIndex = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var find_1 = /*@__PURE__*/ requireFind();
	function findIndex$1(predicate, thisArg) {
	    return lift_1.operate(find_1.createFind(predicate, thisArg, 'index'));
	}
	findIndex.findIndex = findIndex$1;
	
	return findIndex;
}

var first = {};

var hasRequiredFirst;

function requireFirst () {
	if (hasRequiredFirst) return first;
	hasRequiredFirst = 1;
	Object.defineProperty(first, "__esModule", { value: true });
	first.first = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var filter_1 = /*@__PURE__*/ requireFilter();
	var take_1 = /*@__PURE__*/ requireTake();
	var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
	var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function first$1(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); }));
	    };
	}
	first.first = first$1;
	
	return first;
}

var groupBy = {};

var hasRequiredGroupBy;

function requireGroupBy () {
	if (hasRequiredGroupBy) return groupBy;
	hasRequiredGroupBy = 1;
	Object.defineProperty(groupBy, "__esModule", { value: true });
	groupBy.groupBy = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function groupBy$1(keySelector, elementOrOptions, duration, connector) {
	    return lift_1.operate(function (source, subscriber) {
	        var element;
	        if (!elementOrOptions || typeof elementOrOptions === 'function') {
	            element = elementOrOptions;
	        }
	        else {
	            (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
	        }
	        var groups = new Map();
	        var notify = function (cb) {
	            groups.forEach(cb);
	            cb(subscriber);
	        };
	        var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
	        var activeGroups = 0;
	        var teardownAttempted = false;
	        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function (value) {
	            try {
	                var key_1 = keySelector(value);
	                var group_1 = groups.get(key_1);
	                if (!group_1) {
	                    groups.set(key_1, (group_1 = connector ? connector() : new Subject_1.Subject()));
	                    var grouped = createGroupedObservable(key_1, group_1);
	                    subscriber.next(grouped);
	                    if (duration) {
	                        var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function () {
	                            group_1.complete();
	                            durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
	                        }, undefined, undefined, function () { return groups.delete(key_1); });
	                        groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
	                    }
	                }
	                group_1.next(element ? element(value) : value);
	            }
	            catch (err) {
	                handleError(err);
	            }
	        }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); }, function () {
	            teardownAttempted = true;
	            return activeGroups === 0;
	        });
	        source.subscribe(groupBySourceSubscriber);
	        function createGroupedObservable(key, groupSubject) {
	            var result = new Observable_1.Observable(function (groupSubscriber) {
	                activeGroups++;
	                var innerSub = groupSubject.subscribe(groupSubscriber);
	                return function () {
	                    innerSub.unsubscribe();
	                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
	                };
	            });
	            result.key = key;
	            return result;
	        }
	    });
	}
	groupBy.groupBy = groupBy$1;
	
	return groupBy;
}

var isEmpty = {};

var hasRequiredIsEmpty;

function requireIsEmpty () {
	if (hasRequiredIsEmpty) return isEmpty;
	hasRequiredIsEmpty = 1;
	Object.defineProperty(isEmpty, "__esModule", { value: true });
	isEmpty.isEmpty = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function isEmpty$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            subscriber.next(false);
	            subscriber.complete();
	        }, function () {
	            subscriber.next(true);
	            subscriber.complete();
	        }));
	    });
	}
	isEmpty.isEmpty = isEmpty$1;
	
	return isEmpty;
}

var last = {};

var takeLast = {};

var hasRequiredTakeLast;

function requireTakeLast () {
	if (hasRequiredTakeLast) return takeLast;
	hasRequiredTakeLast = 1;
	var __values = (takeLast && takeLast.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(takeLast, "__esModule", { value: true });
	takeLast.takeLast = void 0;
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function takeLast$1(count) {
	    return count <= 0
	        ? function () { return empty_1.EMPTY; }
	        : lift_1.operate(function (source, subscriber) {
	            var buffer = [];
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                buffer.push(value);
	                count < buffer.length && buffer.shift();
	            }, function () {
	                var e_1, _a;
	                try {
	                    for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
	                        var value = buffer_1_1.value;
	                        subscriber.next(value);
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	                subscriber.complete();
	            }, undefined, function () {
	                buffer = null;
	            }));
	        });
	}
	takeLast.takeLast = takeLast$1;
	
	return takeLast;
}

var hasRequiredLast;

function requireLast () {
	if (hasRequiredLast) return last;
	hasRequiredLast = 1;
	Object.defineProperty(last, "__esModule", { value: true });
	last.last = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var filter_1 = /*@__PURE__*/ requireFilter();
	var takeLast_1 = /*@__PURE__*/ requireTakeLast();
	var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
	var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function last$1(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); }));
	    };
	}
	last.last = last$1;
	
	return last;
}

var materialize = {};

var hasRequiredMaterialize;

function requireMaterialize () {
	if (hasRequiredMaterialize) return materialize;
	hasRequiredMaterialize = 1;
	Object.defineProperty(materialize, "__esModule", { value: true });
	materialize.materialize = void 0;
	var Notification_1 = /*@__PURE__*/ requireNotification();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function materialize$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            subscriber.next(Notification_1.Notification.createNext(value));
	        }, function () {
	            subscriber.next(Notification_1.Notification.createComplete());
	            subscriber.complete();
	        }, function (err) {
	            subscriber.next(Notification_1.Notification.createError(err));
	            subscriber.complete();
	        }));
	    });
	}
	materialize.materialize = materialize$1;
	
	return materialize;
}

var max = {};

var hasRequiredMax;

function requireMax () {
	if (hasRequiredMax) return max;
	hasRequiredMax = 1;
	Object.defineProperty(max, "__esModule", { value: true });
	max.max = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function max$1(comparer) {
	    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });
	}
	max.max = max$1;
	
	return max;
}

var flatMap = {};

var hasRequiredFlatMap;

function requireFlatMap () {
	if (hasRequiredFlatMap) return flatMap;
	hasRequiredFlatMap = 1;
	Object.defineProperty(flatMap, "__esModule", { value: true });
	flatMap.flatMap = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	flatMap.flatMap = mergeMap_1.mergeMap;
	
	return flatMap;
}

var mergeMapTo = {};

var hasRequiredMergeMapTo;

function requireMergeMapTo () {
	if (hasRequiredMergeMapTo) return mergeMapTo;
	hasRequiredMergeMapTo = 1;
	Object.defineProperty(mergeMapTo, "__esModule", { value: true });
	mergeMapTo.mergeMapTo = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function mergeMapTo$1(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    if (isFunction_1.isFunction(resultSelector)) {
	        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
	    }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);
	}
	mergeMapTo.mergeMapTo = mergeMapTo$1;
	
	return mergeMapTo;
}

var mergeScan = {};

var hasRequiredMergeScan;

function requireMergeScan () {
	if (hasRequiredMergeScan) return mergeScan;
	hasRequiredMergeScan = 1;
	Object.defineProperty(mergeScan, "__esModule", { value: true });
	mergeScan.mergeScan = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeInternals_1 = /*@__PURE__*/ requireMergeInternals();
	function mergeScan$1(accumulator, seed, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    return lift_1.operate(function (source, subscriber) {
	        var state = seed;
	        return mergeInternals_1.mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {
	            state = value;
	        }, false, undefined, function () { return (state = null); });
	    });
	}
	mergeScan.mergeScan = mergeScan$1;
	
	return mergeScan;
}

var mergeWith = {};

var merge = {};

var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge;
	hasRequiredMerge = 1;
	var __read = (merge && merge.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (merge && merge.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(merge, "__esModule", { value: true });
	merge.merge = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom();
	function merge$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    var concurrent = args_1.popNumber(args, Infinity);
	    return lift_1.operate(function (source, subscriber) {
	        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
	    });
	}
	merge.merge = merge$1;
	
	return merge;
}

var hasRequiredMergeWith;

function requireMergeWith () {
	if (hasRequiredMergeWith) return mergeWith;
	hasRequiredMergeWith = 1;
	var __read = (mergeWith && mergeWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (mergeWith && mergeWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(mergeWith, "__esModule", { value: true });
	mergeWith.mergeWith = void 0;
	var merge_1 = /*@__PURE__*/ requireMerge();
	function mergeWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));
	}
	mergeWith.mergeWith = mergeWith$1;
	
	return mergeWith;
}

var min = {};

var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min;
	hasRequiredMin = 1;
	Object.defineProperty(min, "__esModule", { value: true });
	min.min = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function min$1(comparer) {
	    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });
	}
	min.min = min$1;
	
	return min;
}

var multicast = {};

var hasRequiredMulticast;

function requireMulticast () {
	if (hasRequiredMulticast) return multicast;
	hasRequiredMulticast = 1;
	Object.defineProperty(multicast, "__esModule", { value: true });
	multicast.multicast = void 0;
	var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var connect_1 = /*@__PURE__*/ requireConnect();
	function multicast$1(subjectOrSubjectFactory, selector) {
	    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };
	    if (isFunction_1.isFunction(selector)) {
	        return connect_1.connect(selector, {
	            connector: subjectFactory,
	        });
	    }
	    return function (source) { return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory); };
	}
	multicast.multicast = multicast$1;
	
	return multicast;
}

var onErrorResumeNextWith = {};

var hasRequiredOnErrorResumeNextWith;

function requireOnErrorResumeNextWith () {
	if (hasRequiredOnErrorResumeNextWith) return onErrorResumeNextWith;
	hasRequiredOnErrorResumeNextWith = 1;
	var __read = (onErrorResumeNextWith && onErrorResumeNextWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (onErrorResumeNextWith && onErrorResumeNextWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(onErrorResumeNextWith, "__esModule", { value: true });
	onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith.onErrorResumeNextWith = void 0;
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var onErrorResumeNext_1 = /*@__PURE__*/ requireOnErrorResumeNext();
	function onErrorResumeNextWith$1() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
	    return function (source) { return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources))); };
	}
	onErrorResumeNextWith.onErrorResumeNextWith = onErrorResumeNextWith$1;
	onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith$1;
	
	return onErrorResumeNextWith;
}

var pairwise = {};

var hasRequiredPairwise;

function requirePairwise () {
	if (hasRequiredPairwise) return pairwise;
	hasRequiredPairwise = 1;
	Object.defineProperty(pairwise, "__esModule", { value: true });
	pairwise.pairwise = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function pairwise$1() {
	    return lift_1.operate(function (source, subscriber) {
	        var prev;
	        var hasPrev = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var p = prev;
	            prev = value;
	            hasPrev && subscriber.next([p, value]);
	            hasPrev = true;
	        }));
	    });
	}
	pairwise.pairwise = pairwise$1;
	
	return pairwise;
}

var pluck = {};

var hasRequiredPluck;

function requirePluck () {
	if (hasRequiredPluck) return pluck;
	hasRequiredPluck = 1;
	Object.defineProperty(pluck, "__esModule", { value: true });
	pluck.pluck = void 0;
	var map_1 = /*@__PURE__*/ requireMap();
	function pluck$1() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return map_1.map(function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    });
	}
	pluck.pluck = pluck$1;
	
	return pluck;
}

var publish = {};

var hasRequiredPublish;

function requirePublish () {
	if (hasRequiredPublish) return publish;
	hasRequiredPublish = 1;
	Object.defineProperty(publish, "__esModule", { value: true });
	publish.publish = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var multicast_1 = /*@__PURE__*/ requireMulticast();
	var connect_1 = /*@__PURE__*/ requireConnect();
	function publish$1(selector) {
	    return selector ? function (source) { return connect_1.connect(selector)(source); } : function (source) { return multicast_1.multicast(new Subject_1.Subject())(source); };
	}
	publish.publish = publish$1;
	
	return publish;
}

var publishBehavior = {};

var hasRequiredPublishBehavior;

function requirePublishBehavior () {
	if (hasRequiredPublishBehavior) return publishBehavior;
	hasRequiredPublishBehavior = 1;
	Object.defineProperty(publishBehavior, "__esModule", { value: true });
	publishBehavior.publishBehavior = void 0;
	var BehaviorSubject_1 = /*@__PURE__*/ requireBehaviorSubject();
	var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
	function publishBehavior$1(initialValue) {
	    return function (source) {
	        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
	        return new ConnectableObservable_1.ConnectableObservable(source, function () { return subject; });
	    };
	}
	publishBehavior.publishBehavior = publishBehavior$1;
	
	return publishBehavior;
}

var publishLast = {};

var hasRequiredPublishLast;

function requirePublishLast () {
	if (hasRequiredPublishLast) return publishLast;
	hasRequiredPublishLast = 1;
	Object.defineProperty(publishLast, "__esModule", { value: true });
	publishLast.publishLast = void 0;
	var AsyncSubject_1 = /*@__PURE__*/ requireAsyncSubject();
	var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
	function publishLast$1() {
	    return function (source) {
	        var subject = new AsyncSubject_1.AsyncSubject();
	        return new ConnectableObservable_1.ConnectableObservable(source, function () { return subject; });
	    };
	}
	publishLast.publishLast = publishLast$1;
	
	return publishLast;
}

var publishReplay = {};

var hasRequiredPublishReplay;

function requirePublishReplay () {
	if (hasRequiredPublishReplay) return publishReplay;
	hasRequiredPublishReplay = 1;
	Object.defineProperty(publishReplay, "__esModule", { value: true });
	publishReplay.publishReplay = void 0;
	var ReplaySubject_1 = /*@__PURE__*/ requireReplaySubject();
	var multicast_1 = /*@__PURE__*/ requireMulticast();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function publishReplay$1(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
	    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
	        timestampProvider = selectorOrScheduler;
	    }
	    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
	    return function (source) { return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source); };
	}
	publishReplay.publishReplay = publishReplay$1;
	
	return publishReplay;
}

var raceWith = {};

var hasRequiredRaceWith;

function requireRaceWith () {
	if (hasRequiredRaceWith) return raceWith;
	hasRequiredRaceWith = 1;
	var __read = (raceWith && raceWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (raceWith && raceWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(raceWith, "__esModule", { value: true });
	raceWith.raceWith = void 0;
	var race_1 = /*@__PURE__*/ requireRace$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function raceWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return !otherSources.length
	        ? identity_1.identity
	        : lift_1.operate(function (source, subscriber) {
	            race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
	        });
	}
	raceWith.raceWith = raceWith$1;
	
	return raceWith;
}

var repeat = {};

var hasRequiredRepeat;

function requireRepeat () {
	if (hasRequiredRepeat) return repeat;
	hasRequiredRepeat = 1;
	Object.defineProperty(repeat, "__esModule", { value: true });
	repeat.repeat = void 0;
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function repeat$1(countOrConfig) {
	    var _a;
	    var count = Infinity;
	    var delay;
	    if (countOrConfig != null) {
	        if (typeof countOrConfig === 'object') {
	            (_a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay);
	        }
	        else {
	            count = countOrConfig;
	        }
	    }
	    return count <= 0
	        ? function () { return empty_1.EMPTY; }
	        : lift_1.operate(function (source, subscriber) {
	            var soFar = 0;
	            var sourceSub;
	            var resubscribe = function () {
	                sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
	                sourceSub = null;
	                if (delay != null) {
	                    var notifier = typeof delay === 'number' ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
	                    var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                        notifierSubscriber_1.unsubscribe();
	                        subscribeToSource();
	                    });
	                    notifier.subscribe(notifierSubscriber_1);
	                }
	                else {
	                    subscribeToSource();
	                }
	            };
	            var subscribeToSource = function () {
	                var syncUnsub = false;
	                sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {
	                    if (++soFar < count) {
	                        if (sourceSub) {
	                            resubscribe();
	                        }
	                        else {
	                            syncUnsub = true;
	                        }
	                    }
	                    else {
	                        subscriber.complete();
	                    }
	                }));
	                if (syncUnsub) {
	                    resubscribe();
	                }
	            };
	            subscribeToSource();
	        });
	}
	repeat.repeat = repeat$1;
	
	return repeat;
}

var repeatWhen = {};

var hasRequiredRepeatWhen;

function requireRepeatWhen () {
	if (hasRequiredRepeatWhen) return repeatWhen;
	hasRequiredRepeatWhen = 1;
	Object.defineProperty(repeatWhen, "__esModule", { value: true });
	repeatWhen.repeatWhen = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function repeatWhen$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSub;
	        var syncResub = false;
	        var completions$;
	        var isNotifierComplete = false;
	        var isMainComplete = false;
	        var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };
	        var getCompletionSubject = function () {
	            if (!completions$) {
	                completions$ = new Subject_1.Subject();
	                innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                    if (innerSub) {
	                        subscribeForRepeatWhen();
	                    }
	                    else {
	                        syncResub = true;
	                    }
	                }, function () {
	                    isNotifierComplete = true;
	                    checkComplete();
	                }));
	            }
	            return completions$;
	        };
	        var subscribeForRepeatWhen = function () {
	            isMainComplete = false;
	            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {
	                isMainComplete = true;
	                !checkComplete() && getCompletionSubject().next();
	            }));
	            if (syncResub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                syncResub = false;
	                subscribeForRepeatWhen();
	            }
	        };
	        subscribeForRepeatWhen();
	    });
	}
	repeatWhen.repeatWhen = repeatWhen$1;
	
	return repeatWhen;
}

var retry = {};

var hasRequiredRetry;

function requireRetry () {
	if (hasRequiredRetry) return retry;
	hasRequiredRetry = 1;
	Object.defineProperty(retry, "__esModule", { value: true });
	retry.retry = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var timer_1 = /*@__PURE__*/ requireTimer();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function retry$1(configOrCount) {
	    if (configOrCount === void 0) { configOrCount = Infinity; }
	    var config;
	    if (configOrCount && typeof configOrCount === 'object') {
	        config = configOrCount;
	    }
	    else {
	        config = {
	            count: configOrCount,
	        };
	    }
	    var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
	    return count <= 0
	        ? identity_1.identity
	        : lift_1.operate(function (source, subscriber) {
	            var soFar = 0;
	            var innerSub;
	            var subscribeForRetry = function () {
	                var syncUnsub = false;
	                innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                    if (resetOnSuccess) {
	                        soFar = 0;
	                    }
	                    subscriber.next(value);
	                }, undefined, function (err) {
	                    if (soFar++ < count) {
	                        var resub_1 = function () {
	                            if (innerSub) {
	                                innerSub.unsubscribe();
	                                innerSub = null;
	                                subscribeForRetry();
	                            }
	                            else {
	                                syncUnsub = true;
	                            }
	                        };
	                        if (delay != null) {
	                            var notifier = typeof delay === 'number' ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
	                            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                                notifierSubscriber_1.unsubscribe();
	                                resub_1();
	                            }, function () {
	                                subscriber.complete();
	                            });
	                            notifier.subscribe(notifierSubscriber_1);
	                        }
	                        else {
	                            resub_1();
	                        }
	                    }
	                    else {
	                        subscriber.error(err);
	                    }
	                }));
	                if (syncUnsub) {
	                    innerSub.unsubscribe();
	                    innerSub = null;
	                    subscribeForRetry();
	                }
	            };
	            subscribeForRetry();
	        });
	}
	retry.retry = retry$1;
	
	return retry;
}

var retryWhen = {};

var hasRequiredRetryWhen;

function requireRetryWhen () {
	if (hasRequiredRetryWhen) return retryWhen;
	hasRequiredRetryWhen = 1;
	Object.defineProperty(retryWhen, "__esModule", { value: true });
	retryWhen.retryWhen = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function retryWhen$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSub;
	        var syncResub = false;
	        var errors$;
	        var subscribeForRetryWhen = function () {
	            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	                if (!errors$) {
	                    errors$ = new Subject_1.Subject();
	                    innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                        return innerSub ? subscribeForRetryWhen() : (syncResub = true);
	                    }));
	                }
	                if (errors$) {
	                    errors$.next(err);
	                }
	            }));
	            if (syncResub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                syncResub = false;
	                subscribeForRetryWhen();
	            }
	        };
	        subscribeForRetryWhen();
	    });
	}
	retryWhen.retryWhen = retryWhen$1;
	
	return retryWhen;
}

var sample = {};

var hasRequiredSample;

function requireSample () {
	if (hasRequiredSample) return sample;
	hasRequiredSample = 1;
	Object.defineProperty(sample, "__esModule", { value: true });
	sample.sample = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function sample$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            lastValue = value;
	        }));
	        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        }, noop_1.noop));
	    });
	}
	sample.sample = sample$1;
	
	return sample;
}

var sampleTime = {};

var hasRequiredSampleTime;

function requireSampleTime () {
	if (hasRequiredSampleTime) return sampleTime;
	hasRequiredSampleTime = 1;
	Object.defineProperty(sampleTime, "__esModule", { value: true });
	sampleTime.sampleTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var sample_1 = /*@__PURE__*/ requireSample();
	var interval_1 = /*@__PURE__*/ requireInterval();
	function sampleTime$1(period, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return sample_1.sample(interval_1.interval(period, scheduler));
	}
	sampleTime.sampleTime = sampleTime$1;
	
	return sampleTime;
}

var scan = {};

var hasRequiredScan;

function requireScan () {
	if (hasRequiredScan) return scan;
	hasRequiredScan = 1;
	Object.defineProperty(scan, "__esModule", { value: true });
	scan.scan = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var scanInternals_1 = /*@__PURE__*/ requireScanInternals();
	function scan$1(accumulator, seed) {
	    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
	}
	scan.scan = scan$1;
	
	return scan;
}

var sequenceEqual = {};

var hasRequiredSequenceEqual;

function requireSequenceEqual () {
	if (hasRequiredSequenceEqual) return sequenceEqual;
	hasRequiredSequenceEqual = 1;
	Object.defineProperty(sequenceEqual, "__esModule", { value: true });
	sequenceEqual.sequenceEqual = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function sequenceEqual$1(compareTo, comparator) {
	    if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
	    return lift_1.operate(function (source, subscriber) {
	        var aState = createState();
	        var bState = createState();
	        var emit = function (isEqual) {
	            subscriber.next(isEqual);
	            subscriber.complete();
	        };
	        var createSubscriber = function (selfState, otherState) {
	            var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (a) {
	                var buffer = otherState.buffer, complete = otherState.complete;
	                if (buffer.length === 0) {
	                    complete ? emit(false) : selfState.buffer.push(a);
	                }
	                else {
	                    !comparator(a, buffer.shift()) && emit(false);
	                }
	            }, function () {
	                selfState.complete = true;
	                var complete = otherState.complete, buffer = otherState.buffer;
	                complete && emit(buffer.length === 0);
	                sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
	            });
	            return sequenceEqualSubscriber;
	        };
	        source.subscribe(createSubscriber(aState, bState));
	        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
	    });
	}
	sequenceEqual.sequenceEqual = sequenceEqual$1;
	function createState() {
	    return {
	        buffer: [],
	        complete: false,
	    };
	}
	
	return sequenceEqual;
}

var share = {};

var hasRequiredShare;

function requireShare () {
	if (hasRequiredShare) return share;
	hasRequiredShare = 1;
	var __read = (share && share.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (share && share.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(share, "__esModule", { value: true });
	share.share = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	var lift_1 = /*@__PURE__*/ requireLift();
	function share$1(options) {
	    if (options === void 0) { options = {}; }
	    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject_1.Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
	    return function (wrapperSource) {
	        var connection;
	        var resetConnection;
	        var subject;
	        var refCount = 0;
	        var hasCompleted = false;
	        var hasErrored = false;
	        var cancelReset = function () {
	            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
	            resetConnection = undefined;
	        };
	        var reset = function () {
	            cancelReset();
	            connection = subject = undefined;
	            hasCompleted = hasErrored = false;
	        };
	        var resetAndUnsubscribe = function () {
	            var conn = connection;
	            reset();
	            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
	        };
	        return lift_1.operate(function (source, subscriber) {
	            refCount++;
	            if (!hasErrored && !hasCompleted) {
	                cancelReset();
	            }
	            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
	            subscriber.add(function () {
	                refCount--;
	                if (refCount === 0 && !hasErrored && !hasCompleted) {
	                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
	                }
	            });
	            dest.subscribe(subscriber);
	            if (!connection &&
	                refCount > 0) {
	                connection = new Subscriber_1.SafeSubscriber({
	                    next: function (value) { return dest.next(value); },
	                    error: function (err) {
	                        hasErrored = true;
	                        cancelReset();
	                        resetConnection = handleReset(reset, resetOnError, err);
	                        dest.error(err);
	                    },
	                    complete: function () {
	                        hasCompleted = true;
	                        cancelReset();
	                        resetConnection = handleReset(reset, resetOnComplete);
	                        dest.complete();
	                    },
	                });
	                innerFrom_1.innerFrom(source).subscribe(connection);
	            }
	        })(wrapperSource);
	    };
	}
	share.share = share$1;
	function handleReset(reset, on) {
	    var args = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	    }
	    if (on === true) {
	        reset();
	        return;
	    }
	    if (on === false) {
	        return;
	    }
	    var onSubscriber = new Subscriber_1.SafeSubscriber({
	        next: function () {
	            onSubscriber.unsubscribe();
	            reset();
	        },
	    });
	    return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
	}
	
	return share;
}

var shareReplay = {};

var hasRequiredShareReplay;

function requireShareReplay () {
	if (hasRequiredShareReplay) return shareReplay;
	hasRequiredShareReplay = 1;
	Object.defineProperty(shareReplay, "__esModule", { value: true });
	shareReplay.shareReplay = void 0;
	var ReplaySubject_1 = /*@__PURE__*/ requireReplaySubject();
	var share_1 = /*@__PURE__*/ requireShare();
	function shareReplay$1(configOrBufferSize, windowTime, scheduler) {
	    var _a, _b, _c;
	    var bufferSize;
	    var refCount = false;
	    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
	        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);
	    }
	    else {
	        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);
	    }
	    return share_1.share({
	        connector: function () { return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler); },
	        resetOnError: true,
	        resetOnComplete: false,
	        resetOnRefCountZero: refCount,
	    });
	}
	shareReplay.shareReplay = shareReplay$1;
	
	return shareReplay;
}

var single = {};

var hasRequiredSingle;

function requireSingle () {
	if (hasRequiredSingle) return single;
	hasRequiredSingle = 1;
	Object.defineProperty(single, "__esModule", { value: true });
	single.single = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var SequenceError_1 = /*@__PURE__*/ requireSequenceError();
	var NotFoundError_1 = /*@__PURE__*/ requireNotFoundError();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function single$1(predicate) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var singleValue;
	        var seenValue = false;
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            seenValue = true;
	            if (!predicate || predicate(value, index++, source)) {
	                hasValue && subscriber.error(new SequenceError_1.SequenceError('Too many matching values'));
	                hasValue = true;
	                singleValue = value;
	            }
	        }, function () {
	            if (hasValue) {
	                subscriber.next(singleValue);
	                subscriber.complete();
	            }
	            else {
	                subscriber.error(seenValue ? new NotFoundError_1.NotFoundError('No matching values') : new EmptyError_1.EmptyError());
	            }
	        }));
	    });
	}
	single.single = single$1;
	
	return single;
}

var skip = {};

var hasRequiredSkip;

function requireSkip () {
	if (hasRequiredSkip) return skip;
	hasRequiredSkip = 1;
	Object.defineProperty(skip, "__esModule", { value: true });
	skip.skip = void 0;
	var filter_1 = /*@__PURE__*/ requireFilter();
	function skip$1(count) {
	    return filter_1.filter(function (_, index) { return count <= index; });
	}
	skip.skip = skip$1;
	
	return skip;
}

var skipLast = {};

var hasRequiredSkipLast;

function requireSkipLast () {
	if (hasRequiredSkipLast) return skipLast;
	hasRequiredSkipLast = 1;
	Object.defineProperty(skipLast, "__esModule", { value: true });
	skipLast.skipLast = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function skipLast$1(skipCount) {
	    return skipCount <= 0
	        ?
	            identity_1.identity
	        : lift_1.operate(function (source, subscriber) {
	            var ring = new Array(skipCount);
	            var seen = 0;
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                var valueIndex = seen++;
	                if (valueIndex < skipCount) {
	                    ring[valueIndex] = value;
	                }
	                else {
	                    var index = valueIndex % skipCount;
	                    var oldValue = ring[index];
	                    ring[index] = value;
	                    subscriber.next(oldValue);
	                }
	            }));
	            return function () {
	                ring = null;
	            };
	        });
	}
	skipLast.skipLast = skipLast$1;
	
	return skipLast;
}

var skipUntil = {};

var hasRequiredSkipUntil;

function requireSkipUntil () {
	if (hasRequiredSkipUntil) return skipUntil;
	hasRequiredSkipUntil = 1;
	Object.defineProperty(skipUntil, "__esModule", { value: true });
	skipUntil.skipUntil = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var noop_1 = /*@__PURE__*/ requireNoop();
	function skipUntil$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var taking = false;
	        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
	            taking = true;
	        }, noop_1.noop);
	        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));
	    });
	}
	skipUntil.skipUntil = skipUntil$1;
	
	return skipUntil;
}

var skipWhile = {};

var hasRequiredSkipWhile;

function requireSkipWhile () {
	if (hasRequiredSkipWhile) return skipWhile;
	hasRequiredSkipWhile = 1;
	Object.defineProperty(skipWhile, "__esModule", { value: true });
	skipWhile.skipWhile = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function skipWhile$1(predicate) {
	    return lift_1.operate(function (source, subscriber) {
	        var taking = false;
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));
	    });
	}
	skipWhile.skipWhile = skipWhile$1;
	
	return skipWhile;
}

var startWith = {};

var hasRequiredStartWith;

function requireStartWith () {
	if (hasRequiredStartWith) return startWith;
	hasRequiredStartWith = 1;
	Object.defineProperty(startWith, "__esModule", { value: true });
	startWith.startWith = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat$1();
	var args_1 = /*@__PURE__*/ requireArgs();
	var lift_1 = /*@__PURE__*/ requireLift();
	function startWith$1() {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(values);
	    return lift_1.operate(function (source, subscriber) {
	        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
	    });
	}
	startWith.startWith = startWith$1;
	
	return startWith;
}

var switchAll = {};

var switchMap = {};

var hasRequiredSwitchMap;

function requireSwitchMap () {
	if (hasRequiredSwitchMap) return switchMap;
	hasRequiredSwitchMap = 1;
	Object.defineProperty(switchMap, "__esModule", { value: true });
	switchMap.switchMap = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function switchMap$1(project, resultSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSubscriber = null;
	        var index = 0;
	        var isComplete = false;
	        var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
	            var innerIndex = 0;
	            var outerIndex = index++;
	            innerFrom_1.innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
	                innerSubscriber = null;
	                checkComplete();
	            })));
	        }, function () {
	            isComplete = true;
	            checkComplete();
	        }));
	    });
	}
	switchMap.switchMap = switchMap$1;
	
	return switchMap;
}

var hasRequiredSwitchAll;

function requireSwitchAll () {
	if (hasRequiredSwitchAll) return switchAll;
	hasRequiredSwitchAll = 1;
	Object.defineProperty(switchAll, "__esModule", { value: true });
	switchAll.switchAll = void 0;
	var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function switchAll$1() {
	    return switchMap_1.switchMap(identity_1.identity);
	}
	switchAll.switchAll = switchAll$1;
	
	return switchAll;
}

var switchMapTo = {};

var hasRequiredSwitchMapTo;

function requireSwitchMapTo () {
	if (hasRequiredSwitchMapTo) return switchMapTo;
	hasRequiredSwitchMapTo = 1;
	Object.defineProperty(switchMapTo, "__esModule", { value: true });
	switchMapTo.switchMapTo = void 0;
	var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function switchMapTo$1(innerObservable, resultSelector) {
	    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });
	}
	switchMapTo.switchMapTo = switchMapTo$1;
	
	return switchMapTo;
}

var switchScan = {};

var hasRequiredSwitchScan;

function requireSwitchScan () {
	if (hasRequiredSwitchScan) return switchScan;
	hasRequiredSwitchScan = 1;
	Object.defineProperty(switchScan, "__esModule", { value: true });
	switchScan.switchScan = void 0;
	var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
	var lift_1 = /*@__PURE__*/ requireLift();
	function switchScan$1(accumulator, seed) {
	    return lift_1.operate(function (source, subscriber) {
	        var state = seed;
	        switchMap_1.switchMap(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);
	        return function () {
	            state = null;
	        };
	    });
	}
	switchScan.switchScan = switchScan$1;
	
	return switchScan;
}

var takeUntil = {};

var hasRequiredTakeUntil;

function requireTakeUntil () {
	if (hasRequiredTakeUntil) return takeUntil;
	hasRequiredTakeUntil = 1;
	Object.defineProperty(takeUntil, "__esModule", { value: true });
	takeUntil.takeUntil = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var noop_1 = /*@__PURE__*/ requireNoop();
	function takeUntil$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop_1.noop));
	        !subscriber.closed && source.subscribe(subscriber);
	    });
	}
	takeUntil.takeUntil = takeUntil$1;
	
	return takeUntil;
}

var takeWhile = {};

var hasRequiredTakeWhile;

function requireTakeWhile () {
	if (hasRequiredTakeWhile) return takeWhile;
	hasRequiredTakeWhile = 1;
	Object.defineProperty(takeWhile, "__esModule", { value: true });
	takeWhile.takeWhile = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function takeWhile$1(predicate, inclusive) {
	    if (inclusive === void 0) { inclusive = false; }
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var result = predicate(value, index++);
	            (result || inclusive) && subscriber.next(value);
	            !result && subscriber.complete();
	        }));
	    });
	}
	takeWhile.takeWhile = takeWhile$1;
	
	return takeWhile;
}

var tap = {};

var hasRequiredTap;

function requireTap () {
	if (hasRequiredTap) return tap;
	hasRequiredTap = 1;
	Object.defineProperty(tap, "__esModule", { value: true });
	tap.tap = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	function tap$1(observerOrNext, error, complete) {
	    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete
	        ?
	            { next: observerOrNext, error: error, complete: complete }
	        : observerOrNext;
	    return tapObserver
	        ? lift_1.operate(function (source, subscriber) {
	            var _a;
	            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	            var isUnsub = true;
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                var _a;
	                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
	                subscriber.next(value);
	            }, function () {
	                var _a;
	                isUnsub = false;
	                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	                subscriber.complete();
	            }, function (err) {
	                var _a;
	                isUnsub = false;
	                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
	                subscriber.error(err);
	            }, function () {
	                var _a, _b;
	                if (isUnsub) {
	                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	                }
	                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
	            }));
	        })
	        :
	            identity_1.identity;
	}
	tap.tap = tap$1;
	
	return tap;
}

var throttle = {};

var hasRequiredThrottle;

function requireThrottle () {
	if (hasRequiredThrottle) return throttle;
	hasRequiredThrottle = 1;
	Object.defineProperty(throttle, "__esModule", { value: true });
	throttle.throttle = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function throttle$1(durationSelector, config) {
	    return lift_1.operate(function (source, subscriber) {
	        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
	        var hasValue = false;
	        var sendValue = null;
	        var throttled = null;
	        var isComplete = false;
	        var endThrottling = function () {
	            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
	            throttled = null;
	            if (trailing) {
	                send();
	                isComplete && subscriber.complete();
	            }
	        };
	        var cleanupThrottling = function () {
	            throttled = null;
	            isComplete && subscriber.complete();
	        };
	        var startThrottle = function (value) {
	            return (throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
	        };
	        var send = function () {
	            if (hasValue) {
	                hasValue = false;
	                var value = sendValue;
	                sendValue = null;
	                subscriber.next(value);
	                !isComplete && startThrottle(value);
	            }
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            sendValue = value;
	            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
	        }, function () {
	            isComplete = true;
	            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
	        }));
	    });
	}
	throttle.throttle = throttle$1;
	
	return throttle;
}

var throttleTime = {};

var hasRequiredThrottleTime;

function requireThrottleTime () {
	if (hasRequiredThrottleTime) return throttleTime;
	hasRequiredThrottleTime = 1;
	Object.defineProperty(throttleTime, "__esModule", { value: true });
	throttleTime.throttleTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var throttle_1 = /*@__PURE__*/ requireThrottle();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function throttleTime$1(duration, scheduler, config) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    var duration$ = timer_1.timer(duration, scheduler);
	    return throttle_1.throttle(function () { return duration$; }, config);
	}
	throttleTime.throttleTime = throttleTime$1;
	
	return throttleTime;
}

var timeInterval = {};

var hasRequiredTimeInterval;

function requireTimeInterval () {
	if (hasRequiredTimeInterval) return timeInterval;
	hasRequiredTimeInterval = 1;
	Object.defineProperty(timeInterval, "__esModule", { value: true });
	timeInterval.TimeInterval = timeInterval.timeInterval = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function timeInterval$1(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return lift_1.operate(function (source, subscriber) {
	        var last = scheduler.now();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var now = scheduler.now();
	            var interval = now - last;
	            last = now;
	            subscriber.next(new TimeInterval(value, interval));
	        }));
	    });
	}
	timeInterval.timeInterval = timeInterval$1;
	var TimeInterval = (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());
	timeInterval.TimeInterval = TimeInterval;
	
	return timeInterval;
}

var timeoutWith = {};

var hasRequiredTimeoutWith;

function requireTimeoutWith () {
	if (hasRequiredTimeoutWith) return timeoutWith;
	hasRequiredTimeoutWith = 1;
	Object.defineProperty(timeoutWith, "__esModule", { value: true });
	timeoutWith.timeoutWith = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var isDate_1 = /*@__PURE__*/ requireIsDate();
	var timeout_1 = /*@__PURE__*/ requireTimeout();
	function timeoutWith$1(due, withObservable, scheduler) {
	    var first;
	    var each;
	    var _with;
	    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
	    if (isDate_1.isValidDate(due)) {
	        first = due;
	    }
	    else if (typeof due === 'number') {
	        each = due;
	    }
	    if (withObservable) {
	        _with = function () { return withObservable; };
	    }
	    else {
	        throw new TypeError('No observable provided to switch to');
	    }
	    if (first == null && each == null) {
	        throw new TypeError('No timeout provided.');
	    }
	    return timeout_1.timeout({
	        first: first,
	        each: each,
	        scheduler: scheduler,
	        with: _with,
	    });
	}
	timeoutWith.timeoutWith = timeoutWith$1;
	
	return timeoutWith;
}

var timestamp = {};

var hasRequiredTimestamp;

function requireTimestamp () {
	if (hasRequiredTimestamp) return timestamp;
	hasRequiredTimestamp = 1;
	Object.defineProperty(timestamp, "__esModule", { value: true });
	timestamp.timestamp = void 0;
	var dateTimestampProvider_1 = /*@__PURE__*/ requireDateTimestampProvider();
	var map_1 = /*@__PURE__*/ requireMap();
	function timestamp$1(timestampProvider) {
	    if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider_1.dateTimestampProvider; }
	    return map_1.map(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });
	}
	timestamp.timestamp = timestamp$1;
	
	return timestamp;
}

var window$1 = {};

var hasRequiredWindow;

function requireWindow () {
	if (hasRequiredWindow) return window$1;
	hasRequiredWindow = 1;
	Object.defineProperty(window$1, "__esModule", { value: true });
	window$1.window = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function window(windowBoundaries) {
	    return lift_1.operate(function (source, subscriber) {
	        var windowSubject = new Subject_1.Subject();
	        subscriber.next(windowSubject.asObservable());
	        var errorHandler = function (err) {
	            windowSubject.error(err);
	            subscriber.error(err);
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {
	            windowSubject.complete();
	            subscriber.complete();
	        }, errorHandler));
	        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            windowSubject.complete();
	            subscriber.next((windowSubject = new Subject_1.Subject()));
	        }, noop_1.noop, errorHandler));
	        return function () {
	            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
	            windowSubject = null;
	        };
	    });
	}
	window$1.window = window;
	
	return window$1;
}

var windowCount = {};

var hasRequiredWindowCount;

function requireWindowCount () {
	if (hasRequiredWindowCount) return windowCount;
	hasRequiredWindowCount = 1;
	var __values = (windowCount && windowCount.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(windowCount, "__esModule", { value: true });
	windowCount.windowCount = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function windowCount$1(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
	    return lift_1.operate(function (source, subscriber) {
	        var windows = [new Subject_1.Subject()];
	        var count = 0;
	        subscriber.next(windows[0].asObservable());
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            try {
	                for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
	                    var window_1 = windows_1_1.value;
	                    window_1.next(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            var c = count - windowSize + 1;
	            if (c >= 0 && c % startEvery === 0) {
	                windows.shift().complete();
	            }
	            if (++count % startEvery === 0) {
	                var window_2 = new Subject_1.Subject();
	                windows.push(window_2);
	                subscriber.next(window_2.asObservable());
	            }
	        }, function () {
	            while (windows.length > 0) {
	                windows.shift().complete();
	            }
	            subscriber.complete();
	        }, function (err) {
	            while (windows.length > 0) {
	                windows.shift().error(err);
	            }
	            subscriber.error(err);
	        }, function () {
	            windows = null;
	        }));
	    });
	}
	windowCount.windowCount = windowCount$1;
	
	return windowCount;
}

var windowTime = {};

var hasRequiredWindowTime;

function requireWindowTime () {
	if (hasRequiredWindowTime) return windowTime;
	hasRequiredWindowTime = 1;
	Object.defineProperty(windowTime, "__esModule", { value: true });
	windowTime.windowTime = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var async_1 = /*@__PURE__*/ requireAsync();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var args_1 = /*@__PURE__*/ requireArgs();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function windowTime$1(windowTimeSpan) {
	    var _a, _b;
	    var otherArgs = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherArgs[_i - 1] = arguments[_i];
	    }
	    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
	    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	    var maxWindowSize = otherArgs[1] || Infinity;
	    return lift_1.operate(function (source, subscriber) {
	        var windowRecords = [];
	        var restartOnClose = false;
	        var closeWindow = function (record) {
	            var window = record.window, subs = record.subs;
	            window.complete();
	            subs.unsubscribe();
	            arrRemove_1.arrRemove(windowRecords, record);
	            restartOnClose && startWindow();
	        };
	        var startWindow = function () {
	            if (windowRecords) {
	                var subs = new Subscription_1.Subscription();
	                subscriber.add(subs);
	                var window_1 = new Subject_1.Subject();
	                var record_1 = {
	                    window: window_1,
	                    subs: subs,
	                    seen: 0,
	                };
	                windowRecords.push(record_1);
	                subscriber.next(window_1.asObservable());
	                executeSchedule_1.executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);
	            }
	        };
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
	        }
	        else {
	            restartOnClose = true;
	        }
	        startWindow();
	        var loop = function (cb) { return windowRecords.slice().forEach(cb); };
	        var terminate = function (cb) {
	            loop(function (_a) {
	                var window = _a.window;
	                return cb(window);
	            });
	            cb(subscriber);
	            subscriber.unsubscribe();
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            loop(function (record) {
	                record.window.next(value);
	                maxWindowSize <= ++record.seen && closeWindow(record);
	            });
	        }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));
	        return function () {
	            windowRecords = null;
	        };
	    });
	}
	windowTime.windowTime = windowTime$1;
	
	return windowTime;
}

var windowToggle = {};

var hasRequiredWindowToggle;

function requireWindowToggle () {
	if (hasRequiredWindowToggle) return windowToggle;
	hasRequiredWindowToggle = 1;
	var __values = (windowToggle && windowToggle.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(windowToggle, "__esModule", { value: true });
	windowToggle.windowToggle = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	function windowToggle$1(openings, closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var windows = [];
	        var handleError = function (err) {
	            while (0 < windows.length) {
	                windows.shift().error(err);
	            }
	            subscriber.error(err);
	        };
	        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (openValue) {
	            var window = new Subject_1.Subject();
	            windows.push(window);
	            var closingSubscription = new Subscription_1.Subscription();
	            var closeWindow = function () {
	                arrRemove_1.arrRemove(windows, window);
	                window.complete();
	                closingSubscription.unsubscribe();
	            };
	            var closingNotifier;
	            try {
	                closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
	            }
	            catch (err) {
	                handleError(err);
	                return;
	            }
	            subscriber.next(window.asObservable());
	            closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
	        }, noop_1.noop));
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            var windowsCopy = windows.slice();
	            try {
	                for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
	                    var window_1 = windowsCopy_1_1.value;
	                    window_1.next(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (0 < windows.length) {
	                windows.shift().complete();
	            }
	            subscriber.complete();
	        }, handleError, function () {
	            while (0 < windows.length) {
	                windows.shift().unsubscribe();
	            }
	        }));
	    });
	}
	windowToggle.windowToggle = windowToggle$1;
	
	return windowToggle;
}

var windowWhen = {};

var hasRequiredWindowWhen;

function requireWindowWhen () {
	if (hasRequiredWindowWhen) return windowWhen;
	hasRequiredWindowWhen = 1;
	Object.defineProperty(windowWhen, "__esModule", { value: true });
	windowWhen.windowWhen = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function windowWhen$1(closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var window;
	        var closingSubscriber;
	        var handleError = function (err) {
	            window.error(err);
	            subscriber.error(err);
	        };
	        var openWindow = function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            window === null || window === void 0 ? void 0 : window.complete();
	            window = new Subject_1.Subject();
	            subscriber.next(window.asObservable());
	            var closingNotifier;
	            try {
	                closingNotifier = innerFrom_1.innerFrom(closingSelector());
	            }
	            catch (err) {
	                handleError(err);
	                return;
	            }
	            closingNotifier.subscribe((closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
	        };
	        openWindow();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {
	            window.complete();
	            subscriber.complete();
	        }, handleError, function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            window = null;
	        }));
	    });
	}
	windowWhen.windowWhen = windowWhen$1;
	
	return windowWhen;
}

var withLatestFrom = {};

var hasRequiredWithLatestFrom;

function requireWithLatestFrom () {
	if (hasRequiredWithLatestFrom) return withLatestFrom;
	hasRequiredWithLatestFrom = 1;
	var __read = (withLatestFrom && withLatestFrom.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (withLatestFrom && withLatestFrom.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(withLatestFrom, "__esModule", { value: true });
	withLatestFrom.withLatestFrom = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var identity_1 = /*@__PURE__*/ requireIdentity();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var args_1 = /*@__PURE__*/ requireArgs();
	function withLatestFrom$1() {
	    var inputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        inputs[_i] = arguments[_i];
	    }
	    var project = args_1.popResultSelector(inputs);
	    return lift_1.operate(function (source, subscriber) {
	        var len = inputs.length;
	        var otherValues = new Array(len);
	        var hasValue = inputs.map(function () { return false; });
	        var ready = false;
	        var _loop_1 = function (i) {
	            innerFrom_1.innerFrom(inputs[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                otherValues[i] = value;
	                if (!ready && !hasValue[i]) {
	                    hasValue[i] = true;
	                    (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
	                }
	            }, noop_1.noop));
	        };
	        for (var i = 0; i < len; i++) {
	            _loop_1(i);
	        }
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            if (ready) {
	                var values = __spreadArray([value], __read(otherValues));
	                subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
	            }
	        }));
	    });
	}
	withLatestFrom.withLatestFrom = withLatestFrom$1;
	
	return withLatestFrom;
}

var zipAll = {};

var hasRequiredZipAll;

function requireZipAll () {
	if (hasRequiredZipAll) return zipAll;
	hasRequiredZipAll = 1;
	Object.defineProperty(zipAll, "__esModule", { value: true });
	zipAll.zipAll = void 0;
	var zip_1 = /*@__PURE__*/ requireZip$1();
	var joinAllInternals_1 = /*@__PURE__*/ requireJoinAllInternals();
	function zipAll$1(project) {
	    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
	}
	zipAll.zipAll = zipAll$1;
	
	return zipAll;
}

var zipWith = {};

var zip = {};

var hasRequiredZip;

function requireZip () {
	if (hasRequiredZip) return zip;
	hasRequiredZip = 1;
	var __read = (zip && zip.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (zip && zip.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(zip, "__esModule", { value: true });
	zip.zip = void 0;
	var zip_1 = /*@__PURE__*/ requireZip$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	function zip$1() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    return lift_1.operate(function (source, subscriber) {
	        zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
	    });
	}
	zip.zip = zip$1;
	
	return zip;
}

var hasRequiredZipWith;

function requireZipWith () {
	if (hasRequiredZipWith) return zipWith;
	hasRequiredZipWith = 1;
	var __read = (zipWith && zipWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (zipWith && zipWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(zipWith, "__esModule", { value: true });
	zipWith.zipWith = void 0;
	var zip_1 = /*@__PURE__*/ requireZip();
	function zipWith$1() {
	    var otherInputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherInputs[_i] = arguments[_i];
	    }
	    return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
	}
	zipWith.zipWith = zipWith$1;
	
	return zipWith;
}

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs;
	hasRequiredCjs = 1;
	(function (exports) {
		var __createBinding = (cjs && cjs.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (cjs && cjs.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
		exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
		exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
		exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
		var Observable_1 = /*@__PURE__*/ requireObservable();
		Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
		var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
		Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
		var observable_1 = /*@__PURE__*/ requireObservable$1();
		Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
		var animationFrames_1 = /*@__PURE__*/ requireAnimationFrames();
		Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
		var Subject_1 = /*@__PURE__*/ requireSubject();
		Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
		var BehaviorSubject_1 = /*@__PURE__*/ requireBehaviorSubject();
		Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
		var ReplaySubject_1 = /*@__PURE__*/ requireReplaySubject();
		Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
		var AsyncSubject_1 = /*@__PURE__*/ requireAsyncSubject();
		Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
		var asap_1 = /*@__PURE__*/ requireAsap();
		Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
		Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
		var async_1 = /*@__PURE__*/ requireAsync();
		Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
		Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
		var queue_1 = /*@__PURE__*/ requireQueue();
		Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
		Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
		var animationFrame_1 = /*@__PURE__*/ requireAnimationFrame();
		Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
		Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
		var VirtualTimeScheduler_1 = /*@__PURE__*/ requireVirtualTimeScheduler();
		Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
		Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
		var Scheduler_1 = /*@__PURE__*/ requireScheduler();
		Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
		var Subscription_1 = /*@__PURE__*/ requireSubscription();
		Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
		var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
		Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
		var Notification_1 = /*@__PURE__*/ requireNotification();
		Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
		Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
		var pipe_1 = /*@__PURE__*/ requirePipe();
		Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
		var noop_1 = /*@__PURE__*/ requireNoop();
		Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
		var identity_1 = /*@__PURE__*/ requireIdentity();
		Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
		var isObservable_1 = /*@__PURE__*/ requireIsObservable();
		Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
		var lastValueFrom_1 = /*@__PURE__*/ requireLastValueFrom();
		Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
		var firstValueFrom_1 = /*@__PURE__*/ requireFirstValueFrom();
		Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
		var ArgumentOutOfRangeError_1 = /*@__PURE__*/ requireArgumentOutOfRangeError();
		Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
		var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
		Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
		var NotFoundError_1 = /*@__PURE__*/ requireNotFoundError();
		Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
		var ObjectUnsubscribedError_1 = /*@__PURE__*/ requireObjectUnsubscribedError();
		Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
		var SequenceError_1 = /*@__PURE__*/ requireSequenceError();
		Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
		var timeout_1 = /*@__PURE__*/ requireTimeout();
		Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
		var UnsubscriptionError_1 = /*@__PURE__*/ requireUnsubscriptionError();
		Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
		var bindCallback_1 = /*@__PURE__*/ requireBindCallback();
		Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
		var bindNodeCallback_1 = /*@__PURE__*/ requireBindNodeCallback();
		Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
		var combineLatest_1 = /*@__PURE__*/ requireCombineLatest$1();
		Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
		var concat_1 = /*@__PURE__*/ requireConcat$1();
		Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
		var connectable_1 = /*@__PURE__*/ requireConnectable();
		Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
		var defer_1 = /*@__PURE__*/ requireDefer();
		Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
		var empty_1 = /*@__PURE__*/ requireEmpty();
		Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
		var forkJoin_1 = /*@__PURE__*/ requireForkJoin();
		Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
		var from_1 = /*@__PURE__*/ requireFrom();
		Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
		var fromEvent_1 = /*@__PURE__*/ requireFromEvent();
		Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
		var fromEventPattern_1 = /*@__PURE__*/ requireFromEventPattern();
		Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
		var generate_1 = /*@__PURE__*/ requireGenerate();
		Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
		var iif_1 = /*@__PURE__*/ requireIif();
		Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
		var interval_1 = /*@__PURE__*/ requireInterval();
		Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
		var merge_1 = /*@__PURE__*/ requireMerge$1();
		Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
		var never_1 = /*@__PURE__*/ requireNever();
		Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
		var of_1 = /*@__PURE__*/ requireOf();
		Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
		var onErrorResumeNext_1 = /*@__PURE__*/ requireOnErrorResumeNext();
		Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
		var pairs_1 = /*@__PURE__*/ requirePairs();
		Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
		var partition_1 = /*@__PURE__*/ requirePartition$1();
		Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
		var race_1 = /*@__PURE__*/ requireRace$1();
		Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
		var range_1 = /*@__PURE__*/ requireRange();
		Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
		var throwError_1 = /*@__PURE__*/ requireThrowError();
		Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
		var timer_1 = /*@__PURE__*/ requireTimer();
		Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
		var using_1 = /*@__PURE__*/ requireUsing();
		Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
		var zip_1 = /*@__PURE__*/ requireZip$1();
		Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
		var scheduled_1 = /*@__PURE__*/ requireScheduled();
		Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
		var empty_2 = /*@__PURE__*/ requireEmpty();
		Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
		var never_2 = /*@__PURE__*/ requireNever();
		Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
		__exportStar(/*@__PURE__*/ requireTypes(), exports);
		var config_1 = /*@__PURE__*/ requireConfig();
		Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
		var audit_1 = /*@__PURE__*/ requireAudit();
		Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
		var auditTime_1 = /*@__PURE__*/ requireAuditTime();
		Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
		var buffer_1 = /*@__PURE__*/ requireBuffer();
		Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
		var bufferCount_1 = /*@__PURE__*/ requireBufferCount();
		Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
		var bufferTime_1 = /*@__PURE__*/ requireBufferTime();
		Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
		var bufferToggle_1 = /*@__PURE__*/ requireBufferToggle();
		Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
		var bufferWhen_1 = /*@__PURE__*/ requireBufferWhen();
		Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
		var catchError_1 = /*@__PURE__*/ requireCatchError();
		Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
		var combineAll_1 = /*@__PURE__*/ requireCombineAll();
		Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
		var combineLatestAll_1 = /*@__PURE__*/ requireCombineLatestAll();
		Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
		var combineLatestWith_1 = /*@__PURE__*/ requireCombineLatestWith();
		Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
		var concatAll_1 = /*@__PURE__*/ requireConcatAll();
		Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
		var concatMap_1 = /*@__PURE__*/ requireConcatMap();
		Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
		var concatMapTo_1 = /*@__PURE__*/ requireConcatMapTo();
		Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
		var concatWith_1 = /*@__PURE__*/ requireConcatWith();
		Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
		var connect_1 = /*@__PURE__*/ requireConnect();
		Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
		var count_1 = /*@__PURE__*/ requireCount();
		Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
		var debounce_1 = /*@__PURE__*/ requireDebounce();
		Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
		var debounceTime_1 = /*@__PURE__*/ requireDebounceTime();
		Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
		var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
		Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
		var delay_1 = /*@__PURE__*/ requireDelay();
		Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
		var delayWhen_1 = /*@__PURE__*/ requireDelayWhen();
		Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
		var dematerialize_1 = /*@__PURE__*/ requireDematerialize();
		Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
		var distinct_1 = /*@__PURE__*/ requireDistinct();
		Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
		var distinctUntilChanged_1 = /*@__PURE__*/ requireDistinctUntilChanged();
		Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
		var distinctUntilKeyChanged_1 = /*@__PURE__*/ requireDistinctUntilKeyChanged();
		Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
		var elementAt_1 = /*@__PURE__*/ requireElementAt();
		Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
		var endWith_1 = /*@__PURE__*/ requireEndWith();
		Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
		var every_1 = /*@__PURE__*/ requireEvery();
		Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
		var exhaust_1 = /*@__PURE__*/ requireExhaust();
		Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
		var exhaustAll_1 = /*@__PURE__*/ requireExhaustAll();
		Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
		var exhaustMap_1 = /*@__PURE__*/ requireExhaustMap();
		Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
		var expand_1 = /*@__PURE__*/ requireExpand();
		Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
		var filter_1 = /*@__PURE__*/ requireFilter();
		Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
		var finalize_1 = /*@__PURE__*/ requireFinalize();
		Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
		var find_1 = /*@__PURE__*/ requireFind();
		Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
		var findIndex_1 = /*@__PURE__*/ requireFindIndex();
		Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
		var first_1 = /*@__PURE__*/ requireFirst();
		Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
		var groupBy_1 = /*@__PURE__*/ requireGroupBy();
		Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
		var ignoreElements_1 = /*@__PURE__*/ requireIgnoreElements();
		Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
		var isEmpty_1 = /*@__PURE__*/ requireIsEmpty();
		Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
		var last_1 = /*@__PURE__*/ requireLast();
		Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
		var map_1 = /*@__PURE__*/ requireMap();
		Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
		var mapTo_1 = /*@__PURE__*/ requireMapTo();
		Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
		var materialize_1 = /*@__PURE__*/ requireMaterialize();
		Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
		var max_1 = /*@__PURE__*/ requireMax();
		Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
		var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
		Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
		var flatMap_1 = /*@__PURE__*/ requireFlatMap();
		Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
		var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
		Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
		var mergeMapTo_1 = /*@__PURE__*/ requireMergeMapTo();
		Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
		var mergeScan_1 = /*@__PURE__*/ requireMergeScan();
		Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
		var mergeWith_1 = /*@__PURE__*/ requireMergeWith();
		Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
		var min_1 = /*@__PURE__*/ requireMin();
		Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
		var multicast_1 = /*@__PURE__*/ requireMulticast();
		Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
		var observeOn_1 = /*@__PURE__*/ requireObserveOn();
		Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
		var onErrorResumeNextWith_1 = /*@__PURE__*/ requireOnErrorResumeNextWith();
		Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
		var pairwise_1 = /*@__PURE__*/ requirePairwise();
		Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
		var pluck_1 = /*@__PURE__*/ requirePluck();
		Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
		var publish_1 = /*@__PURE__*/ requirePublish();
		Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
		var publishBehavior_1 = /*@__PURE__*/ requirePublishBehavior();
		Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
		var publishLast_1 = /*@__PURE__*/ requirePublishLast();
		Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
		var publishReplay_1 = /*@__PURE__*/ requirePublishReplay();
		Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
		var raceWith_1 = /*@__PURE__*/ requireRaceWith();
		Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
		var reduce_1 = /*@__PURE__*/ requireReduce();
		Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
		var repeat_1 = /*@__PURE__*/ requireRepeat();
		Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
		var repeatWhen_1 = /*@__PURE__*/ requireRepeatWhen();
		Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
		var retry_1 = /*@__PURE__*/ requireRetry();
		Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
		var retryWhen_1 = /*@__PURE__*/ requireRetryWhen();
		Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
		var refCount_1 = /*@__PURE__*/ requireRefCount();
		Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
		var sample_1 = /*@__PURE__*/ requireSample();
		Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
		var sampleTime_1 = /*@__PURE__*/ requireSampleTime();
		Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
		var scan_1 = /*@__PURE__*/ requireScan();
		Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
		var sequenceEqual_1 = /*@__PURE__*/ requireSequenceEqual();
		Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
		var share_1 = /*@__PURE__*/ requireShare();
		Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
		var shareReplay_1 = /*@__PURE__*/ requireShareReplay();
		Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
		var single_1 = /*@__PURE__*/ requireSingle();
		Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
		var skip_1 = /*@__PURE__*/ requireSkip();
		Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
		var skipLast_1 = /*@__PURE__*/ requireSkipLast();
		Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
		var skipUntil_1 = /*@__PURE__*/ requireSkipUntil();
		Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
		var skipWhile_1 = /*@__PURE__*/ requireSkipWhile();
		Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
		var startWith_1 = /*@__PURE__*/ requireStartWith();
		Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
		var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
		Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
		var switchAll_1 = /*@__PURE__*/ requireSwitchAll();
		Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
		var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
		Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
		var switchMapTo_1 = /*@__PURE__*/ requireSwitchMapTo();
		Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
		var switchScan_1 = /*@__PURE__*/ requireSwitchScan();
		Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
		var take_1 = /*@__PURE__*/ requireTake();
		Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
		var takeLast_1 = /*@__PURE__*/ requireTakeLast();
		Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
		var takeUntil_1 = /*@__PURE__*/ requireTakeUntil();
		Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
		var takeWhile_1 = /*@__PURE__*/ requireTakeWhile();
		Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
		var tap_1 = /*@__PURE__*/ requireTap();
		Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
		var throttle_1 = /*@__PURE__*/ requireThrottle();
		Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
		var throttleTime_1 = /*@__PURE__*/ requireThrottleTime();
		Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
		var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
		Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
		var timeInterval_1 = /*@__PURE__*/ requireTimeInterval();
		Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
		var timeout_2 = /*@__PURE__*/ requireTimeout();
		Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
		var timeoutWith_1 = /*@__PURE__*/ requireTimeoutWith();
		Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
		var timestamp_1 = /*@__PURE__*/ requireTimestamp();
		Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
		var toArray_1 = /*@__PURE__*/ requireToArray();
		Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
		var window_1 = /*@__PURE__*/ requireWindow();
		Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
		var windowCount_1 = /*@__PURE__*/ requireWindowCount();
		Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
		var windowTime_1 = /*@__PURE__*/ requireWindowTime();
		Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
		var windowToggle_1 = /*@__PURE__*/ requireWindowToggle();
		Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
		var windowWhen_1 = /*@__PURE__*/ requireWindowWhen();
		Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
		var withLatestFrom_1 = /*@__PURE__*/ requireWithLatestFrom();
		Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
		var zipAll_1 = /*@__PURE__*/ requireZipAll();
		Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
		var zipWith_1 = /*@__PURE__*/ requireZipWith();
		Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
		
	} (cjs));
	return cjs;
}

var cjsExports = /*@__PURE__*/ requireCjs();

var operators = {};

var partition = {};

var hasRequiredPartition;

function requirePartition () {
	if (hasRequiredPartition) return partition;
	hasRequiredPartition = 1;
	Object.defineProperty(partition, "__esModule", { value: true });
	partition.partition = void 0;
	var not_1 = /*@__PURE__*/ requireNot();
	var filter_1 = /*@__PURE__*/ requireFilter();
	function partition$1(predicate, thisArg) {
	    return function (source) {
	        return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
	    };
	}
	partition.partition = partition$1;
	
	return partition;
}

var race = {};

var hasRequiredRace;

function requireRace () {
	if (hasRequiredRace) return race;
	hasRequiredRace = 1;
	var __read = (race && race.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (race && race.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(race, "__esModule", { value: true });
	race.race = void 0;
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var raceWith_1 = /*@__PURE__*/ requireRaceWith();
	function race$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args))));
	}
	race.race = race$1;
	
	return race;
}

var hasRequiredOperators;

function requireOperators () {
	if (hasRequiredOperators) return operators;
	hasRequiredOperators = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
		exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
		exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
		var audit_1 = /*@__PURE__*/ requireAudit();
		Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
		var auditTime_1 = /*@__PURE__*/ requireAuditTime();
		Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
		var buffer_1 = /*@__PURE__*/ requireBuffer();
		Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
		var bufferCount_1 = /*@__PURE__*/ requireBufferCount();
		Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
		var bufferTime_1 = /*@__PURE__*/ requireBufferTime();
		Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
		var bufferToggle_1 = /*@__PURE__*/ requireBufferToggle();
		Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
		var bufferWhen_1 = /*@__PURE__*/ requireBufferWhen();
		Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
		var catchError_1 = /*@__PURE__*/ requireCatchError();
		Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
		var combineAll_1 = /*@__PURE__*/ requireCombineAll();
		Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
		var combineLatestAll_1 = /*@__PURE__*/ requireCombineLatestAll();
		Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
		var combineLatest_1 = /*@__PURE__*/ requireCombineLatest();
		Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
		var combineLatestWith_1 = /*@__PURE__*/ requireCombineLatestWith();
		Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
		var concat_1 = /*@__PURE__*/ requireConcat();
		Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
		var concatAll_1 = /*@__PURE__*/ requireConcatAll();
		Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
		var concatMap_1 = /*@__PURE__*/ requireConcatMap();
		Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
		var concatMapTo_1 = /*@__PURE__*/ requireConcatMapTo();
		Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
		var concatWith_1 = /*@__PURE__*/ requireConcatWith();
		Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
		var connect_1 = /*@__PURE__*/ requireConnect();
		Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
		var count_1 = /*@__PURE__*/ requireCount();
		Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
		var debounce_1 = /*@__PURE__*/ requireDebounce();
		Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
		var debounceTime_1 = /*@__PURE__*/ requireDebounceTime();
		Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
		var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
		Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
		var delay_1 = /*@__PURE__*/ requireDelay();
		Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
		var delayWhen_1 = /*@__PURE__*/ requireDelayWhen();
		Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
		var dematerialize_1 = /*@__PURE__*/ requireDematerialize();
		Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
		var distinct_1 = /*@__PURE__*/ requireDistinct();
		Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
		var distinctUntilChanged_1 = /*@__PURE__*/ requireDistinctUntilChanged();
		Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
		var distinctUntilKeyChanged_1 = /*@__PURE__*/ requireDistinctUntilKeyChanged();
		Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
		var elementAt_1 = /*@__PURE__*/ requireElementAt();
		Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
		var endWith_1 = /*@__PURE__*/ requireEndWith();
		Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
		var every_1 = /*@__PURE__*/ requireEvery();
		Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
		var exhaust_1 = /*@__PURE__*/ requireExhaust();
		Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
		var exhaustAll_1 = /*@__PURE__*/ requireExhaustAll();
		Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
		var exhaustMap_1 = /*@__PURE__*/ requireExhaustMap();
		Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
		var expand_1 = /*@__PURE__*/ requireExpand();
		Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
		var filter_1 = /*@__PURE__*/ requireFilter();
		Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
		var finalize_1 = /*@__PURE__*/ requireFinalize();
		Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
		var find_1 = /*@__PURE__*/ requireFind();
		Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
		var findIndex_1 = /*@__PURE__*/ requireFindIndex();
		Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
		var first_1 = /*@__PURE__*/ requireFirst();
		Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
		var groupBy_1 = /*@__PURE__*/ requireGroupBy();
		Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
		var ignoreElements_1 = /*@__PURE__*/ requireIgnoreElements();
		Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
		var isEmpty_1 = /*@__PURE__*/ requireIsEmpty();
		Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
		var last_1 = /*@__PURE__*/ requireLast();
		Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
		var map_1 = /*@__PURE__*/ requireMap();
		Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
		var mapTo_1 = /*@__PURE__*/ requireMapTo();
		Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
		var materialize_1 = /*@__PURE__*/ requireMaterialize();
		Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
		var max_1 = /*@__PURE__*/ requireMax();
		Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
		var merge_1 = /*@__PURE__*/ requireMerge();
		Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
		var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
		Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
		var flatMap_1 = /*@__PURE__*/ requireFlatMap();
		Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
		var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
		Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
		var mergeMapTo_1 = /*@__PURE__*/ requireMergeMapTo();
		Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
		var mergeScan_1 = /*@__PURE__*/ requireMergeScan();
		Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
		var mergeWith_1 = /*@__PURE__*/ requireMergeWith();
		Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
		var min_1 = /*@__PURE__*/ requireMin();
		Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
		var multicast_1 = /*@__PURE__*/ requireMulticast();
		Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
		var observeOn_1 = /*@__PURE__*/ requireObserveOn();
		Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
		var onErrorResumeNextWith_1 = /*@__PURE__*/ requireOnErrorResumeNextWith();
		Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNext; } });
		var pairwise_1 = /*@__PURE__*/ requirePairwise();
		Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
		var partition_1 = /*@__PURE__*/ requirePartition();
		Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
		var pluck_1 = /*@__PURE__*/ requirePluck();
		Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
		var publish_1 = /*@__PURE__*/ requirePublish();
		Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
		var publishBehavior_1 = /*@__PURE__*/ requirePublishBehavior();
		Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
		var publishLast_1 = /*@__PURE__*/ requirePublishLast();
		Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
		var publishReplay_1 = /*@__PURE__*/ requirePublishReplay();
		Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
		var race_1 = /*@__PURE__*/ requireRace();
		Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
		var raceWith_1 = /*@__PURE__*/ requireRaceWith();
		Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
		var reduce_1 = /*@__PURE__*/ requireReduce();
		Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
		var repeat_1 = /*@__PURE__*/ requireRepeat();
		Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
		var repeatWhen_1 = /*@__PURE__*/ requireRepeatWhen();
		Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
		var retry_1 = /*@__PURE__*/ requireRetry();
		Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
		var retryWhen_1 = /*@__PURE__*/ requireRetryWhen();
		Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
		var refCount_1 = /*@__PURE__*/ requireRefCount();
		Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
		var sample_1 = /*@__PURE__*/ requireSample();
		Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
		var sampleTime_1 = /*@__PURE__*/ requireSampleTime();
		Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
		var scan_1 = /*@__PURE__*/ requireScan();
		Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
		var sequenceEqual_1 = /*@__PURE__*/ requireSequenceEqual();
		Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
		var share_1 = /*@__PURE__*/ requireShare();
		Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
		var shareReplay_1 = /*@__PURE__*/ requireShareReplay();
		Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
		var single_1 = /*@__PURE__*/ requireSingle();
		Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
		var skip_1 = /*@__PURE__*/ requireSkip();
		Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
		var skipLast_1 = /*@__PURE__*/ requireSkipLast();
		Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
		var skipUntil_1 = /*@__PURE__*/ requireSkipUntil();
		Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
		var skipWhile_1 = /*@__PURE__*/ requireSkipWhile();
		Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
		var startWith_1 = /*@__PURE__*/ requireStartWith();
		Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
		var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
		Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
		var switchAll_1 = /*@__PURE__*/ requireSwitchAll();
		Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
		var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
		Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
		var switchMapTo_1 = /*@__PURE__*/ requireSwitchMapTo();
		Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
		var switchScan_1 = /*@__PURE__*/ requireSwitchScan();
		Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
		var take_1 = /*@__PURE__*/ requireTake();
		Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
		var takeLast_1 = /*@__PURE__*/ requireTakeLast();
		Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
		var takeUntil_1 = /*@__PURE__*/ requireTakeUntil();
		Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
		var takeWhile_1 = /*@__PURE__*/ requireTakeWhile();
		Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
		var tap_1 = /*@__PURE__*/ requireTap();
		Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
		var throttle_1 = /*@__PURE__*/ requireThrottle();
		Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
		var throttleTime_1 = /*@__PURE__*/ requireThrottleTime();
		Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
		var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
		Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
		var timeInterval_1 = /*@__PURE__*/ requireTimeInterval();
		Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
		var timeout_1 = /*@__PURE__*/ requireTimeout();
		Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_1.timeout; } });
		var timeoutWith_1 = /*@__PURE__*/ requireTimeoutWith();
		Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
		var timestamp_1 = /*@__PURE__*/ requireTimestamp();
		Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
		var toArray_1 = /*@__PURE__*/ requireToArray();
		Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
		var window_1 = /*@__PURE__*/ requireWindow();
		Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
		var windowCount_1 = /*@__PURE__*/ requireWindowCount();
		Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
		var windowTime_1 = /*@__PURE__*/ requireWindowTime();
		Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
		var windowToggle_1 = /*@__PURE__*/ requireWindowToggle();
		Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
		var windowWhen_1 = /*@__PURE__*/ requireWindowWhen();
		Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
		var withLatestFrom_1 = /*@__PURE__*/ requireWithLatestFrom();
		Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
		var zip_1 = /*@__PURE__*/ requireZip();
		Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
		var zipAll_1 = /*@__PURE__*/ requireZipAll();
		Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
		var zipWith_1 = /*@__PURE__*/ requireZipWith();
		Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
		
	} (operators));
	return operators;
}

var operatorsExports = /*@__PURE__*/ requireOperators();

const USER_PREFERENCE_STORAGE_ID = "RAUserPreferences";
const USER_PREFERENCE_VERSION = "0.1";
function isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent);
}
/**
 * Return pages from readalong XML file
 * @param {string} - the path to the readalong file
 */
async function parseRAS(path) {
    let response = await fetch(path);
    if (!response.ok) {
        console.error(`fetch(${path}) failed with status ${response.status}`);
        return { pages: null, meta: null };
    }
    let xmlDocument = await response.text();
    let parser = new DOMParser();
    let xml = parser.parseFromString(xmlDocument, "text/xml");
    return { pages: extractPages(xml), meta: extractMeta(xml) };
}
/**
 * Return pages from parsed XML
 * @param {xml} - the parsed XML (could be an element)
 */
function extractPages(xml) {
    let parsed_pages = Array.from(xml.querySelectorAll("div[type=page]")).map((page) => {
        let img = page.querySelector("graphic[url]");
        let paragraphs = page.querySelectorAll("p");
        let parsed_page = {
            id: page.getAttribute("id"),
            paragraphs: Array.from(paragraphs),
        };
        if (img !== null) {
            parsed_page["img"] = img.getAttribute("url");
        }
        if (page.attributes)
            parsed_page["attributes"] = page.attributes;
        return parsed_page;
    });
    return parsed_pages;
}
/**
 *
 * @param {xml} - the parsed XML
 * @returns {RASMeta} - meta key-values
 */
function extractMeta(xml) {
    let meta = {};
    Array.from(xml.querySelectorAll("meta")).forEach((metaTag) => {
        const key = metaTag.getAttribute("name");
        let value = metaTag.getAttribute("content");
        meta[key] = value.trim();
    });
    return meta;
}
/**
 * Extract alignment data from parsed text
 */
function extractAlignment(parsed_text) {
    let alignment = {};
    for (const page of parsed_text) {
        for (const p of page.paragraphs) {
            for (const w of Array.from(p.querySelectorAll("w[time][dur]"))) {
                const time = w.getAttribute("time");
                const dur = w.getAttribute("dur");
                if (time !== null && dur !== null)
                    alignment[w.getAttribute("id")] = [
                        Math.round(parseFloat(time) * 1000),
                        Math.round(parseFloat(dur) * 1000),
                    ];
            }
        }
    }
    return alignment;
}
/**
 * Sprite class containing the state of our sprites to play and their progress.
 * @param {Object} options Settings to pass into and setup the sound and visuals.
 */
var Sprite = function (options) {
    var self = this;
    const html5 = isIOS();
    self.sounds = [];
    // Setup the options to define this sprite display.
    self._sprite = options.sprite;
    // Create new Subject tracking which element is being read
    self._reading$ = new cjsExports.Subject();
    // List of all non-"all" sprites
    self._tinySprite = Object.keys(options.sprite).map((str) => [
        self._sprite[str][0],
        str,
        self._sprite[str][0] + self._sprite[str][1], //start time + duration (real time upper limit of the sprite)
    ]);
    // remove the 'all' sprite
    self._tinySprite.pop();
    // percentage finished
    self._percentPlayed = new cjsExports.BehaviorSubject("0%");
    // Create our audio sprite definition.
    self.sound = new howlerExports.Howl({
        src: options.src,
        sprite: options.sprite,
        rate: options.rate,
        html5: html5,
        onend: function () {
            self._reading$.next(""); //flush the pipe
        },
    });
    // Begin the progress step tick.
    requestAnimationFrame(self.step.bind(self));
};
Sprite.prototype = {
    /**
     * Play a sprite when clicked and track the progress.
     * @param  {String} key Key in the sprite map object.
     */
    play: function (key) {
        var self = this;
        self._spriteLeft = self._tinySprite;
        var sprite = key;
        // Play the sprite sound and capture the ID.
        var id = self.sound.play(sprite);
        return id;
    },
    pause: function () {
        var self = this;
        self.sound.pause();
        return self.sound.id;
    },
    /**
     * Go back s seconds, or if current position - s is less than 0
     * go back to the beginning.
     *
     * @param id - the id of the audio to roll back
     * @param s - the number of seconds to go back
     */
    goBack: function (id, s) {
        var self = this;
        // reset sprites left
        self._spriteLeft = self._tinySprite;
        // if current_seek - s is greater than 0, find the closest sprite
        // and highlight it; seek to current_seek -s.
        if (self.sound.seek((id = id)) - s > 0) {
            var id = self.sound.seek(self.sound.seek((id = id)) - s, id);
            // move highlight back TODO: refactor out into its own function and combine with version in step()
            var seek = self.sound.seek((id = id));
            for (var j = 0; j < self._spriteLeft.length; j++) {
                // if seek passes sprite start point, replace self._reading with that sprite and slice the array of sprites left
                if (seek * 1000 >= self._spriteLeft[j][0]) {
                    // only emit sprite if within current audio seek position
                    if (seek * 1000 <= self._spriteLeft[j][2]) {
                        self._reading$.next(self._spriteLeft[j][1]);
                    }
                    self._spriteLeft = self._spriteLeft.slice(j, self._spriteLeft.length);
                }
            }
            self._reading$.next(self._spriteLeft[0][1]);
            // else, return back to beginning
        }
        else {
            var id = self.sound.seek(0, id);
            self._reading$.next(self._spriteLeft[0][1]);
        }
        return id;
    },
    /**
     * Go to s seconds in the audio timeline
     * @param id - the id of the audio to roll back
     * @param s - the number of seconds to go back
     */
    goTo: function (id, s) {
        var self = this;
        // reset sprites left
        self._spriteLeft = self._tinySprite;
        // if current_seek - s is greater than 0, find the closest sprite
        // and highlight it; seek to current_seek -s.
        var id = self.sound.seek(s, id);
        // get the current audio position and convert it from seconds to millisecond
        var seek = self.sound.seek((id = id)) * 1000;
        for (var j = 0; j < self._spriteLeft.length; j++) {
            // if seek passes sprite start point, replace self._reading with that sprite and slice the array of sprites left
            if (seek >= self._spriteLeft[j][0]) {
                // only emit sprite if within current audio seek position
                if (seek <= self._spriteLeft[j][2]) {
                    self._reading$.next(self._spriteLeft[j][1]);
                    //attempt to adjust the audio position
                    id = self.sound.seek(self._spriteLeft[j][0], id); //set sound to beginning of word
                    self.sound.seek((id = id));
                    self._spriteLeft = self._spriteLeft.slice(j, self._spriteLeft.length);
                    break;
                }
            }
        }
        //update the progress bar
        if (self.sounds.length) {
            const percentage = (Math.round((s / self.sound.duration(id)) * 100) || 0) + "%";
            self.sounds[0].style.width = percentage;
            self.sounds[0].setAttribute("offset", percentage);
        }
        // else, return back to beginning
        return id;
    },
    /**
     * Stop the sound
     */
    stop: function () {
        var self = this;
        // remove reading
        self._reading$.next("");
        // Play the sprite sound and capture the ID.
        var id = self.sound.stop();
        return id;
    },
    /**
     * The step called within requestAnimationFrame to update the playback positions.
     */
    step: function () {
        var self = this;
        // // Loop through all active sounds and update their progress bar.
        for (var i = 0; i < self.sounds.length; i++) {
            var seek = self.sound.seek() || 0;
            for (var j = 0; j < self._spriteLeft.length; j++) {
                // TODO: refactor out into its own function and combine with version in step()
                // if stopped
                if (seek > 0) {
                    // if seek passes sprite start point, replace self._reading with that sprite and slice the array of sprites left
                    if (seek * 1000 >= self._spriteLeft[j][0]) {
                        // only emit sprite if within current audio seek position
                        if (seek * 1000 <= self._spriteLeft[j][2]) {
                            self._reading$.next(self._spriteLeft[j][1]);
                        }
                        self._spriteLeft = self._spriteLeft.slice(j, self._spriteLeft.length);
                    }
                }
            }
            let percent = ((seek / self.sound.duration()) * 100 || 0) + "%";
            self.sounds[i].style.width = percent;
            self.sounds[i].setAttribute("offset", percent);
        }
        requestAnimationFrame(self.step.bind(self));
    },
};
async function isFileAvailable(url) {
    return new Promise(function (resolve, _) {
        let xhr = new XMLHttpRequest();
        xhr.open("HEAD", url);
        xhr.onload = function () {
            if (this.status >= 200 && this.status < 300) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        };
        xhr.onerror = function () {
            resolve(false);
        };
        xhr.send();
    });
}
// returns users preference if it matches current version format
const getUserPreferences = () => {
    const prefs = window.localStorage.getItem(USER_PREFERENCE_STORAGE_ID);
    if (prefs && prefs.length) {
        const user_preferences = JSON.parse(prefs);
        if (user_preferences.version &&
            user_preferences.version === USER_PREFERENCE_VERSION) {
            return user_preferences;
        }
    }
    return null;
};
const setUserPreferences = (userPref) => {
    window.localStorage.setItem(USER_PREFERENCE_STORAGE_ID, JSON.stringify(userPref));
};
const hasUserPreferences = () => {
    return window.localStorage.getItem(USER_PREFERENCE_STORAGE_ID) !== null;
};
const clearUserPreferences = () => {
    window.localStorage.removeItem(USER_PREFERENCE_STORAGE_ID);
};
const sentenceIsAligned = (sentence) => {
    return sentence.innerHTML.includes("</w>");
};

const web_component$2 = {
	page: "Page",
	speed: "Playback Speed",
	"re-align": "Re-align with audio",
	"loading-error": "Error: the <FILETYPE> file \"<FILENAME>\" could not be loaded.",
	"parse-error": "Error: the <FILETYPE> file \"<FILENAME>\" could not be parsed.",
	"alignment-error": "Error: No alignments were found.",
	"image-error": "Error: the file \"<FILENAME>\" is not an image file.",
	loading: "Loading...",
	"line-placeholder": "Type your text here",
	"upload-image": "Upload an image for this page",
	"choose-file": "Choose a file",
	"play-tooltip": "Play/pause audio recording",
	"rewind-tooltip": "Rewind 5 seconds",
	"stop-tooltip": "Stop audio playback",
	"theme-tooltip": "Toggle dark/light mode",
	"full-screen-tooltip": "Full screen mode",
	"translation-tooltip": "Toggle translations",
	"add-translation": "Add a translation, transliteration or gloss",
	"configuration-tooltip": "Preferences",
	settings: "My preferences",
	"page-animation": "Animated page transitions",
	"auto-pause": "Pause at the end of each page",
	language: "Interface language",
	"save-settings": "Remember my preferences",
	"reset-title": "Reset all preferences",
	reset: "Reset",
	eng: "English",
	fra: "French",
	spa: "Spanish",
	close: "Close",
	"annotations-tooltip": "Annotations"
};

const web_component$1 = {
	page: "Page",
	speed: "Vitesse de Lecture",
	"re-align": "Raligner avec l'audio",
	"loading-error": "Erreur: le fichier <FILETYPE> \"<FILENAME>\" n'a pas pu tre charg.",
	"parse-error": "Erreur: le fichier <FILETYPE> \"<FILENAME>\" n'a pas pu tre analys.",
	"alignment-error": "Erreur: aucun alignement n'a t trouv.",
	"image-error": "Erreur: le fichier \"<FILENAME>\" n'est pas un fichier image.",
	loading: "Chargement en cours",
	"line-placeholder": "crivez votre texte ici",
	"upload-image": "Ajouter une image  cette page",
	"choose-file": "Choisir un fichier",
	"play-tooltip": "couter/mettre en pause l'enregistrement",
	"rewind-tooltip": "Reculer de 5 secondes",
	"stop-tooltip": "Arrter la lecture",
	"theme-tooltip": "Basculer en mode sombre/clair",
	"full-screen-tooltip": "Mode plein cran",
	"translation-tooltip": "Afficher ou cacher les traductions",
	"add-translation": "Ajouter une traduction, une translitration ou une glose",
	"configuration-tooltip": "Prfrences",
	settings: "Mes prfrences",
	"page-animation": "Transitions de page animes",
	"auto-pause": "Pause  la fin de chaque page",
	language: "Langue de l'interface",
	"save-settings": "Sauvegarder mes prfrences",
	"reset-title": "Rinitialiser toutes les prfrences",
	reset: "Rinitialiser",
	eng: "Anglais",
	fra: "Franais",
	spa: "Espagnol",
	close: "Fermer",
	"annotations-tooltip": "Annotations"
};

const web_component = {
	page: "Pgina",
	speed: "Velocidad de reproduccin",
	"re-align": "Re-alinear con el audio",
	"loading-error": "Error: el fichero <FILETYPE> \"<FILENAME>\" no se pudo cargar.",
	"parse-error": "Error: el fichero <FILETYPE> \"<FILENAME>\" no se pudo analizar.",
	"alignment-error": "Error: No se encontr ningn alineamiento.",
	"image-error": "Error: el fichero \"<FILENAME>\" no es un archivo de imagen.",
	loading: "Cargando...",
	"line-placeholder": "Escriba su texto aqu",
	"upload-image": "Cargue una imagen para esta pgina",
	"choose-file": "Seleccione un fichero",
	"play-tooltip": "Reproducir/pausar grabacin de audio",
	"rewind-tooltip": "Rebobine (rewind) 5 segundos",
	"stop-tooltip": "Pare la reproduccin de audio",
	"theme-tooltip": "Cambie la paleta de colores",
	"full-screen-tooltip": "Modo pantalla completa",
	"translation-tooltip": "Active o desactive las traducciones",
	"add-translation": "Aada una traduccin, transliteracin o glosa",
	"configuration-tooltip": "Preferencias",
	settings: "Mis preferencias",
	"page-animation": "Transicines de pgina animadas",
	"auto-pause": "Pausa al final de cada pgina",
	language: "Idioma de la interfaz",
	"save-settings": "Recordar mis preferencias",
	"reset-title": "Restablecer todas las preferencias",
	reset: "Reinicializar",
	eng: "Ingls",
	fra: "Francs",
	spa: "Espaol",
	close: "Cerrar",
	"annotations-tooltip": "Anotaciones"
};

const PACKAGE_VERSION = "1.6.3";

const stylesCss = () => `.font-weight--100{font-weight:100}.font-weight--200{font-weight:200}.font-weight--300{font-weight:300}.font-weight--400{font-weight:400}.font-weight--500{font-weight:500}.font-weight--600{font-weight:600}.font-weight--700{font-weight:700}.font-weight--800{font-weight:800}.font-weight--900{font-weight:900}.shadowed{text-shadow:0.3px 0.2px black}.theme--light.settings,.theme--light.page__container,.theme--light.page__col__image,.theme--light.sentence,.theme--light.scroll-guide__container{background-color:#fff}.theme--dark.settings,.theme--dark.page__container,.theme--dark.page__col__image,.theme--dark.sentence,.theme--dark.scroll-guide__container{background-color:rgb(59.9272727273, 67.4181818182, 104.8727272727)}.sentence__text,.sentence__word,.scroll-guide__text{line-height:1.5;border-radius:0.3125em;position:relative;padding:0.0625em;font-size:1em}.theme--light.ripple,.theme--light.reading,.page p.theme--light,.theme--light.sentence__text,.theme--light.sentence__word,.theme--light.scroll-guide__text{color:rgb(4.2909090909, 4.8272727273, 7.5090909091)}.theme--dark.ripple,.theme--dark.reading,.page p.theme--dark,.theme--dark.sentence__text,.theme--dark.sentence__word,.theme--dark.scroll-guide__text{color:#fff}.theme--light.ripple:active,.theme--light.reading:active,.theme--light.sentence__word:hover{color:#fff;background:rgb(127.5, 127.5, 127.5) radial-gradient(circle, transparent 1%, rgb(127.5, 127.5, 127.5) 1%) center/15000%}.theme--dark.ripple:active,.theme--dark.reading:active,.theme--dark.sentence__word:hover{color:#fff;background:rgb(165.75, 165.75, 165.75) radial-gradient(circle, transparent 1%, rgb(165.75, 165.75, 165.75) 1%) center/15000%}.theme--light.sentence__word.reading{color:#fff;background:#666666 radial-gradient(circle, transparent 1%, #666666 1%) center/15000%}.theme--dark.sentence__word.reading{color:rgb(4.2909090909, 4.8272727273, 7.5090909091);background:#fff radial-gradient(circle, transparent 1%, #fff 1%) center/15000%}.theme--light.page__col__img-placeholder{border:0.046875em dotted rgb(127.5, 127.5, 127.5)}.theme--dark.page__col__img-placeholder{border:0.046875em dotted rgb(165.75, 165.75, 165.75)}.theme--light.overlay__container,.theme--light.scroll-guide__container{border:0.046875em solid rgb(127.5, 127.5, 127.5)}.theme--dark.overlay__container,.theme--dark.scroll-guide__container{border:0.046875em solid rgb(165.75, 165.75, 165.75)}.theme--light#annotationsMenu,.theme--light.settings,.theme--light.pages__container,.theme--light.page--multi,.theme--light.control-panel{border-left:0.046875em solid rgb(127.5, 127.5, 127.5)}.theme--dark#annotationsMenu,.theme--dark.settings,.theme--dark.pages__container,.theme--dark.page--multi,.theme--dark.control-panel{border-left:0.046875em solid rgb(165.75, 165.75, 165.75)}.theme--light#annotationsMenu,.theme--light.settings,.theme--light.pages__container,.theme--light.page--multi,.theme--light.control-panel{border-right:0.046875em solid rgb(127.5, 127.5, 127.5)}.theme--dark#annotationsMenu,.theme--dark.settings,.theme--dark.pages__container,.theme--dark.page--multi,.theme--dark.control-panel{border-right:0.046875em solid rgb(165.75, 165.75, 165.75)}.theme--light#annotationsMenu,#annotationsMenu button.theme--light,.theme--light.settings,.settings>.content>.theme--light.preference-btns,.settings>.theme--light.footer,.theme--light.pages__container{border-top:0.046875em solid rgb(127.5, 127.5, 127.5)}.theme--dark#annotationsMenu,#annotationsMenu button.theme--dark,.theme--dark.settings,.settings>.content>.theme--dark.preference-btns,.settings>.theme--dark.footer,.theme--dark.pages__container{border-top:0.046875em solid rgb(165.75, 165.75, 165.75)}.theme--light#annotationsMenu,#annotationsMenu h3.theme--light,#annotationsMenu button.theme--light,.theme--light.settings,.theme--light.control-panel{border-bottom:0.046875em solid rgb(127.5, 127.5, 127.5)}.theme--dark#annotationsMenu,#annotationsMenu h3.theme--dark,#annotationsMenu button.theme--dark,.theme--dark.settings,.theme--dark.control-panel{border-bottom:0.046875em solid rgb(165.75, 165.75, 165.75)}.ripple:hover,.reading:hover,.sentence__word:hover{cursor:pointer}@viewport{width:device-width}button{border:0;cursor:pointer}html{background-color:#fff;box-sizing:border-box;height:100%}*:before,*:after{box-sizing:inherit}body{-webkit-font-smoothing:antialiased;color:rgb(4.2909090909, 4.8272727273, 7.5090909091);font-family:"BCSans", "Noto Sans", Verdana, Arial, sans-serif;min-height:100%;overflow-x:hidden;overflow-y:hidden;text-rendering:optimizeLegibility}a{background:transparent;color:#c69;text-decoration:none;transition:color 0.2s;outline:none}a:active,a:focus{outline:none}img{height:90%;max-width:90%;object-fit:cover}h1,h2,h3,h4,h5,h6{font-family:"BCSans", "Noto Sans", Verdana, Arial, sans-serif;font-weight:normal}p,mat-chip,mat-tab-label,span,button,div,a{font-family:"BCSans", "Noto Sans", Verdana, Arial, sans-serif}.theme--light::-webkit-scrollbar{width:0.5em;height:0.5em}.theme--light::-webkit-scrollbar-track{background:#fff}.theme--light::-webkit-scrollbar-thumb{background:rgb(4.2909090909, 4.8272727273, 7.5090909091);border-radius:0.3125em;height:0.625em;width:0.625em}.theme--dark::-webkit-scrollbar{width:0.5em;height:0.5em}.theme--dark::-webkit-scrollbar-track{background:rgb(59.9272727273, 67.4181818182, 104.8727272727)}.theme--dark::-webkit-scrollbar-thumb{background:#fff;border-radius:0.3125em;height:0.625em;width:0.625em}.bg-img{background-image:url("../assets/img/bg.jpg");height:100vh;overflow:overlay;overflow-x:hidden;background-position:center;background-repeat:no-repeat;background-size:cover;min-height:100%}.shadow-box{box-shadow:0 0.3125rem 1rem 0 rgba(0, 0, 0, 0.24);padding:25px;background:rgba(255, 255, 255, 0.94);border-radius:5px}.font-xs{font-size:0.5em}.font-sm{font-size:0.75em}.font-md{font-size:1em}.font-lg{font-size:1.25em}.font-xl{font-size:1.5em}.font-xxl{font-size:2em}.faded{opacity:0.2;color:black}table{table-layout:fixed}.center{margin-left:auto;margin-right:auto;text-align:center}.container{max-width:80em}.background--light{background:#fff}.stop-color--light{fill:#fff}.color--light{color:rgb(4.2909090909, 4.8272727273, 7.5090909091)}.background--dark{background:rgb(59.9272727273, 67.4181818182, 104.8727272727)}.stop-color--dark{fill:rgb(59.9272727273, 67.4181818182, 104.8727272727)}.color--dark{color:#fff}.abs{position:absolute}.top-0{top:0}.left-0{left:0}.right-0{right:0}.top-5{top:0.3125em}.left-5{left:0.3125em}.right-5{right:0.3125em}.top-10{top:0.625em}.left-10{left:0.625em}.right-10{right:0.625em}.top-15{top:0.9375em}.left-15{left:0.9375em}.right-15{right:0.9375em}.top-20{top:1.25em}.left-20{left:1.25em}.right-20{right:1.25em}.top-25{top:1.5625em}.left-25{left:1.5625em}.right-25{right:1.5625em}.top-30{top:1.875em}.left-30{left:1.875em}.right-30{right:1.875em}.top-35{top:2.1875em}.left-35{left:2.1875em}.right-35{right:2.1875em}.top-40{top:2.5em}.left-40{left:2.5em}.right-40{right:2.5em}.top-45{top:2.8125em}.left-45{left:2.8125em}.right-45{right:2.8125em}.top-50{top:3.125em}.left-50{left:3.125em}.right-50{right:3.125em}.invisible{visibility:hidden !important}.control-panel{border-radius:0 0 0.3125em 0.3125em;position:relative;min-width:100%;display:inline-flex}.control-panel__buttons--left{width:25%;float:left;margin-top:0.3125em;padding:0.3125em}.control-panel__buttons--center{width:25%;text-align:center;margin:0 auto}.control-panel__buttons--right{width:25%;text-align:right;float:right;margin-top:0.3125em;margin-right:0.3125em}.control-panel__buttons__header{margin:0.3125em}.control-panel__control{border-radius:0.3125em;margin:0.5em auto}.control-panel__control:focus{outline:none}.settings{margin-left:0;margin-right:0;text-align:center}.settings__option__header{margin-bottom:0.5em}#waveform{background-size:contain;background-repeat:no-repeat;background-position:center center;width:100%;height:100%;position:absolute;top:0;left:0}.low{z-index:700}.overlay__container{width:100%;max-width:100%;height:3.125em;position:relative;z-index:800}#overlay__object{z-index:700;max-height:100%;min-width:100%;fill:"transparent"}#overlay__object.theme--light{stroke:rgb(127.5, 127.5, 127.5)}#overlay__object.theme--dark{stroke:rgb(165.75, 165.75, 165.75)}.scroll-guide__container{text-align:center;z-index:700;width:20%;position:fixed;left:50%;transform:translate(-50%, 0)}.scroll-guide__text{font-size:1.25em}.pages__container{overflow:auto;max-height:55vh;height:100%;max-width:100%;width:100%;position:relative;display:-webkit-inline-flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;border-radius:0.3125em 0.3125em 0 0;transition:margin-right 0.5s}.page{overflow-y:hidden;overflow-x:auto;flex-grow:1;min-width:99.6%;width:100%;max-width:55em}.page__container{display:grid;grid-template-columns:[col-start] [col-end];grid-template-rows:[row-start] 5% [row-end] 95%;grid-template-areas:"image page-no" "image text";justify-items:stretch}.page__counter{grid-area:page-no;margin:0.625em 0 0 0.9375em;text-align:right;padding-right:0.9375em;max-height:5rem}.page__col__image{grid-area:image;max-height:100%;text-align:center;margin:5%;padding:0;border-radius:0 0 0 0;position:relative}.page__col__image img{max-height:55vh;max-width:95%;object-fit:contain}.page__col__img-placeholder{cursor:pointer}.page__col__text{grid-area:text}.page.two-column-layout-page{grid-template-columns:40% auto}.page.one-column-layout-page{display:flex;flex-direction:row;flex-wrap:wrap;justify-content:center;overflow-y:auto}.page.one-column-layout-page .page__col__image img{max-height:33vh !important}.page.one-column-layout-page .page__counter{width:100%;display:block;text-align:center}.hide-page-counter .page__counter{display:none}.pages__container.vertical{flex-direction:column !important}.pages__container.vertical>.page{min-height:100%}.paragraph__container{overflow-y:auto;min-width:40%;padding-bottom:0.75em}.sentence{margin:0 1.5em;text-align:left;max-width:90%}.sentence__container{margin:3.75em 0.625em 3.75em 0.625em;scroll-behavior:smooth;max-width:100%;position:relative;overflow-y:auto;overflow-x:hidden}.sentence__container__buttons{position:absolute;top:0;right:0}.sentence__text{font-size:1.5em;padding:0}.sentence__word{font-size:1.5em}.sentence__translation .sentence__text,.sentence[annotation-id] .sentence__text,.sentence__translation .sentence__word{color:#777;font-style:italic;font-size:95%}.sentence__translation__button{margin-left:10px}.sentence__translation__button i{font-size:medium}.paragraph.visually_aligned .sentence .sentence__text,.paragraph.visually_aligned .sentence .sentence__word{display:table-cell}.paragraph.visually_aligned .sentence .sentence__text:empty{display:none}.paragraph.visually_aligned{display:table}.paragraph.visually_aligned .sentence{display:table-row}.read-along-container{max-width:75em;margin:0 auto;overflow-y:hidden;overflow-x:hidden;padding:0.3125em;position:relative}.read-along-container--fullscreen{max-width:80%;min-width:80%}.slot__header{margin-bottom:0.3125em}.slot__subheader{margin-top:0;margin-left:1em}.settings-background{position:fixed;top:0;left:0;height:100vh;width:100vw;background-color:rgba(0, 0, 0, 0.075);z-index:900;-webkit-backdrop-filter:blur(5px) !important;backdrop-filter:blur(5px) !important}.settings{height:55vh;max-height:55vh;width:375px;max-width:375px;position:fixed;z-index:1000;top:15vh;left:calc((100% - 375px) / 2);display:flex;flex-direction:column;justify-content:space-between;overflow-x:hidden;transition:0.5s}.settings>div.header{border-bottom:1px solid #ccc;flex-grow:0;flex-shrink:0}.settings>div.header h3 button{float:inline-start;margin-top:0;margin-bottom:0}.settings>div.header h3{padding:10px;margin:0}.settings>div.header>.close{position:relative;float:inline-end;background-color:inherit;color:inherit;font-size:18px;padding:0.275rem 0.75rem;font-weight:400;line-height:1.5;text-align:center;text-decoration:none;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;border:0;transition:color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out}.settings>div.header>.close:hover{color:#fff;background-color:#bb2d3b;border-color:#bb2d3b;box-shadow:inset 0 1px 0 rgba(255, 255, 255, 0.15), 0 1px 1px rgba(0, 0, 0, 0.075)}.settings>.content{flex-grow:10}.settings>.content p{cursor:pointer;text-align:left;color:inherit}.settings>.content p select,.settings>.content p button{margin-right:1em;width:80px;text-align:justify;background-color:transparent !important}.settings>.content p button{margin:0 1em 0 0;padding:0 0.0625em}.settings>.content p{margin:0.5em 1em}.settings>.content p.version{position:absolute;bottom:35px;left:0;right:0;text-align:center}.settings>.content>.preference-btns{height:3em;display:flex;flex-grow:0;flex-shrink:0;flex-direction:row;align-content:space-between;justify-content:space-between}.settings>.content>.preference-btns button{width:75%;border:1px solid #ccc;padding:0.25em 0.5em !important}.settings>.content>.preference-btns button:hover{background-color:rgba(0, 0, 0, 0.15);box-shadow:1px 1px 1px rgba(0, 0, 0, 0.15)}.settings>.footer{padding:0.01em 1em;height:3em;display:flex;flex-grow:0;flex-shrink:0;flex-direction:row;justify-content:space-between;column-gap:1em}.settings>.footer>div{flex-grow:8}.settings>.footer>button{margin-left:0;margin-right:0;border:1px solid #ccc;padding:0.25em 0.5em !important}.settings>.footer>button:hover{background-color:rgba(0, 0, 0, 0.15);box-shadow:1px 1px 1px rgba(0, 0, 0, 0.15)}.settings button:disabled{background-color:rgba(200, 200, 200, 0.15);color:#ccc}.settings p.version{cursor:unset;padding:1em;font-size:0.7em;font-weight:100;color:#ccc}.settings.theme--dark select,.settings.theme--dark select option,.settings.theme--dark{color:#fff}@media screen and (max-width: 385px){.settings{width:95vw;max-width:95vw;left:2.5vw;overflow:auto}.settings p select,.settings p button{display:block;width:80%}.settings p{margin-bottom:1em;border-bottom:1px solid #ccc}}button:focus,input:focus{box-shadow:0 1px 1px rgba(0, 0, 0, 0.15)}#annotationsMenu{position:absolute;bottom:4em;right:0.3125em;z-index:1000;width:fit-content;width:-moz-fit-content;display:flex;flex-direction:column;border-radius:0.3125em}#annotationsMenu h3{margin:0.3125em 0;padding:0.3125em 0.5em}#annotationsMenu button{display:flex;justify-content:flex-start;align-content:baseline;font-size:medium;padding:0.5em}#annotationsMenu button .material-icons-outlined{font-size:inherit;border-radius:0;margin-right:0.3125em}.sentence.invisible[annotation-id]{display:none}.loader{border:16px solid #eee;border-radius:50%;border-right-color:#aa0;border-bottom-color:#a33;border-left-color:#111;width:10rem;height:10rem;-webkit-animation:spin 3s linear infinite;animation:spin 3s linear infinite;position:fixed;top:calc(50vh - 10rem);left:calc(50vw - 10rem);z-index:1000;box-shadow:0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19)}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.alert{display:flex;padding:1rem 1rem;margin-bottom:1rem;border:1px solid transparent;border-radius:0.25rem;transition-delay:2s;transition:visibility 5s, height 5s}.alert.status-success{color:#0f5132;background-color:#d1e7dd;border-color:#badbcc}.alert.status-error{color:#842029;background-color:#f8d7da;border-color:#f5c2c7}.alert.fade{visibility:collapse;height:0 !important;overflow:hidden !important;line-height:0 !important;padding:0 !important;margin:0 !important;border:0 !important}.alert>i.material-icons{padding-inline-end:0.3em}.animate-transition,.ripple,.reading{transition:background 0.4s}.animate-transition:active,.ripple:active,.reading:active{transition:background 0s}.ripple,.reading{background-position:center;padding:0.0625em}.ripple:active,.reading:active{background-size:100%}.progress{position:absolute;top:0;left:0;height:100%;width:0}.progress.theme--light{background-color:rgba(127.5, 127.5, 127.5, 0.2)}.progress.theme--dark{background-color:rgba(165.75, 165.75, 165.75, 0.2)}.material-icons{font-family:"Material Icons";font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:"liga";-webkit-font-smoothing:antialiased}.material-icons-outlined{font-family:"Material Icons Outlined";font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:"liga";-webkit-font-smoothing:antialiased}[contenteditable][data-placeholder]:empty:before{content:attr(data-placeholder);position:absolute;color:gray;cursor:text;background-color:transparent}.drop-area{border:2px dashed #ccc;border-radius:20px;width:50%;font-family:sans-serif;margin:50px auto;padding:20px}.drop-area.highlight{border-color:purple}p{margin-top:0}.my-form{margin-bottom:10px}#gallery{margin-top:10px}#gallery img{width:150px;margin-bottom:10px;margin-right:10px;vertical-align:middle}.button{display:inline-block;padding:10px;background:#ccc;cursor:pointer;border-radius:5px;border:1px solid #ccc}.button:hover{background:#ddd}.fileElem{display:none}#img-remover{margin:0;position:absolute;z-index:700;border-radius:50px;color:red}#image-container{display:contents}`;

const LOADING = 0;
const LOADED = 1;
const ERROR_PARSING = 2;
const ERROR_LOADING = 3;
// The length of time an error message stays on the screen. 0 (and negative)
// values disables this functionality.
const DEFAULT_ERROR_TIMEOUT_MS = 50000;
/**
 * navigatorTheme returns the user's preferred theme, defaults to the
 * light theme.
 */
function navigatorTheme() {
    if (window.matchMedia) {
        if (window.matchMedia("prefers-color-scheme: dark").matches) {
            return "dark";
        }
    }
    return "light";
}
const ReadAlongComponent = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.reading$ = new cjsExports.Subject(); // An RxJs Subject for the current item being read.
        /**
         * Theme to use: ['light', 'dark'] defaults to the user's configured theme.
         */
        this.theme = navigatorTheme();
        /**
         * Language  of the interface. In 639-3 code.
         * Options are "eng" (English), "fra" (French) or "spa" (Spanish)
         */
        this.language = "eng";
        /**
         * i18n strings dicts
         */
        this.i18nStrings = { eng: web_component$2, fra: web_component$1, spa: web_component };
        /**
         * Define a path for where the image assets are located
         * This should be used instead of use-assets-folder.
         * Defaults to 'assets/'. The empty string means that
         * image paths will not have a prefix added to them.
         * Use of the forward slash is optional.
         */
        this.imageAssetsFolder = "assets/";
        /**
         * Toggles the page scrolling from horizontal to vertical. Defaults to horizontal
         *
         */
        this.pageScrolling = "horizontal";
        /**
         * Choose mode of ReadAlong - either view (default) or edit
         */
        this.mode = "VIEW";
        /**
         * Select whether scrolling between pages should be "smooth" (default nicely
         * animated, good for fast computers) or "auto" (choppy but much less compute
         * intensive)
         */
        this.scrollBehaviour = "smooth";
        /**
         * Show text translation  on at load time
         */
        this.displayTranslation = true;
        /**
         * Control the range of the playback rate: allow speeds
         * from 100 - playback-rate-range to 100 + playback-rate-range.
         */
        this.playbackRateRange = 15;
        /**
         * Auto Pause at end of every page
         */
        this.autoPauseAtEndOfPage = false;
        /************
         *  STATES  *
         ************/
        /**
         * Whether audio is playing or not
         */
        this.playing = false;
        this.playback_rate = 1;
        this.fullscreen = false;
        this.autoScroll = true;
        this.hasLoaded = 0;
        this.showGuide = false;
        this.hasTextTranslations = false;
        this.invalidImages = {};
        this.assetsStatus = {
            AUDIO: LOADING,
            RAS: LOADING,
        };
        this.alignment_failed = false;
        this.isScrolling = false;
        this.scrollTimer = null;
        this.endOfPageTags = {};
        this.settingsVisible = false;
        this.userPreferencesDirty = false;
        this.hasUserPreferences = hasUserPreferences();
        this.meta = {};
        this.annotations = [];
        this.annotationsMenuVisible = false;
        /**********
         * RENDER *
         **********/
        /**
         * The Guide element
         */
        this.Guide = () => (index.h("button", { class: "scroll-guide__container ripple ui-button theme--" +
                this.userPreferences.theme, onClick: () => this.hideGuideAndScroll() }, index.h("span", { class: "scroll-guide__text theme--" + this.userPreferences.theme }, this.getI18nString("re-align"))));
        /**
         * Render svg overlay
         */
        this.Overlay = () => (index.h("object", { onClick: (e) => this.goToSeekFromProgress(e), id: "overlay__object", type: "image/svg+xml", data: this.svgOverlay }));
        /**
         * Remove image at given page
         *
         * @param props
         */
        this.RemoveImg = (props) => {
            return (index.h("button", { "data-test-id": "delete-button", "aria-label": "Delete", title: "Delete image", onClick: () => this.deleteImage(props.pageIndex), id: "img-remover", class: "ripple theme--" +
                    this.userPreferences.theme +
                    " background--" +
                    this.userPreferences.theme }, index.h(MatIcon, null, "delete")));
        };
        /**
         * Render image at path 'url' in assets folder.
         *
         * @param props
         */
        this.Img = (props) => {
            return (index.h("div", { class: "image__container page__col__image theme--" +
                    this.userPreferences.theme }, this.mode === "EDIT" && (index.h("span", { id: "image-container" }, index.h(this.RemoveImg, { pageIndex: props.pageIndex }))), index.h("img", { alt: "image", class: "image", src: props.imgURL })));
        };
        this.ImgPlaceHolder = (props) => {
            return (index.h("div", { class: "image__container page__col__image theme--" +
                    this.userPreferences.theme }, index.h("div", { class: "drop-area" }, index.h("form", { class: "my-form" }, index.h("p", { class: "theme--" + this.userPreferences.theme }, this.getI18nString("upload-image")), index.h("input", { type: "file", class: "fileElem", id: "fileElem--" + props.pageID, accept: "image/*", onChange: ($event) => {
                    const el = $event.target;
                    if (el.files.length === 0) {
                        return;
                    }
                    this.handleImageFile(el.files[0], props.pageIndex);
                    el.value = "";
                } }), index.h("label", { class: "button", htmlFor: "fileElem--" + props.pageID }, this.getI18nString("choose-file"))))));
        };
        /**
         * Page Counter element
         *
         * @param props
         *
         * Shows currentPage / pgCount
         */
        this.PageCount = (props) => (index.h("div", { class: "page__counter color--" + this.userPreferences.theme }, this.getI18nString("page"), " ", index.h("span", { "data-test-id": "page-count__current" }, props.currentPage), " / ", index.h("span", { "data-test-id": "page-count__total" }, props.pgCount)));
        this.ImgContainer = (props) => {
            const hasImage = props.pageIndex in this.images && this.images[props.pageIndex] !== null;
            if (hasImage) {
                return (index.h(this.Img, { imgURL: this.images[props.pageIndex], pageIndex: props.pageIndex }));
            }
            if (this.mode === "EDIT") {
                return (index.h(this.ImgPlaceHolder, { pageID: props.pageID, pageIndex: props.pageIndex }));
            }
        };
        /**
         * Page element
         *
         * @param props
         *
         * Show 'Page' or vertically scrollable text content.
         * Text content on 'Page' breaks is separated horizontally.
         */
        this.Page = (props) => (index.h("div", { class: "page page__container page--multi animate-transition  theme--" +
                this.userPreferences.theme +
                " " +
                (props.pageData.attributes["class"]
                    ? props.pageData.attributes["class"].value
                    : ""), id: props.pageData["id"] }, 
        /* Display the PageCount only if there's more than 1 page */
        this.parsed_text.length > 1 ? (index.h(this.PageCount, { pgCount: this.parsed_text.length, currentPage: this.parsed_text.indexOf(props.pageData) + 1 })) : null, index.h(this.ImgContainer, { pageID: props.pageData.id, pageIndex: this.parsed_text.indexOf(props.pageData) }), index.h("div", { class: "page__col__text paragraph__container theme--" +
                this.userPreferences.theme }, 
        /* Here are the Paragraph children */
        props.pageData.paragraphs.map((paragraph) => {
            return (index.h(this.Paragraph, { sentences: Array.from(paragraph.childNodes), attributes: paragraph.attributes }));
        }))));
        /**
         * Paragraph element
         *
         * @param props
         *
         * A paragraph element with one or more sentences
         */
        this.Paragraph = (props) => (index.h("div", Object.assign({}, props.attributes, { class: "paragraph sentence__container theme--" +
                this.userPreferences.theme +
                " " +
                (props.attributes["class"] ? props.attributes["class"].value : "") }), 
        /* Here are the Sentence children */
        props.sentences.map((sentence) => sentence.childNodes.length > 0 && (index.h(this.Sentence, { sentenceData: sentence })))));
        /**
         * Sentence element
         *
         * @param props
         *
         * A sentence element with one or more words
         */
        this.Sentence = (props) => {
            let words = Array.from(props.sentenceData.childNodes);
            let sentenceID = props.sentenceData.id;
            if (!this.hasTextTranslations && props.sentenceData.hasAttribute("class")) {
                this.hasTextTranslations = /translation/.test(props.sentenceData.getAttribute("class"));
            }
            let nodeProps = {};
            //attributes of sentence you want to retain
            for (const attr of ["annotation-id", "do-not-align", "lang", "id"]) {
                if (props.sentenceData.hasAttribute(attr)) {
                    nodeProps[attr] = props.sentenceData.getAttribute(attr);
                }
            }
            if (props.sentenceData.hasAttribute("xml:lang")) {
                nodeProps["lang"] = props.sentenceData.getAttribute("xml:lang");
            }
            if (this.mode === "EDIT" &&
                /translation/.test(props.sentenceData.getAttribute("class")))
                return index.h(index.Fragment, null);
            return (index.h("div", Object.assign({}, nodeProps, { class: "sentence" +
                    " " +
                    (props.sentenceData.hasAttribute("class")
                        ? props.sentenceData.getAttribute("class")
                        : "") +
                    (nodeProps["annotation-id"] ? " invisible" : "") }), 
            /* Here are the Word and NonWordText children */
            words.map((child, c) => {
                if (child.nodeName === "#text") {
                    return (index.h(this.NonWordText, { text: child.textContent, attributes: child.attributes, id: (props.sentenceData.hasAttribute("id")
                            ? props.sentenceData.getAttribute("id")
                            : "P") +
                            "text" +
                            c }));
                }
                else if (child.nodeName === "w" || child.nodeName === "W") {
                    /* It may be uppercase for embedded markup, because in
                         that case it has been parsed as "HTML".  See
                         https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName */
                    return (index.h(this.Word, { text: child.textContent, id: child["id"], attributes: child.attributes }));
                }
                else if (child) {
                    let cnodeProps = {};
                    if (child.hasAttribute("xml:lang"))
                        cnodeProps["lang"] =
                            props.sentenceData.getAttribute("xml:lang");
                    if (child.hasAttribute("lang"))
                        cnodeProps["lang"] = props.sentenceData.getAttribute("lang");
                    return (index.h("span", Object.assign({}, cnodeProps, { class: "sentence__text theme--" +
                            this.userPreferences.theme +
                            (" " + child.className), id: child.id ? child.id : "text_" + c }), child.textContent));
                }
            }), (() => {
                if (this.mode === "EDIT" &&
                    !/translation/.test(props.sentenceData.getAttribute("class"))) {
                    if (sentenceID in this.translations &&
                        sentenceID in this.translations &&
                        this.translations[sentenceID] !== null) {
                        return (index.h("span", { class: "sentence__translation" }, index.h("button", { title: "Remove translation", "aria-label": "Remove translation", "data-test-id": "remove-translation-button", onClick: () => this.removeLine(props.sentenceData), class: "sentence__translation__button remove" }, index.h(MatIcon, null, "remove")), index.h("p", { id: sentenceID + "translation", "data-test-id": "translation-line", class: "sentence__text editable__translation", onInput: (e) => {
                                this.updateTranslation(sentenceID, e.currentTarget.innerText);
                            }, contentEditable: true, onKeyDown: (event) => {
                                if (event.key == "Enter")
                                    event.preventDefault();
                            }, "data-placeholder": this.getI18nString("line-placeholder"), innerHTML: this.translations[sentenceID] })));
                    }
                    else {
                        return (index.h("button", { title: this.getI18nString("add-translation"), "aria-label": "Add translation", "data-test-id": "add-translation-button", class: "sentence__translation sentence__translation__button", onClick: () => this.addLine(props.sentenceData) }, index.h(MatIcon, null, "add")));
                    }
                }
                else {
                    return null;
                }
            })()));
        };
        /**
         * A non-Word text element
         *
         * @param props
         *
         * This is an element that is a child to a Sentence element,
         * but cannot be clicked and is not a word. This is usually
         * inter-Word punctuation or other text.
         */
        this.NonWordText = (props) => {
            let nodeProps = {};
            if (props.attributes && props.attributes["xml:lang"])
                nodeProps["lang"] = props.attributes["xml:lang"].value;
            if (props.attributes && props.attributes["lang"])
                nodeProps["lang"] = props.attributes["lang"].value;
            return (index.h("span", Object.assign({}, nodeProps, { class: "sentence__text theme--" + this.userPreferences.theme, id: props.id }), props.text));
        };
        /**
         * A Word text element
         *
         * @param props
         *
         * This is a clickable, audio-aligned Word element
         */
        this.Word = (props) => {
            let nodeProps = {};
            if (props.attributes && props.attributes["xml:lang"])
                nodeProps["lang"] = props.attributes["xml:lang"].value;
            if (props.attributes && props.attributes["lang"])
                nodeProps["lang"] = props.attributes["lang"].value;
            return (index.h("span", Object.assign({}, nodeProps, { class: "sentence__word theme--" +
                    this.userPreferences.theme +
                    " " +
                    (props && props.attributes["class"]
                        ? props.attributes["class"].value
                        : ""), id: props.id, onClick: (ev) => this.playSprite(ev) }), props.text));
        };
        /**
         * Render controls for ReadAlong
         */
        this.PlayControl = () => (index.h("button", { "data-test-id": "play-button", disabled: !this.isReadyToPlay(), "aria-label": "Play", title: this.getI18nString("play-tooltip"), onClick: () => {
                this.playing ? this.pause() : this.play();
            }, class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, tabindex: 1 }, this.playing ? index.h(MatIcon, null, "pause") : index.h(MatIcon, null, "play_arrow")));
        this.ReplayControl = () => (index.h("button", { "data-test-id": "replay-button", disabled: this.hasLoaded < 2, "aria-label": "Rewind", title: this.getI18nString("rewind-tooltip"), onClick: () => this.goBack(5), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h(MatIcon, null, "replay_5")));
        this.StopControl = () => (index.h("button", { "data-test-id": "stop-button", disabled: this.hasLoaded < 2, "aria-label": "Stop", title: this.getI18nString("stop-tooltip"), onClick: () => this.stop(), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h(MatIcon, null, "stop")));
        this.PlaybackSpeedControl = () => (index.h("div", null, index.h("h5", { class: "control-panel__buttons__header color--" + this.userPreferences.theme, id: "speed-slider-label" }, this.getI18nString("speed")), index.h("input", { type: "range", min: 100 - this.playbackRateRange, max: 100 + this.playbackRateRange, value: this.playback_rate * 100, class: "slider control-panel__control", id: "myRange", "aria-labelledby": "speed-slider-label", onInput: (v) => {
                //console.log("v", v);
                this.changePlayback(v);
            } })));
        this.StyleControl = () => (index.h("button", { "aria-label": "Change theme", title: this.getI18nString("theme-tooltip"), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h(MatIcon, { outline: true }, "style")));
        this.FullScreenControl = () => (index.h("button", { "aria-label": "Full screen mode", onClick: () => this.toggleFullscreen(), title: this.getI18nString("full-screen-tooltip"), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, this.fullscreen ? (index.h(MatIcon, { "aria-label": "Exit full screen mode" }, "fullscreen_exit")) : (index.h(MatIcon, { "aria-label": "Full screen mode" }, "fullscreen"))));
        this.TextAnnotationsControl = () => (index.h("button", { "data-test-id": "annotations-toggle", "aria-label": "Toggle Annotations", title: this.getI18nString("annotations-tooltip"), onClick: () => (this.annotationsMenuVisible = !this.annotationsMenuVisible), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h(MatIcon, { outline: true }, "layers")));
        this.TextTranslationDisplayControl = () => (index.h("button", { "data-test-id": "translation-toggle", "aria-label": "Toggle Translation", title: this.getI18nString("translation-tooltip"), onClick: () => this.toggleTextTranslation(), class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h(MatIcon, { outline: true }, "subtitles")));
        this.ToggleSettingsControl = () => (index.h("button", { "data-test-id": "settings-button", title: this.getI18nString("configuration-tooltip"), onClick: () => this.toggleSettings(), id: "settings-button", class: "control-panel__control ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h(MatIcon, { "aria-label": "Show settings" }, "settings")));
        this.ControlPanel = () => (index.h("div", { "data-test-id": "control-panel", class: "control-panel theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, index.h("div", { class: "control-panel__buttons--left" }, index.h(this.PlayControl, null), index.h(this.ReplayControl, null), index.h(this.StopControl, null)), index.h("div", { class: "control-panel__buttons--center" }, index.h(this.PlaybackSpeedControl, null)), index.h("div", { class: "control-panel__buttons--right" }, this.annotations.length > 0 ? (index.h(this.TextAnnotationsControl, null)) : (this.hasTextTranslations && index.h(this.TextTranslationDisplayControl, null)), window.document.fullscreenEnabled && index.h(this.FullScreenControl, null), index.h(this.ToggleSettingsControl, null))));
        this.Settings = () => (index.h("div", { id: "settings", "data-test-id": "settings", class: "settings  theme--" + this.userPreferences.theme }, index.h("div", { class: "header" }, index.h("button", { class: "close", "data-test-id": "settings-close-button", onClick: () => {
                this.toggleSettings();
            } }, "\u00D7", " "), index.h("h3", null, this.getI18nString("settings"))), index.h("div", { class: "content" }, index.h("p", null, index.h("label", null, index.h("select", { title: this.getI18nString("language"), onChange: (e) => {
                const newLang = e.target.value;
                this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { language: newLang });
                this.userPreferencesDirty = true;
            }, id: "settings-language", "data-test-id": "settings-language", tabindex: 2 }, Object.keys(this.i18nStrings).map((lang) => (index.h("option", { class: `background--${this.userPreferences.theme}`, selected: this.userPreferences.language == lang, value: lang }, this.i18nStrings[lang][lang] || lang)))), this.getI18nString("language"))), index.h("p", { onClick: () => {
                this.changeTheme();
                this.userPreferencesDirty = true;
            }, tabindex: 3 }, index.h(this.StyleControl, null), this.getI18nString("theme-tooltip")), index.h("p", { onClick: () => {
                this.toggleScrollBehavior();
                this.userPreferencesDirty = true;
            }, tabindex: 4 }, index.h("button", { class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, title: this.getI18nString("page-animation"), "data-test-id": "settings-scroll-behavior" }, this.userPreferences.scrollBehaviour === "smooth" ? (index.h(MatIcon, { outline: true }, "check_box")) : (index.h(MatIcon, { outline: true }, "check_box_outline_blank"))), this.getI18nString("page-animation")), index.h("p", { onClick: () => {
                this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { autoPauseAtEndOfPage: !this.userPreferences.autoPauseAtEndOfPage });
                this.userPreferencesDirty = true;
            }, tabindex: 5 }, index.h("button", { class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, title: this.getI18nString("auto-pause"), "data-test-id": "settings-auto-pause" }, this.userPreferences.autoPauseAtEndOfPage ? (index.h(MatIcon, { outline: true }, "check_box")) : (index.h(MatIcon, { outline: true }, "check_box_outline_blank"))), this.getI18nString("auto-pause")), index.h("div", { class: "preference-btns" }, index.h("button", { type: "button", class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, title: this.getI18nString("save-settings"), onClick: () => {
                setUserPreferences(this.userPreferences);
                this.userPreferencesDirty = false;
                this.hasUserPreferences = true;
            }, "data-test-id": "settings-save", disabled: !this.userPreferencesDirty, tabindex: 6 }, this.getI18nString("save-settings"))), index.h("p", { class: "version" }, "@readalongs/web-component version: ", PACKAGE_VERSION)), index.h("div", { class: "footer" }, index.h("button", { type: "button", class: "control-panel__control ripple" +
                ` theme--${this.userPreferences.theme}` +
                ` background--${this.userPreferences.theme}`, title: this.getI18nString("reset-title"), onClick: () => {
                clearUserPreferences();
                this.userPreferences = this.defaultUserPreferences();
                this.userPreferencesDirty = false;
                this.hasUserPreferences = false;
            }, "data-test-id": "reset", disabled: !this.hasUserPreferences && !this.userPreferencesDirty, tabindex: 7 }, this.getI18nString("reset")), index.h("button", { onClick: () => this.toggleSettings(), class: "control-panel__control  ripple theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme, tabindex: 8 }, this.getI18nString("close")))));
        this.AnnotationsMenu = () => {
            return (index.h("div", { id: "annotationsMenu", class: "annotations-menu  theme--" + this.userPreferences.theme }, this.annotations.map((annotation) => (index.h("button", { "data-test-id": "toggle-annotation-" + annotation.id, class: "ripple theme--" +
                    this.userPreferences.theme +
                    " background--" +
                    this.userPreferences.theme, onClick: () => this.toggleTextAnnotation(annotation.id) }, annotation.isVisible ? (index.h(MatIcon, { outline: true }, "check_box")) : (index.h(MatIcon, { outline: true }, "check_box_outline_blank")), annotation.name))), index.h("button", { "data-test-id": "toggle-all-annotations", class: "ripple theme--" +
                    this.userPreferences.theme +
                    " background--" +
                    this.userPreferences.theme, onClick: () => this.toggleTextAnnotation("*") }, index.h(MatIcon, { outline: true }, "layers"), " All")));
        };
    }
    handleScrollEvent() {
        this.isScrolling = true;
        if (this.scrollTimer)
            clearTimeout(this.scrollTimer);
        this.scrollTimer = setTimeout(() => {
            this.isScrolling = false;
        }, 125);
    }
    wheelHandler(event) {
        // only show guide if there is an actual highlighted element
        if (this.el.shadowRoot.querySelector(".reading")) {
            if (event["path"] &&
                event["path"].length > 0 &&
                (event["path"][0].classList.contains("sentence__word") ||
                    event["path"][0].classList.contains("sentence__container") ||
                    event["path"][0].classList.contains("sentence"))) {
                if (this.autoScroll) {
                    let reading_el = this.el.shadowRoot.querySelector(".reading");
                    if (reading_el) {
                        this.autoScroll = !this.inPageContentOverflow(reading_el);
                        this.showGuide = !this.autoScroll;
                    }
                }
            }
        }
    }
    // handle cases where user presses esc to cancel full screen
    fullScreenHandler() {
        this.fullscreen = window.document.fullscreenElement != null;
    }
    handleKeyDown(event) {
        //dismiss setting modal user pressing escape
        if (event.key === "Escape" && this.settingsVisible) {
            this.settingsVisible = false;
        }
    }
    /***********
     *  UTILS  *
     ***********/
    /**
     * Transforms a given path to either use the default assets folder or rely on the absolute path given
     * @param path
     * @return string
     */
    urlTransform(path) {
        // Frankenstein of combined useAssetsFolder v1.1.1 functionality and imageAssetsFolder v2.0.0 functionality
        // TODO: delete this first if statement and all occurrences of useAssetsFolder for v2.0.0
        if (this.useAssetsFolder !== undefined) {
            // Old v1.1.1 functionality
            if (this.useAssetsFolder &&
                looksLikeRelativePath(path) &&
                !path.startsWith("blob")) {
                return "assets/" + path;
            }
            else {
                return path;
            }
        }
        else if (this.imageAssetsFolder &&
            looksLikeRelativePath(path) &&
            !path.startsWith("blob")) {
            if (this.imageAssetsFolder && !this.imageAssetsFolder.endsWith("/")) {
                this.imageAssetsFolder += "/";
            }
            return this.imageAssetsFolder + path;
        }
        return path;
        function looksLikeRelativePath(path) {
            return !/^(https?:[/][/]|assets[/]|data:)/.test(path);
        }
    }
    /**
     * Given an audio file path and a parsed alignment object,
     * build a Sprite object
     * @param audio
     * @param alignment
     */
    buildSprite(audio, alignment) {
        return new Sprite({
            src: [audio],
            sprite: alignment,
            rate: this.playback_rate,
        });
    }
    /**
     * Add escape characters to query selector param
     * @param id
     */
    tagToQuery(id) {
        id = id.replace(".", "\\.");
        id = id.replace("#", "\\#");
        return "#" + id;
    }
    /**
     * Return HTML element of word closest to second s
     *
     * @param s seconds
     */
    returnWordClosestTo(s) {
        let keys = Object.keys(this.processed_alignment);
        // remove 'all' sprite as it's not a word.
        keys.pop();
        for (let i = 1; i < keys.length; i++) {
            if (s * 1000 > this.processed_alignment[keys[i]][0] &&
                this.processed_alignment[keys[i + 1]] &&
                s * 1000 < this.processed_alignment[keys[i + 1]][0]) {
                return this.el.shadowRoot.querySelector(this.tagToQuery(keys[i]));
            }
        }
    }
    /**
     * Return the file path given the asset_type
     */
    getPathFromAssetType(asset_type) {
        if (asset_type === "AUDIO") {
            return this.audio;
        }
        else if (asset_type === "RAS") {
            return this.href;
        }
        else {
            return "Asset Path Not Supported";
        }
    }
    /**
     * toggle the setting pane visiblilty
     */
    toggleSettings() {
        //pause audio if playing and setting modal is being presented
        if (this.playing) {
            this.pause();
        }
        this.settingsVisible = !this.settingsVisible;
    }
    /**
     * toggle (override) scrolling animation
     */
    toggleScrollBehavior() {
        this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { scrollBehaviour: this.userPreferences.scrollBehaviour === "auto" ? "smooth" : "auto" });
    }
    /*************
     *   AUDIO   *
     *************/
    /**
     * Change playback between .75 and 1.25. To change the playback options,
     * change the HTML in the function renderControlPanel
     *
     * @param ev
     */
    changePlayback(ev) {
        let inputEl = ev.currentTarget;
        this.playback_rate = parseInt(inputEl.value) / 100;
        this.audio_howl_sprites.sound.rate(this.playback_rate);
    }
    /**
     *  Go back s milliseconds
     *
     * @param s
     */
    goBack(s) {
        this.autoScroll = false;
        if (this.play_id) {
            this.audio_howl_sprites.goBack(this.play_id, s);
        }
        setTimeout(() => (this.autoScroll = true), 100);
    }
    /**
     * Go to seek
     *
     * @param seek number
     *
     */
    goTo(seek) {
        if (this.play_id === undefined) {
            this.play();
            this.pause();
        }
        //allow display to bring the selected portion into view
        this.autoScroll = true;
        seek = seek / 1000;
        this.audio_howl_sprites.goTo(this.play_id, seek);
        setTimeout(() => (this.autoScroll = true), 100);
    }
    /**
     * Go to seek from id
     *
     * @param ev
     */
    goToSeekAtEl(ev) {
        let el = ev.currentTarget;
        let tag = el.id;
        let seek = this.processed_alignment[tag][0];
        this.goTo(seek);
        return tag;
    }
    /**
     * Go to seek from progress bar
     */
    goToSeekFromProgress(ev) {
        let el = ev.currentTarget;
        let client_rect = el.getBoundingClientRect();
        // get offset of clicked element
        let offset = client_rect.left;
        // get width of clicked element
        let width = client_rect.width;
        // get click point
        let click = ev.pageX - offset;
        // get seek in milliseconds
        let seek = (click / width) * this.duration * 1000;
        this.goTo(seek);
    }
    /**
     * Pause audio.
     */
    pause() {
        if (this.playing) {
            this.playing = false;
            this.audio_howl_sprites.pause();
        }
    }
    /**
     * Play the current audio, or start a new play of all
     * the audio
     *
     *
     */
    play() {
        //do not attempt to play if sprites are not initialized
        if (this.audio_howl_sprites === undefined)
            return;
        this.playing = true;
        // If already playing once, continue playing
        if (this.play_id !== undefined) {
            this.play_id = this.audio_howl_sprites.play(this.play_id);
        }
        else {
            // else, start a new play
            this.play_id = this.audio_howl_sprites.play("all");
        }
        // animate the progress bar
        this.animateProgress();
    }
    /**
     * Seek to an element with id 'id', then play it
     *
     * @param ev
     */
    playSprite(ev) {
        let tag = this.goToSeekAtEl(ev);
        if (!this.playing) {
            this.audio_howl_sprites.play(tag);
        }
    }
    /**
     * Stop the sound and remove all active reading styling
     */
    stop() {
        this.playing = false;
        this.play_id = undefined;
        if (this.audio_howl_sprites) {
            this.audio_howl_sprites.stop();
        }
        this.el.shadowRoot
            .querySelectorAll(".reading")
            .forEach((x) => x.classList.remove("reading"));
        if (!this.autoScroll) {
            this.autoScroll = true;
            this.showGuide = false;
        }
    }
    /**
     * toggle the visibility of translation text
     */
    toggleTextTranslation() {
        this.el.shadowRoot
            .querySelectorAll(".translation, .sentence__translation, [annotation-id]")
            .forEach((translation) => translation.classList.toggle("invisible"));
    }
    /**
     * Toggle the visibility of annotation layers (sentences)
     * if id is set to * it toggles all layers
     * @param annotationId
     */
    toggleTextAnnotation(annotationId) {
        this.el.shadowRoot
            .querySelectorAll("[annotation-id" +
            (annotationId === "*" ? "]" : '="' + annotationId + '"]'))
            .forEach((annotationElem) => annotationElem.classList.toggle("invisible"));
        this.annotations = this.annotations.map((annotationObj) => {
            if (annotationObj.id == annotationId || annotationId === "*")
                annotationObj.isVisible = !annotationObj.isVisible;
            return annotationObj;
        });
    }
    /*************
     * ANIMATION *
     *************/
    /**
     * Remove highlighting from every other word and add it to el
     *
     * @param el
     */
    addHighlightingTo(el) {
        this.el.shadowRoot
            .querySelectorAll(".reading")
            .forEach((x) => x.classList.remove("reading"));
        el.classList.add("reading");
    }
    /**
     * Animate the progress through the overlay svg
     */
    animateProgressWithOverlay() {
        // select svg container
        let wave__container = this.el.shadowRoot.querySelector("#overlay__object");
        // use svg container to grab fill and trail
        let fill = wave__container.contentDocument.querySelector("#progress-fill");
        let trail = wave__container.contentDocument.querySelector("#progress-trail");
        let base = wave__container.contentDocument.querySelector("#progress-base");
        fill.classList.add("stop-color--" + this.userPreferences.theme);
        base.classList.add("stop-color--" + this.userPreferences.theme);
        // push them to array to be changed in step()
        this.audio_howl_sprites.sounds.push(fill);
        this.audio_howl_sprites.sounds.push(trail);
        // When this sound is finished, remove the progress element.
        this.audio_howl_sprites.sound.once("end", () => {
            this.audio_howl_sprites.sounds.forEach((x) => {
                x.setAttribute("offset", "0%");
            });
            this.el.shadowRoot
                .querySelectorAll(".reading")
                .forEach((x) => x.classList.remove("reading"));
            this.playing = false;
            // }
        }, this.play_id);
    }
    /**
     * Animate the progress if no svg overlay is provided
     *
     * @param play_id
     * @param tag
     */
    animateProgressDefault(play_id, tag) {
        let elm = document.createElement("div");
        elm.className = "progress theme--" + this.userPreferences.theme;
        elm.id = play_id.toString();
        elm.dataset.sprite = tag;
        let query = this.tagToQuery(tag);
        this.el.shadowRoot.querySelector(query).appendChild(elm);
        this.audio_howl_sprites.sounds.push(elm);
        // When this sound is finished, remove the progress element.
        this.audio_howl_sprites.sound.once("end", () => {
            // this.audio_howl_sprites = [];
            this.el.shadowRoot
                .querySelectorAll(".reading")
                .forEach((x) => x.classList.remove("reading"));
            this.playing = false;
            // }
        }, this.play_id);
    }
    /**
     * Animate progress, either by default or with svg overlay.
     */
    animateProgress(play_id = this.play_id) {
        // Start animating progress
        if (this.svgOverlay) {
            // either with svg overlay
            this.animateProgressWithOverlay();
        }
        else if (play_id) {
            // or default progress bar
            this.animateProgressDefault(play_id, "all");
        }
    }
    /**
     * Change fill colour to match theme
     */
    changeFill() {
        // Get theme contrast from the computed color of a word
        let contrast_el = this.el.shadowRoot.querySelector(".sentence__word");
        let contrast = window.getComputedStyle(contrast_el).color;
        // select svg container
        let wave__container = this.el.shadowRoot.querySelector("#overlay__object");
        // use svg container to grab fill and trail
        let fill = wave__container.contentDocument.querySelector("#progress-fill");
        let base = wave__container.contentDocument.querySelector("#progress-base");
        // select polygon
        let polygon = wave__container.contentDocument.querySelector("#polygon");
        polygon.setAttribute("stroke", contrast);
        base.setAttribute("stop-color", contrast);
        fill.setAttribute("stop-color", contrast);
    }
    /**
     * Get Current Word
     */
    async getCurrentWord() {
        return this.reading$;
    }
    /**
     * Get Images
     */
    async getImages() {
        return this.images;
    }
    /**
     * Update Single Sprite
     */
    async updateSpriteAlignments(alignment) {
        this.stop();
        this.processed_alignment = alignment;
        this.attachScrollingLogicToAudio();
    }
    /**
     * Get ReadAlong Element
     */
    async getReadAlongElement() {
        return this.el;
    }
    /**
     * Get Alignments
     */
    async getAlignments() {
        return this.processed_alignment;
    }
    /**
     * Get Translations
     */
    async getTranslations() {
        return this.translations;
    }
    /**
     * Change theme
     */
    async changeTheme() {
        const newTheme = this.userPreferences.theme === "light" ? "dark" : "light";
        this.userPreferences = Object.assign(Object.assign({}, this.userPreferences), { theme: newTheme });
    }
    /**
     * Update stylesheet
     * @param url
     */
    async setCss(url) {
        this.cssUrl = url;
    }
    /**
     * Add custom font
     */
    async addCustomFont(fontData) {
        const style = document.createElement("style");
        style.setAttribute("id", "ra-wc-custom-font");
        style.setAttribute("type", "text/css");
        style.innerHTML = fontData;
        document.head.appendChild(style);
    }
    /**
     * Return the Sentence Container of Word
     * Currently the 3rd parent up the tree node
     * @param element
     * @private
     */
    static _getSentenceContainerOfWord(element) {
        return element.parentElement.parentElement.parentElement;
    }
    /**
     * Make Fullscreen
     */
    toggleFullscreen() {
        let fullScreenPromise;
        if (!this.fullscreen) {
            let elem = this.el.shadowRoot.getElementById("read-along-container");
            if (elem.requestFullscreen) {
                fullScreenPromise = elem.requestFullscreen();
            }
            else if (elem.mozRequestFullScreen) {
                /* Firefox */
                fullScreenPromise = elem.mozRequestFullScreen();
            }
            else if (elem.webkitRequestFullscreen) {
                /* Chrome, Safari and Opera */
                fullScreenPromise = elem.webkitRequestFullscreen();
            }
            else if (elem.msRequestFullscreen) {
                /* IE/Edge */
                fullScreenPromise = elem.msRequestFullscreen();
            }
            fullScreenPromise.then(() => {
                this.fullscreen = true;
                this.el.shadowRoot
                    .getElementById("read-along-container")
                    .classList.add("read-along-container--fullscreen");
            });
        }
        else {
            let document = this.el.ownerDocument;
            if (document.exitFullscreen) {
                fullScreenPromise = document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                /* Firefox */
                fullScreenPromise = document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                /* Chrome, Safari and Opera */
                fullScreenPromise = document.webkitExitFullscreen();
            }
            else if (document.msExitFullscreen) {
                /* IE/Edge */
                fullScreenPromise = document.msExitFullscreen();
            }
            fullScreenPromise.then(() => {
                this.fullscreen = false;
                this.el.shadowRoot
                    .getElementById("read-along-container")
                    .classList.remove("read-along-container--fullscreen");
            });
        }
    }
    /*************
     * SCROLLING *
     *************/
    hideGuideAndScroll() {
        let reading_el = this.el.shadowRoot.querySelector(".reading");
        // observe when element is scrolled to, then remove the scroll guide and unobserve
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                intersectionObserver.unobserve(reading_el);
            }
        });
        intersectionObserver.observe(reading_el);
        this.scrollTo(reading_el);
    }
    //for when you visually align content
    inParagraphContentOverflow(element) {
        let para_el = ReadAlongComponent._getSentenceContainerOfWord(element);
        let para_rect = para_el.getBoundingClientRect();
        let el_rect = element.getBoundingClientRect();
        // element being read is left of the words being viewed
        let inOverflowLeft = el_rect.right < para_rect.left;
        // element being read is right of the words being viewed
        let inOverflowRight = el_rect.right > para_rect.right;
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                intersectionObserver.unobserve(element);
            }
        });
        intersectionObserver.observe(element);
        // if not in overflow, return false
        return inOverflowLeft || inOverflowRight;
    }
    inPageContentOverflow(element) {
        let page_el = this.el.shadowRoot.querySelector("#" + this.current_page);
        let page_rect = page_el.getBoundingClientRect();
        let el_rect = element.getBoundingClientRect();
        // element being read is below/ahead of the words being viewed
        let inOverflowBelow = el_rect.top + el_rect.height > page_rect.top + page_rect.height;
        // element being read is above/behind of the words being viewed
        //even if it is barely above the view
        let inOverflowAbove = el_rect.top < page_rect.top;
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                // IT IS VISIBLE
                inOverflowAbove = inOverflowBelow = false;
                intersectionObserver.unobserve(element);
            }
        });
        intersectionObserver.observe(element);
        // if not in overflow, return false
        return inOverflowAbove || inOverflowBelow;
    }
    inPage(element) {
        let sent_el = ReadAlongComponent._getSentenceContainerOfWord(element);
        let sent_rect = sent_el.getBoundingClientRect();
        let el_rect = element.getBoundingClientRect();
        // element being read is below/ahead of the words being viewed
        let inOverflowBelow = el_rect.top + el_rect.height > sent_rect.top + sent_rect.height;
        // element being read is above/behind of the words being viewed
        let inOverflowAbove = el_rect.top + el_rect.height < 0;
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                setTimeout(() => {
                    this.showGuide = false;
                    this.autoScroll = true;
                }, 100);
                intersectionObserver.unobserve(element);
            }
        });
        intersectionObserver.observe(element);
        // if not in overflow, return false
        return inOverflowAbove || inOverflowBelow;
    }
    scrollToPage(pg_id) {
        let page_container = this.el.shadowRoot.querySelector(".pages__container");
        let next_page = this.el.shadowRoot.querySelector("#" + pg_id);
        page_container.scrollBy({
            top: this.pageScrolling.match("vertical") != null
                ? next_page.offsetTop - page_container.scrollTop
                : 0,
            left: this.pageScrolling.match("vertical") != null
                ? 0
                : next_page.offsetLeft - page_container.scrollLeft,
            behavior: this.userPreferences.scrollBehaviour,
        });
        next_page.scrollTo(0, 0); //reset to top of the page
    }
    scrollByHeight(el) {
        let sent_container = ReadAlongComponent._getSentenceContainerOfWord(el); //get the direct parent sentence container
        let anchor = el.parentElement.getBoundingClientRect();
        let intersectionObserver = new IntersectionObserver((entries) => {
            let [entry] = entries;
            if (entry.isIntersecting) {
                intersectionObserver.unobserve(el);
            }
            else {
                sent_container.scrollTo({
                    top: sent_container.getBoundingClientRect().height - anchor.height, // negative value
                    // acceptable
                    left: 0,
                    behavior: this.userPreferences.scrollBehaviour,
                });
            }
        }, {
            root: sent_container,
            threshold: [0, 0.25, 0.5, 0.75, 1],
        });
        intersectionObserver.observe(el);
    }
    //scrolling within the visually aligned paragraph
    scrollByWidth(el) {
        let sent_container = ReadAlongComponent._getSentenceContainerOfWord(el); //get the direct parent sentence container
        let anchor = el.getBoundingClientRect();
        sent_container.scrollTo({
            left: anchor.left - 10, // negative value acceptable
            top: 0,
            behavior: this.userPreferences.scrollBehaviour,
        });
    }
    scrollTo(el) {
        el.scrollIntoView({
            behavior: this.userPreferences.scrollBehaviour,
        });
    }
    /*************
     * LIFECYCLE *
     *************/
    /**
     * When the component is disconnected, stop all audio.
     *
     */
    disconnectedCallback() {
        this.stop();
    }
    /**
     * When the component updates, change the fill of the progress bar.
     * This is because the fill colour is determined by a computed CSS
     * value set by the Web Component's theme. When the @prop theme changes and
     * the component updates, we have to update the fill with the new
     * computed CSS value.
     */
    componentDidUpdate() {
        if (this.svgOverlay) {
            this.changeFill();
        }
    }
    /**
     * construct a valid default user preferences object, using the provided
     * component properties.
     */
    defaultUserPreferences() {
        const prefs = {
            version: USER_PREFERENCE_VERSION,
            autoPauseAtEndOfPage: this.autoPauseAtEndOfPage,
            scrollBehaviour: this.scrollBehaviour.toLowerCase(),
            language: this.language.toLowerCase(),
            theme: this.theme.toLowerCase(),
        };
        // Make sure scroll-behaviour is valid
        if (prefs.scrollBehaviour !== "smooth" &&
            prefs.scrollBehaviour !== "auto") {
            console.error("Invalid scroll-behaviour value, using default (smooth)");
            prefs.scrollBehaviour = "smooth";
        }
        // The backward compatible behaviour used to be audio, alignment and text files outside assets
        // and only image files inside assets.
        // See version 0.1.0, where it only looks in assets/ for images, nothing else.
        // TO maintain backwards compatibility handle assets url
        //this.audio = this.urlTransform(this.audio)
        //this.alignment = this.urlTransform(this.alignment)
        //this.text = this.urlTransform(this.text)
        //this.cssUrl = this.urlTransform(this.cssUrl)
        // Maintains backwards compatibility with ISO 639-1 language codes.
        const acceptedLanguages = {
            en: "eng",
            eng: "eng",
            fr: "fra",
            fra: "fra",
            es: "spa",
            spa: "spa",
        };
        prefs.language = acceptedLanguages[prefs.language] || "eng";
        return prefs;
    }
    /**
     * Using this Lifecycle hook to handle backwards compatibility of component attribute
     */
    async componentWillLoad() {
        this.userPreferences = getUserPreferences();
        if (!this.userPreferences) {
            this.userPreferences = this.defaultUserPreferences();
        }
        // Make sure playback-rate-range is valid
        if (isNaN(this.playbackRateRange) ||
            this.playbackRateRange < 0 ||
            this.playbackRateRange > 99) {
            console.error("Invalid playback-rate-range value, using default (15).");
            this.playbackRateRange = 15;
        }
        // TODO: if parseRAS has an error, we need ERROR_PARSING
        // Parse the text to be displayed
        const text = this.el.querySelector("read-along > text");
        if (text) {
            this.parsed_text = extractPages(text);
            this.meta = extractMeta(this.el);
        }
        else {
            const doc = await parseRAS(this.href);
            this.parsed_text = doc.pages;
            this.meta = doc.meta;
        }
        if (this.parsed_text === null) {
            this.parsed_text = [];
            this.assetsStatus.RAS = ERROR_LOADING;
        }
        else if (this.parsed_text.length === 0) {
            this.assetsStatus.RAS = ERROR_PARSING;
        }
        else {
            this.images = {};
            this.translations = {};
            for (const [i, page] of this.parsed_text.entries()) {
                if ("img" in page) {
                    var imageURL = this.urlTransform(page.img);
                    this.images[i] = this.urlTransform(page.img);
                    if (/^(https?:[/]|assets)[/]\b/.test(imageURL)) {
                        let isAvailable = await isFileAvailable(imageURL);
                        if (!isAvailable) {
                            this.images[i] = null;
                        }
                    }
                }
                else {
                    this.images[i] = null;
                }
                //get the ids for the last word on each the page
                if ("paragraphs" in page) {
                    try {
                        const paragraphs = page.paragraphs;
                        const sentences = paragraphs[paragraphs.length - 1].querySelectorAll("s:not(.translation), s:not(.sentence__translation)"); //get non-translation sentences in the last paragraph
                        const word = sentences[sentences.length - 1].querySelector("w:last-of-type"); //get the last word of the last sentence
                        this.endOfPageTags[word.id] = [
                            parseFloat(word.getAttribute("time")), //in seconds
                            parseFloat(word.getAttribute("dur")) * 1000, // in milliseconds
                        ];
                        this.finalTaggedWord = word.id; // do not pause on the last word of the read-along
                    }
                    catch (err) { }
                    let lastAlignedSentenceId = null;
                    //get the translations
                    page.paragraphs
                        .map((paragraph) => paragraph.querySelectorAll("s"))
                        .forEach((sentences) => {
                        if (sentences.length) {
                            sentences.forEach((sentence) => {
                                if (sentence.id && sentenceIsAligned(sentence)) {
                                    lastAlignedSentenceId = `${sentence.id}`;
                                }
                                else if (/translation/.test(sentence.className)) {
                                    const translation = {};
                                    if (sentence.hasAttribute("sentence-id")) {
                                        let sentenceID = sentence.getAttribute("sentence-id");
                                        translation[sentenceID] = sentence.textContent;
                                        this.translations = Object.assign(Object.assign({}, this.translations), translation);
                                    }
                                    else if (lastAlignedSentenceId != null) {
                                        translation[lastAlignedSentenceId] = sentence.textContent;
                                        lastAlignedSentenceId = null;
                                        this.translations = Object.assign(Object.assign({}, this.translations), translation);
                                    }
                                }
                            });
                        }
                    });
                }
            }
            // this.parsed_text.map((page, i) => page.img ? [i, page.img] : [i, null])
            /**
             * parse defined annotations information from the .readalong meta
             * annotations-id defines the id of each layer
             * annotations-labels defines the display label for each layer
             * annotations-label-{locale} defines the localized display label for each layer
             * all lists are delimited by comma
             */
            if (this.meta["annotations-ids"]) {
                const delimiter = ",";
                const labels = this.meta["annotations-labels-" + this.userPreferences.language]
                    ? this.meta["annotations-labels-" + this.userPreferences.language]
                    : this.meta["annotations-labels"];
                const annotationNames = labels ? labels.split(delimiter) : [];
                this.meta["annotations-ids"]
                    .split(delimiter)
                    .forEach((annotation, l) => {
                    var _a;
                    this.annotations.push({
                        isVisible: false, //hide by default
                        name: (_a = annotationNames[l].trim()) !== null && _a !== void 0 ? _a : annotation.trim(),
                        id: annotation.trim(),
                    });
                });
            }
            this.assetsStatus.RAS = LOADED;
        }
        this.hasLoaded += 1;
    }
    /**
     * Lifecycle hook: after component loads, build the Sprite and parse the files necessary.
     * Then subscribe to the _reading$ Subject in order to update CSS styles when new element
     * is being read
     */
    componentDidLoad() {
        const bcSansFontCssUrl = "https://unpkg.com/@bcgov/bc-sans@1.0.1/css/BCSans.css";
        const iconsFontCssUrl = "https://fonts.googleapis.com/css2?family=Material+Icons&family=Material+Icons+Outlined&display=swap";
        [bcSansFontCssUrl, iconsFontCssUrl]
            .filter((url) => !document.querySelector(`link[href="${url}"]`))
            .forEach((url) => {
            const el = document.createElement("link");
            el.setAttribute("rel", "stylesheet");
            el.setAttribute("href", url);
            document.head.appendChild(el);
        });
        this.processed_alignment = extractAlignment(this.parsed_text);
        this.alignment_failed = Object.keys(this.processed_alignment).length == 0;
        // load basic Howl
        this.audio_howl = new howlerExports.Howl({
            src: [this.audio],
            html5: isIOS(),
            preload: false,
        });
        // Once loaded, get duration and build Sprite
        this.audio_howl.once("load", () => {
            this.attachScrollingLogicToAudio();
        });
        // Handle load errors
        this.audio_howl.once("loaderror", () => {
            this.hasLoaded += 1;
            this.assetsStatus.AUDIO = ERROR_LOADING;
        });
        this.audio_howl.load();
    }
    attachScrollingLogicToAudio() {
        this.processed_alignment["all"] = [0, this.audio_howl.duration() * 1000];
        this.duration = this.audio_howl.duration();
        this.audio_howl_sprites = this.buildSprite(this.audio, this.processed_alignment);
        // Once Sprites are built, subscribe to reading subject and update element class
        // when new distinct values are emitted
        this.audio_howl_sprites._reading$
            .pipe(operatorsExports.distinctUntilChanged())
            .subscribe((el_tag) => {
            // Update the main reading tag subject
            this.reading$.next(el_tag);
            //if stop
            if (el_tag == "")
                return;
            //if auto pause is active and not on last word of the read along pause the audio
            if (this.playing &&
                this.userPreferences.autoPauseAtEndOfPage &&
                el_tag in this.endOfPageTags &&
                this.finalTaggedWord !== el_tag) {
                //clear previous timeout if active
                if (this.autoPauseTimer)
                    window.clearTimeout(this.autoPauseTimer);
                //pause 25ms before end of word
                this.autoPauseTimer = window.setTimeout(() => {
                    this.pause();
                }, this.endOfPageTags[el_tag][1] - 25);
            }
            // Turn tag to query
            let query = this.tagToQuery(el_tag);
            if (query === undefined)
                return; // not go any further if tag does not exist in the DOM
            // select the element with that tag
            let query_el = this.el.shadowRoot.querySelector(query);
            // Remove all elements with reading class
            this.el.shadowRoot
                .querySelectorAll(".reading")
                .forEach((x) => x.classList.remove("reading"));
            // Add reading to the selected el
            query_el.classList.add("reading");
            // Scroll horizontally (to different page) if needed
            let current_page = ReadAlongComponent._getSentenceContainerOfWord(query_el).parentElement
                .id;
            if (current_page !== this.current_page) {
                if (this.current_page !== undefined && !this.isScrolling) {
                    this.scrollToPage(current_page);
                }
                this.current_page = current_page;
            }
            const leftEdge = Math.ceil(this.el.shadowRoot
                .querySelector(".pages__container")
                .getBoundingClientRect().left) + 1;
            const pageLeftEdge = Math.ceil(this.el.shadowRoot
                .querySelector("#" + this.current_page)
                .getBoundingClientRect().left);
            //if the user has scrolled away from the from the current page bring them page
            if (query_el.getBoundingClientRect().left < 0 ||
                pageLeftEdge !== leftEdge) {
                if (!this.isScrolling)
                    this.scrollToPage(current_page);
            }
            // scroll vertically (through paragraph) if needed
            if (this.inPageContentOverflow(query_el)) {
                if (this.autoScroll) {
                    query_el.scrollIntoView({ block: "start", inline: "nearest" });
                    if (!this.isScrolling)
                        this.scrollByHeight(query_el);
                }
            } // scroll horizontal (through paragraph) if needed
            if (this.inParagraphContentOverflow(query_el)) {
                if (this.autoScroll) {
                    query_el.scrollIntoView(false);
                    if (!this.isScrolling)
                        this.scrollByWidth(query_el);
                }
            }
        });
        this.hasLoaded += 1;
        this.assetsStatus.AUDIO = LOADED;
    }
    componentDidRender() {
        //if creator does not want the translation to show at load time
        if (!this.displayTranslation &&
            this.parsed_text &&
            this.parsed_text.length > 0) {
            this.toggleTextTranslation();
            this.displayTranslation = true;
        }
        if (this.latestTranslation) {
            // Add focus to the latest translation line that was added
            let newLine = this.el.shadowRoot.querySelector(this.latestTranslation);
            newLine.focus();
            this.latestTranslation = "";
        }
    }
    /**
     * Is the App ready to start playing
     * This could be expressed as one line
     * but because there are multiple states involved
     * breaking it down to make it easier to track
     */
    isReadyToPlay() {
        //not ready if still audio & alignment is not loaded
        if (this.hasLoaded < 2)
            return false;
        //not ready if
        if (this.audio_howl_sprites === undefined)
            return false;
        //not ready if
        if (this.audio_howl_sprites.sound === undefined)
            return false;
        return true; //it is ready
    }
    /**********
     *  LANG  *
     **********/
    /**
     * Helper function for getI18nString()
     * @param key  the key of the string to lookup
     * @returns the requested string found i18n/messages.{this.language}.json
     */
    getRawI18nString(key) {
        if (this.i18nStrings[this.userPreferences.language] &&
            this.i18nStrings[this.userPreferences.language][key]) {
            return this.i18nStrings[this.userPreferences.language][key];
        }
        else if (this.i18nStrings.eng[key]) {
            // Fallback to English if the string does not exist for this.language
            return this.i18nStrings.eng[key];
        }
        else {
            // Last fallback in case it's not found anywhere, because we never want to just fail
            return key;
        }
    }
    /**
     * Any text used in the Web Component should be at least bilingual in English and French.
     * To add a new term, add a new key to each messages.*.json file in ../../i18n
     * and give the translations as values.
     *
     * Subsitution semantics: given substitution = { "STR1": "value1", "STR2": "value2" },
     * the text "foo <STR1> bar <STR2> baz" will replaced by "foo value1 bar value2 baz".
     *
     * @param key  short name for the text to fetch
     * @param substitutions  optional list of subtitutions to perform
     * @returns  the string in language this.language for key
     */
    getI18nString(key, substitutions = {}) {
        let result = this.getRawI18nString(key);
        for (const [sub_key, value] of Object.entries(substitutions)) {
            result = result.replace("<" + sub_key + ">", value);
        }
        return result;
    }
    /**********
     *  EDIT  *
     **********/
    addLine(sentence_element) {
        if (!this.hasTextTranslations) {
            this.hasTextTranslations = true;
        }
        let newTranslation = {};
        newTranslation[sentence_element.id] = "";
        this.translations = Object.assign(Object.assign({}, this.translations), newTranslation);
        this.latestTranslation = "#" + sentence_element.id + "translation";
    }
    removeLine(sentence_element) {
        delete this.translations[sentence_element.id];
        this.translations = Object.assign({}, this.translations);
    }
    updateTranslation(sentence_id, text) {
        this.translations[sentence_id] = text;
        //console.log(JSON.stringify(this.translations));
    }
    handleImageFile(file, pageIndex) {
        // verify the user has uploaded an  image file.
        if (!file.type.toLowerCase().startsWith("image/")) {
            this.invalidImages[pageIndex] = {
                fileName: file.name,
                pageIndex: pageIndex,
            };
            this.invalidImages = Object.assign({}, this.invalidImages);
            return;
        }
        // forcibly remove the error message associated
        // with this page.
        if (pageIndex in this.invalidImages) {
            delete this.invalidImages[pageIndex];
            this.invalidImages = Object.assign({}, this.invalidImages);
        }
        this.images[pageIndex] = URL.createObjectURL(file);
        this.images = Object.assign({}, this.images); // Using spread operator as advised https://stenciljs.com/docs/reactive-data#updating-an-object
    }
    deleteImage(pageIndex) {
        // release memory allocated by createObjectURL
        if (this.images[pageIndex].startsWith("blob:")) {
            URL.revokeObjectURL(this.images[pageIndex]);
        }
        const newImage = {};
        newImage[pageIndex] = null;
        this.images = Object.assign(Object.assign({}, this.images), newImage); // Using spread operator as advised https://stenciljs.com/docs/reactive-data#updating-an-object
    }
    /**
     * Render main component
     */
    render() {
        return (index.h("div", { key: '9e97168f2185f956462e96f9f36e47cdb02b66cb', id: "read-along-container", class: "read-along-container" }, index.h("div", { key: 'ed2e6c564afff98609d43bfecd025dd387a9cc39', id: "title__slot__container" }, index.h("h1", { key: '37cab34fce33269faa2358551a6d1c915b415cbd', class: "slot__header" }, index.h("slot", { key: 'bd3b4811eb6a103013a23cbc2d3527b24882a1a3', name: "read-along-header" })), index.h("h3", { key: '1b9f5380c25d7078c8584cb6c03d0fb667537a4e', class: "slot__subheader" }, index.h("slot", { key: '449845200d61903a88d1d206890b3a01b87f4e39', name: "read-along-subheader" }))), Object.entries(this.assetsStatus).map(([assetType, code]) => {
            if (code === ERROR_PARSING) {
                let path = this.getPathFromAssetType(assetType);
                return (index.h("error-message", { msg: this.getI18nString("parse-error", {
                        FILETYPE: assetType,
                        FILENAME: path,
                    }), data_cy: assetType + "-error" }));
            }
            if (code === ERROR_LOADING) {
                let path = this.getPathFromAssetType(assetType);
                return (index.h("error-message", { msg: this.getI18nString("loading-error", {
                        FILETYPE: assetType,
                        FILENAME: path,
                    }), data_cy: assetType + "-error" }));
            }
        }), this.alignment_failed && this.assetsStatus.RAS === LOADED && (index.h("error-message", { key: 'eaf54cd7fc20104524300f7a953d09cb82973f42', msg: this.getI18nString("alignment-error"), data_cy: "alignment-error" })), this.assetsStatus.RAS === LOADED &&
            Object.values(this.invalidImages).map((invalidImage) => {
                return (index.h("error-message", { msg: this.getI18nString("image-error", {
                        FILENAME: invalidImage.fileName,
                        PAGENUMBER: (invalidImage.pageIndex + 1).toString(),
                    }), timeout: DEFAULT_ERROR_TIMEOUT_MS, data_cy: "invalid-image-file", onExpired: () => {
                        // we don't need to be reactive here, the error message
                        // is no longer visible it is sufficient to remove
                        // its entry from the invalidImages object.
                        delete this.invalidImages[invalidImage.pageIndex];
                    } }));
            }), index.h("div", { key: 'a61e2c9b732b0b984284eb89992dfc4e68fcb359', onScroll: () => {
                this.handleScrollEvent();
            }, "data-test-id": "text-container", class: "pages__container" +
                " theme--" +
                this.userPreferences.theme +
                " " +
                this.pageScrolling }, this.showGuide ? index.h(this.Guide, null) : null, this.assetsStatus.RAS == LOADED &&
            this.parsed_text.map((page) => (index.h(this.Page, { pageData: page }))), this.hasLoaded < 2 && index.h("div", { key: '1c11b5f5a2a24bc4665e518847083e84e8ba9075', class: "loader" })), this.settingsVisible && (index.h("div", { key: 'bd23100cafa0691bc14f78d3ed601db07b730a1f', class: "settings-background", onClick: () => (this.settingsVisible = false) })), this.settingsVisible && index.h(this.Settings, { key: '3b424d3cae6aec26b2db79cfc342a80611a97998' }), this.alignment_failed || (index.h("div", { key: 'b112277b73af8aa0989f7bc2eee89e8945f2439c', onClick: (e) => this.goToSeekFromProgress(e), id: "all", "data-test-id": "progress-bar", class: "overlay__container theme--" +
                this.userPreferences.theme +
                " background--" +
                this.userPreferences.theme }, this.svgOverlay ? index.h(this.Overlay, null) : null)), this.annotationsMenuVisible && index.h(this.AnnotationsMenu, { key: '5184e678db807b007c2317883ee1d5a36b983a54' }), this.assetsStatus.AUDIO == LOADED && index.h(this.ControlPanel, { key: 'f5269089e11c1c34875ed5efcd5f7123e08115a7' }), this.cssUrl && this.cssUrl.match(".css") != null && (index.h("link", { key: '166f32c96ce9dd8d838f6f177e293f8c1dc23eb9', href: this.cssUrl, rel: "stylesheet" }))));
    }
    static get assetsDirs() { return ["assets"]; }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "audio_howl_sprites": [{
                "wheelHandler": 0
            }]
    }; }
};
ReadAlongComponent.style = stylesCss();

exports.error_message = ErrorMessage;
exports.read_along = ReadAlongComponent;
//# sourceMappingURL=error-message.read-along.entry.cjs.js.map

//# sourceMappingURL=error-message_2.cjs.entry.js.map